Инженерная группа Интернета (IETF) К. Борман 
Запрос на комментарии: 7959 Universitaet Bremen 
Обновления TZI : 7252 Z. Shelby, Ed. 
Категория: Standards Track ARM 
ISSN: 2070-1721 август 2016 

https://datatracker.ietf.org/doc/rfc7959/ Google translate 2021

Блочные передачи в ограниченном протоколе приложений (CoAP)

# 1. Введение 
Работа над ограниченными средами RESTful (CoRE) направлена ​​на реализацию 
архитектуры передачи репрезентативного состояния (REST) ​​в подходящей 
форме для большинства пользователей. узлы с ограничениями (например, микроконтроллеры с
ограниченное ОЗУ и ПЗУ [RFC7228]) и сети (например, IPv6 через маломощные 
беспроводные персональные сети (6LoWPAN) [RFC4944]) 
[RFC7252]. Протокол CoAP предназначен для предоставления 
сервисов RESTful [REST], аналогичных HTTP [RFC7230], при этом уменьшая сложность 
реализации, а также размер пакетов, которыми обмениваются, чтобы 
сделать эти сервисы полезными в сильно ограниченной сети с сильно 
ограниченными узлами. 

Эта цель требует сдержанности в ряде иногда противоречащих друг другу способов: 

* уменьшение сложности реализации, чтобы минимизировать размер кода, 

* уменьшение размеров сообщений, чтобы минимизировать количество
  фрагменты, необходимые для каждого сообщения (чтобы максимизировать вероятность 
  доставки сообщения), количество необходимой мощности передачи 
  и загрузка канала с ограниченной полосой пропускания, 

* снижение требований к среде, таких как стабильное хранилище, 
  хорошие источники случайности, или возможности взаимодействия с пользователем. 

   

Поскольку CoAP основан на транспорте дейтаграмм, таком как UDP или Datagram 
Transport Layer Security (DTLS), максимальный размер представлений ресурсов, 
которые могут быть переданы без излишней 
фрагментации, ограничен. Кроме того, не все 
представления ресурсов поместятся в один пакет канального уровня
сеть с ограничениями, которая может вызвать фрагментацию уровня адаптации, 
даже если фрагментация уровня IP не требуется. Использование фрагментации 
(либо на уровне адаптации, либо на уровне IP) для транспортировки 
более крупных представлений возможно вплоть до максимального размера 
базового протокола дейтаграмм (например, UDP), но процесс 
фрагментации / повторной сборки обременяет нижние уровни. 
состояние разговора, которое лучше управляется на уровне приложения. 

Настоящая спецификация определяет пару опций CoAP для обеспечения 
блочного доступа к представлениям ресурсов. Параметры блока 
предоставляют минимальный способ передачи более крупных представлений ресурсов в
блочная мода. Основная цель - избежать необходимости 
создавать состояние диалога на сервере для блочных 
запросов GET . (Невозможно полностью избежать создания 
состояния диалога для POST / PUT, если создание / замена ресурсов должно быть 
атомарным; если это свойство не требуется, 
в этом случае также нет необходимости создавать состояние диалога с сервером.)  
Блочная передача реализована в виде комбинаций обменов, каждый 
из которых выполняется в соответствии с базовым протоколом CoAP [RFC7252].

Каждый обмен в такой комбинации регулируется спецификациями 
в [RFC7252], включая спецификации контроля перегрузки 
(раздел 4.7 [RFC7252]) и соображения безопасности 
(раздел 11 [RFC7252]; дополнительные соображения безопасности затем 
применяются к передачам, как целиком, см. раздел 7). Настоящая 
спецификация минимизирует ограничения, которые она добавляет к этим базовым 
обменам; однако не все варианты использования CoAP очень полезны 
при поблочной передаче (например, использование неподтвержденных запросов 
в поблочных передачах вне варианта использования, описанного в разделе 2.8, 
повысит общую вероятность недоставки). Быть идеально
Понятно, что настоящая спецификация также не снимает никаких 
ограничений, налагаемых базовой спецификацией, на которую она строго накладывается 
. Например, 
двусторонние пакеты ограничиваются контролем перегрузки, описанным в разделе 4.7 [RFC7252] (NSTART как 
предел для инициирования обмена, PROBING_RATE как предел для отправки 
без ответа); блочные передачи не могут отправлять / запрашивать больше 
трафика, чем клиент может отправлять / запрашивать с того же 
сервера без блочного режима. 

В некоторых случаях настоящая спецификация РЕКОМЕНДУЕТ, чтобы клиент 
выполнял последовательность поблочных передач «без неоправданной задержки».
Это не может быть сформулировано как требование совместимости, но это 
ожидание от качества реализации. И наоборот, ожидается 
, что серверам не придется изо всех сил обслуживать 
клиентов, которым требуется значительное время для завершения поблочной передачи. 
Например, для блочного GET, если ресурс изменяется во время его выполнения 
, тег объекта (ETag) для следующего полученного блока может быть 
другим. Чтобы этого не происходило постоянно для быстро меняющегося 
ресурса, сервер МОЖЕТ попытаться сохранить кэш для конкретного 
клиента в течение короткого промежутка времени. Ожидается, что время 
жизни такого кеша может быть коротким, порядка нескольких
ожидаемое время приема- 
передачи , считая от предыдущего переданного блока . 

Таким образом, эта спецификация добавляет пару параметров блока к CoAP, 
которые могут использоваться для поблочных передач. Преимущества использования этих 
опций включают в себя: 

* Передачи большего размера, чем могут быть размещены в ограниченных 
пакетах канального уровня сети, могут выполняться меньшими блоками. 

* На уровне адаптации или уровне IP не создается трудноуправляемое состояние диалога для фрагментации. 

* Передача каждого блока подтверждается, что позволяет 
при необходимости индивидуальную повторную передачу. 

* Обе стороны имеют право голоса в размере блока, который фактически будет 
      использоваться. 

* Полученные в результате обмены легко понять с 
      помощью инструментов анализатора пакетов и, следовательно, вполне доступны для отладки. 

* При необходимости, параметры блока также могут использоваться (без изменений) для 
      обеспечения произвольного доступа к блокам размером со степенью двойки в представлении 
      ресурса. 


   Реализация CoAP, которая не поддерживает эти параметры, обычно 
   ограничена размером представлений, которыми можно обмениваться, 
   см. Раздел 4.6 [RFC7252]. Несмотря на то, что варианты критичны,
   сервер может решить начать использовать их незапрашиваемым образом в 
   ответе. Не было приложено никаких усилий, чтобы предоставить 
   механизм индикации возможностей, поддерживающий это решение: поскольку 
   механизмы поблочной передачи являются фундаментальными для использования CoAP для представлений 
   размером более одного килобайта, ожидается, что они будут 
   реализованы очень широко. 

   Ключевые слова «ДОЛЖЕН», «НЕ ДОЛЖЕН», «ОБЯЗАТЕЛЬНО», « 
   ДОЛЖЕН», «НЕ ДОЛЖЕН », «ДОЛЖЕН», «НЕ ДОЛЖЕН», «РЕКОМЕНДУЕТСЯ», «НЕ РЕКОМЕНДУЕТСЯ», «МОЖЕТ» и 
   «НЕОБЯЗАТЕЛЬНО» "в этом документе следует интерпретировать, как описано в RFC 
   2119,

   В этом документе термин «байт» используется в его теперь обычном смысле 
   как синоним «октет». 

   Там, где объясняется битовая арифметика, в этом документе используются обозначения, 
   знакомые по языку программирования C, за исключением того, что оператор 
   «**» означает возведение в степень. 

# 2. Блочная передача данных. 

   Как обсуждалось во введении, существуют веские причины для ограничения 
   размера дейтаграмм в ограниченных сетях: 

* максимальным размером дейтаграммы (~ 64 КБ для UDP); 
* желанием избежать фрагментации IP (MTU составляет 1280 для IPv6) 
* стремлением избежать фрагментации уровня адаптации (60-80 байтов для 6LoWPAN [RFC4919])


   Когда представление ресурса больше, чем может быть удобно 
   передано в полезной нагрузке одной дейтаграммы CoAP, 
   можно использовать параметр «Блок», чтобы указать поблочную передачу. Поскольку полезные данные могут быть 
   отправлены как с запросами, так и с ответами по стандарту , эта спецификация 
   предоставляет два отдельных варианта для каждого направления передачи полезной нагрузки. 
   При именовании этих опций (для поблочных передач, а также в 
   разделе 4) мы используем число 1 («Block1», «Size1») для обозначения 
   передачи представления ресурса, относящегося к запросу,




   и число 2 («Блок2», «Размер2») для обозначения передачи представления 
   ресурса для ответа. 

   В дальнейшем термин «полезная нагрузка» будет использоваться для фактического 
   содержимого одного сообщения CoAP, т. Е. Одного передаваемого блока 
   , в то время как термин «тело» будет использоваться для всего 
   представления ресурса, которое передается в блочный 
   мод. Параметр Content-Format применяется к телу, а не к 
   полезной нагрузке; в частности, границы между блоками могут находиться в 
   местах, которые не разделяют целые блоки с точки зрения структуры, 
   кодирования или кодирования содержимого, используемых Content-Format. (По аналогии,
   Опция ETag, определенная в разделе 5.10.6 [RFC7252], применяется ко 
   всему представлению ресурса и, следовательно, к телу 
   ответа.) 

   В большинстве случаев все блоки передаются для тела (кроме 
   последнего) будет такого же размера. (Если в первом запросе используется 
   больший размер блока, чем предпочитает получатель, в последующих запросах будет 
   использоваться предпочтительный размер блока.) Размер блока не фиксируется 
   протоколом. Чтобы упростить реализацию, параметры 
   блока поддерживают только небольшой диапазон размеров блоков, равных степени двойки, 
   от 2 ** 4 (16) до 2 ** 10 (1024) байтов. Поскольку тела часто не будут
   равномерно разделить на выбранный размер блока, равный степени двойки, размер 
   не должен достигаться в последнем блоке (но даже для последнего блока 
   выбранный размер степени двойки все равно будет указан в 
   поле размера блока Блочный вариант). 

## 2.1. Параметры Block2 и Block1 

       +-----+---+---+---+---+--------+--------+--------+---------+
       | No. | C | U | N | R | Name   | Format | Length | Default |
       +-----+---+---+---+---+--------+--------+--------+---------+
       |  23 | C | U | - | - | Block2 | uint   |    0-3 | (none)  |
       |     |   |   |   |   |        |        |        |         |
       |  27 | C | U | - | - | Block1 | uint   |    0-3 | (none)  |
       +-----+---+---+---+---+--------+--------+--------+---------+
    
                       Table 1: Block Option Numbers

   Параметры как Block1, так и Block2 могут присутствовать как в сообщениях запроса, так и в сообщениях ответа. В любом случае опция Block1 относится к полезной нагрузке запроса, а опция Block2 относится к полезной нагрузке ответа.


   Следовательно, для методов, определенных в [RFC7252], блок 1 полезен с запросами POST и PUT, несущими полезную нагрузку, и их ответами.
   Блок 2 полезен с запросами GET, POST и PUT и их ответами, несущими полезную нагрузку (2.01, 2.02, 2.04 и 2.05 - см. Раздел 5.5 [RFC7252]).

   Если Block1 присутствует в запросе или Block2 в ответе (т. Е.
   в этом сообщении к полезной нагрузке, к которой он относится) он указывает
   поблочная передача и описывает, как эта конкретная блочная полезная нагрузка формирует часть всего передаваемого тела («описательный
   использование "). Там, где он присутствует в противоположном направлении, он обеспечивает
   дополнительный контроль над тем, как эта полезная нагрузка будет сформирована или была
   обработано («контроль использования»).

   Предполагается, что реализация любой из опций Block является необязательной.
   Однако, если он присутствует в сообщении CoAP, он ДОЛЖЕН быть обработан (или сообщение отклонено); поэтому он определен как критический вариант. Любая опция Block НЕ ДОЛЖНА встречаться более одного раза в одном сообщении.

## 2.2. Структура варианта блока 

   В параметре блока 
   (Блок1 или Блок2) может потребоваться передача трех элементов информации : 

* размер блока (SZX); 

* следуют ли еще блоки (M); 

* относительный номер блока (ЧИСЛО) в последовательности блоков 
      заданного размера. 

   Значение параметра Block - это 
   целое число без знака переменного размера (от 0 до 3 байтов) (uint, см. Раздел 3.2 [RFC7252]). Это целочисленное 
   значение кодирует эти три поля, см. Рисунок 1. (Из-за CoAP
   uint-encoding правила, когда все числа NUM, M и SZX равны нулю, 
   будет отправлено нулевое целое число.)  

           0
           0 1 2 3 4 5 6 7
          +-+-+-+-+-+-+-+-+
          |  NUM  |M| SZX |
          +-+-+-+-+-+-+-+-+
      
           0                   1
           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |          NUM          |M| SZX |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      
           0                   1                   2
           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |                   NUM                 |M| SZX |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      
                       Figure 1: Block Option Value

 Размер блока кодируется с использованием трехбитового целого числа без знака (от 0 для 
   2 ** 4 байтов до 6 для 2 ** 10 байтов), которое мы называем «SZX» (« 
   показатель размера »); тогда фактический размер блока равен «2 ** (SZX + 4)». SZX 
   передается в трех младших битах значения опции 
   (т. Е. «Val & 7», где «val» - значение опции). 

   Четвертый младший бит, M или "
   указывает, следуют ли следующие блоки или текущая поблочная 
   передача является последним передаваемым блоком. 

   Значение параметра, деленное на шестнадцать (поле ЧИСЛО), представляет собой порядковый 
   номер блока, передаваемого в данный момент, начиная с нуля. 
   Таким образом, текущая передача имеет размер в байтах, начиная 
   с байта «NUM << (SZX + 4)». 

   Замечание по реализации: для удобства реализации «(val & ~ 0xF) 
      << (val & 7)», т. Е. Значение параметра с замаскированными последними 4 битами 
      , смещенное влево на значение SZX, дает байт 
      позиция первого байта передаваемого блока. 

   В частности,
   Параметр, значение полей параметра определяется следующим образом: 

   NUM: Номер блока, указывающий номер блока, который запрашивается или 
      предоставляется. Номер блока 0 указывает первый блок тела 
      (т. Е. Начиная с первого байта тела).  

   M: Больше флаг («не последний блок»). Для наглядного использования этот флаг, 
      если он не установлен, указывает, что полезная нагрузка в этом сообщении является последним 
      блоком в теле; если установлено, это означает, что есть один или 
      несколько дополнительных блоков. Когда опция Block2 используется в
      для запроса на получение определенного номера блока ("использование управления") 
      бит M ДОЛЖЕН быть отправлен как ноль и игнорироваться при приеме. (В 
      опции Block1 в ответе флаг M используется для обозначения 
      атомарности, см. Ниже.) 

   SZX: Размер блока. Размер блока представлен как 
      трехбитовое целое число без знака, указывающее размер блока в степени 
      двойки. Таким образом, размер блока = 2 ** (SZX + 4). Допустимые значения SZX 
      от 0 до 6, т. Е. Минимальный размер блока составляет 2 ** (0 + 4) = 16, а 
      максимальный - 2 ** (6 + 4) = 1024. Значение 7 для SZX (что будет 
      указать размер блока 2048) зарезервировано, т. е. НЕ ДОЛЖНО быть отправлено
      и ДОЛЖНЫ приводить к появлению кода ответа 4,00 Bad Request при получении 
      запроса. 

   Для параметров Блок1 и Блок2 нет значения по умолчанию. Отсутствие 
   одной из этих опций эквивалентно значению опции 0 по 
   отношению к значению NUM и M, которое может быть указано в опции, 
   т. Е. Указывает, что текущий блок является первым и единственным блоком 
   передачи (блок номер 0, бит M не установлен). Однако, в 
   отличие от явного значения 0, которое указывало бы на SZX, 
   равное 0 и, следовательно, значение размера в 16 байт, отсутствует конкретный явный размер, 
   подразумеваемый отсутствием опции - размер остается неопределенным.
   (Как и для любого uint, явное значение 0 эффективно указывается параметром 
   нулевой длины; это, следовательно, отличается по семантике от 
   отсутствия параметра.) 

## 2.3. Параметры блокировки в запросах и ответах Параметры 

Блоки  используются в одной из трех ролей: 
* В описательном использовании, т. Е. Параметр Block2 в ответе (например, 
  ответ 2.05 для GET) или параметр Block1 в запросе (PUT 
  или POST): 

* Поле NUM в значении опции описывает, какой номер блока 
 содержится в полезных данных этого сообщения. 

* Бит M указывает, нужно ли 
 передавать дополнительные блоки для завершения передачи этого тела.

* Размер блока, подразумеваемый SZX, ДОЛЖЕН соответствовать размеру 
 полезной нагрузки в байтах, если установлен бит M. (SZX не ​​управляет 
  размером полезной нагрузки, если M не установлено). Для блока 2, если запрос 
  предлагает большее значение SZX, следующий запрос ДОЛЖЕН сместить SZX  
  до размера, указанного в ответе. (В результате, 
  если сервер использует меньший из (1) предпочтительного размера блока 
  и (2) запрошенного размера блока, все блоки для тела используют один и тот 
  же размер блока.)


* Опция Block2 при использовании элемента управления в запросе (например, GET): 

    * Поле NUM в опции Block2 дает номер блока полезных данных, которые запрашиваются для возврата в ответе. 

    * В этом случае бит M не работает и ДОЛЖЕН быть установлен в ноль. 

    * Указанный размер блока (SZX) предполагает размер блока (в случае 
    блока с номером 0) или повторяет размер блока предыдущих 
    полученных блоков (в случае ненулевого номера блока). 

* Опция Block1 при использовании элемента управления в ответе (например, 
      ответ 2.xx на запрос PUT или POST): 

  * Поле NUM опции Block1 указывает номер блока
     признается. 
  
  * Если в запросе был установлен бит M, сервер может выбрать 
     , действовать ли с каждым блоком отдельно, без памяти, или 
     обрабатывать запрос для всего тела атомарно, 
     или любое их сочетание. 
     
     + Если в ответе также установлен бит M, это указывает на то, что 
        этот ответ не несет окончательного кода ответа на 
        запрос, т. Е. Сервер собирает дополнительные блоки из той 
        же конечной точки и планирует выполнить запрос атомарно 
        (например, действует только при получении последнего блока 
        полезной нагрузки). В этом случае ответ НЕ ДОЛЖЕН содержать
        Блок2 Вариант. 
  
     + И наоборот, если бит M не установлен, даже если он был установлен в 
        запросе, это указывает на то, что блочный запрос был выполнен 
        сейчас специально для этого блока, и ответ несет 
        окончательный ответ на этот запрос (и на любые предыдущие 
        с бит M, установленный в опции Block1 ответа в этой 
        последовательности поблочных передач); 
        ожидается, что клиент по-прежнему будет продолжать посылать дополнительные блоки, 
        метод запроса для которых также может быть или не может быть применен для каждого блока. 
        (Обратите внимание, что ресурс сейчас находится в частично обновленном состоянии;
        этот подход уместен только в том случае, если 
        допустимо раскрытие такой версии.  Клиент может уменьшить 
        окно, быстро продолжив обновление ресурса или, в 
        случае сбоя, перезапустив обновление.) 
  * Наконец, размер блока SZX, указанный в параметре Control Block1 Option, 
     указывает наибольший размер блока, предпочитаемый сервером для 
     передачи к ресурсу, который является таким же или меньшим, чем 
     тот, который использовался при первоначальном обмене; клиент ДОЛЖЕН использовать
     этот размер блока или меньший во всех дальнейших запросах в 
     последовательности передачи, даже если это означает изменение размера блока 
     (и, возможно, соответствующее масштабирование номера блока) с этого момента.
  
   Используя один или оба параметра Block, одну операцию REST можно разделить 
   на несколько обменов сообщениями CoAP. Как указано в [RFC7252], 
   каждый из этих обменов сообщениями использует свой собственный идентификатор сообщения CoAP. 
  
   Опция Content-Format, отправляемая с запросами или ответами, ДОЛЖНА 
   отражать Content-Format всего тела. Если блоки 
   тела ответа прибывают с разными параметрами Content-Format, 
   клиент должен решать, как обрабатывать эту ошибку (обычно он прерывает любую ошибку).
   текущий поблочный перевод). Если блоки запроса поступают на 
   сервер с несоответствующими параметрами формата содержимого, сервер НЕ ДОЛЖЕН 
   собирать их в один запрос; обычно это приводит к 
   ошибочному ответу 4.08 (Request Entity Incomplete, Раздел 2.9.2) на 
   несоответствующем блоке. 

## 2.4. Использование опции Block2 

   Когда на запрос дан ответ, содержащий опцию Block2 
   с установленным битом M, запрашивающая сторона может получить дополнительные блоки представления 
   ресурса, отправив дальнейшие запросы с теми же 
   опциями, что и исходный запрос, и опцией Block2, дающей 
   номер блока и желаемый размер блока. В запросе клиент ДОЛЖЕН установить
   Бит M опции Block2 равен нулю, и сервер ДОЛЖЕН игнорировать его при 
   приеме. 

   Чтобы повлиять на размер блока, используемого в ответе, запрашивающая 
   сторона МОЖЕТ также использовать опцию Block2 в начальном запросе, задав желаемый 
   размер, нулевой номер блока и нулевой бит M. Сервер ДОЛЖЕН использовать 
   указанный размер блока или меньший размер. Любые дальнейшие блочные 
   запросы для блоков помимо первого ДОЛЖНЫ указывать тот же 
   размер блока, который использовался сервером в ответе на первый 
   запрос, который дал желаемый размер с использованием опции Block2. 

   После того, как запрашивающая сторона использует параметр Block2 и 
   был получен первый ответ с возможно скорректированным размером блока, все дальнейшие
   запросы в одной блочной передаче в конечном итоге будут сходиться в соответствии со стандартами   
   с использованием того же размера, за исключением того, что может не хватить контента для 
   заполнения последнего блока ( тот, который вернулся с не установленным битом M). (Обратите внимание, 
   что клиент может начать использовать опцию Block2 во втором запросе 
   после того, как первый запрос без опции Block2 привел к 
   опции Block2 в ответе.) Сервер использует размер блока, указанный в 
   опции запроса, или меньший размер, но запрашивающая сторона ДОЛЖНА принять к 
   сведению фактический размер блока, использованного в ответе, который он получает на свой
   первоначальный запрос и приступить к его использованию в последующих запросах. 
   Поведение сервер должен гарантировать , что такое поведение клиента приводит к тому 
   же размера блока для всех ответов в последовательности (за исключением последнего 
   один с M бит не установлен, и , возможно , первым , если первоначальный 
   запрос не содержит вариант block2) . 

   Блочная передача может использоваться для ресурсов GET, 
   представления которых полностью статичны (не меняются с течением времени вообще, 
   например, в схеме, описывающей устройство), или для динамически изменяющихся 
   ресурсов. В последнем случае параметр Block2 СЛЕДУЕТ использовать 
   вместе с параметром ETag ([RFC7252], раздел 5.10.6), чтобы
   убедитесь, что 
   собираемые блоки принадлежат одной и той же версии представления: серверу СЛЕДУЕТ включать параметр ETag в каждый 
   ответ. Если доступна опция ETag, клиент при 
   повторной сборке представления из обмениваемых блоков ДОЛЖЕН 
   сравнить опции ETag. Если параметры ETag не совпадают при 
   передаче GET , запрашивающая сторона может попытаться получить 
   свежие значения для блоков, которые он получил первым. Чтобы минимизировать 
   результирующую неэффективность, сервер МОЖЕТ кэшировать текущее значение 
   представления для текущей последовательности запросов. (Сервер может 
   идентифицировать последовательность по комбинации запрашивающей конечной точки
   и URI является одним и тем же в каждом блочном запросе.) Обратите внимание, 
   что эта спецификация не требует, чтобы сервер 
   устанавливал какое-либо состояние; однако серверы, которые предлагают быстро меняющиеся 
   ресурсы, могут, таким образом, сделать невозможным получение клиентом 
   согласованного набора блоков. Клиенты, которые хотят получить 
   все блоки ресурса, ДОЛЖНЫ стремиться сделать это без неоправданной задержки. 
   Серверы могут полностью рассчитывать на то, что они смогут сбросить любое кешированное состояние по истечении 
   периода EXCHANGE_LIFETIME ([RFC7252], раздел 4.8.2) после 
   последнего доступа к состоянию, однако нет необходимости всегда 
   сохранять состояние так долго.

   Опция Block2 не предоставляет возможности для одной конечной точки выполнять 
   несколько одновременно выполняемых 
   операций поблочной передачи полезной нагрузки (например, GET) на один и тот же ресурс. Это редко является 
   требованием, но в качестве обходного пути клиент может изменить ключ кеша 
   (например, используя один из нескольких URI для доступа к ресурсам с той же 
   семантикой, или изменив выборную опцию, безопасную для прокси).  

## 2.5. Использование опции Block1 
   В запросе с полезной нагрузкой (например, PUT или POST), Block1

   Параметр относится к полезной нагрузке в запросе (описательное использование). 

   В ответ на запрос с полезной нагрузкой (например, 
   передача PUT или POST ) размер блока, указанный в опции Block1, указывает 
   предпочтительный размер блока сервера для этого ресурса ( 
   использование управления ). Очевидно, что на этом этапе первый блок уже был 
   передан клиентом без использования этих знаний. Тем не менее, 
   клиент ДОЛЖЕН учитывать указанные предпочтения и для всех дальнейших 
   блоков использовать размер блока, предпочитаемый сервером, или меньший. 
   Обратите внимание, что любое уменьшение размера блока может означать, что второй 
   запрос начинается с номера блока больше единицы, так как первый запрос
   запрос уже передал несколько блоков, считая меньшим 
   размером. 

   Чтобы противостоять влиянию фрагментации уровня адаптации на 
   вероятность доставки пакета, клиент может отказаться от повторной передачи 
   запроса с относительно большой полезной нагрузкой даже до достижения MAX_RETRANSMIT 
   и попробовать повторить запрос как блочную 
   передачу с меньшая полезная нагрузка. Обратите внимание, что эта новая попытка является 
   новой транзакцией на уровне сообщений и требует нового идентификатора сообщения. 
   (Из-за неопределенности того, 
   был ли потерян запрос или подтверждение, эта стратегия полезна в основном для 
   идемпотентных запросов.)

   При поблочной передаче полезной нагрузки запроса (например, PUT или POST), 
   которая предназначена для атомарной реализации на 
   сервере, фактическое создание / замена происходит во время 
   последнего блока, т. Е. Блока с неустановленным битом M в опции Block1 
   принимается. В этом случае все успешные ответы на незавершенные блоки 
   содержат код ответа 2.31 (Продолжить, раздел 2.9.1). Если не все 
   предыдущие блоки доступны на сервере во время обработки 
   последнего блока, передача завершается неудачей и 
   ДОЛЖЕН быть возвращен код ошибки 4.08 (Request Entity Incomplete, раздел 2.9.2). Сервер 
   также МОЖЕТ вернуть код ошибки 4.08 для любого (окончательного или неокончательного) блока 1.
   передача не по порядку; поэтому клиентам, не имеющим 
   специальных механизмов для обработки этого случая, СЛЕДУЕТ всегда начинать с 
   нулевого блока и отправлять следующие блоки по порядку. 

   Одна из причин, по которой клиент может столкнуться с кодом ошибки 4.08, заключается в том, 
   что сервер уже превысил тайм-аут и отказался от 
   собираемого частичного тела запроса . Клиенты ДОЛЖНЫ стремиться к отправке всех блоков 
   запроса без неоправданной задержки. Серверы могут в полной мере рассчитывать , чтобы быть свободным , чтобы 
   отказаться от любого частичного тела запроса , когда период EXCHANGE_LIFETIME Бормана и Шелби Standards Track 

   ([RFC7252], раздел 4.8.2) истек после 
   передачи самого последнего блока ; однако от сервера не требуется 
   всегда хранить частичное тело запроса так долго. 

   Код ошибки 4.13 (Request Entity Too Large) может быть возвращен в любое 
   время сервером, у которого в настоящее время нет ресурсов для хранения 
   блоков для блочной передачи полезной нагрузки запроса, которую он намеревался 
   бы реализовать атомарным способом. (Обратите внимание, что ответ 4.13 на 
   запрос, который не использует Block1, является подсказкой для клиента, чтобы попытаться 
   отправить Block1, а ответ 4.13 с меньшим SZX в его 
   опции Block1, чем запрошенный, является подсказкой попробовать меньший SZX.)

   Блочная передача полезной нагрузки запроса, которая реализована 
   без сохранения состояния на сервере, вероятно, оставит ресурс, на котором 
   работают, в несогласованном состоянии, пока передача все еще 
   продолжается или когда клиент не завершает передачу. Эта 
   характеристика ближе к характеристикам удаленных файловых систем, чем к 
   HTTP, где состояние всегда сохраняется на сервере во время передачи. 
   Методы, хорошо известные из общего доступа к файлам (например, 
   временные ресурсы, зависящие от клиента ), могут быть использованы для смягчения этого отличия от 
   HTTP. 

   Опция Block1 не предоставляет возможности для одной конечной точки выполнять 
   несколько одновременно выполняющихся поблочных запросов передачи полезной нагрузки.
   (например, PUT или POST) операции с одним и тем же ресурсом. Запуск новой 
   блочной последовательности запросов к тому же ресурсу (до того, как 
   была завершена старая последовательность из той же конечной точки) просто перезаписывает 
   контекст, который сервер может все еще хранить. (Вероятно, это именно 
   то , что нужно в данном случае - клиент, возможно, просто перезапустился 
   и потерял свои знания о предыдущей последовательности.) 

## 2.6. Комбинирование блочной передачи с опцией наблюдения

 Опция наблюдения обеспечивает способ уведомления клиента об изменениях ресурса во времени [RFC7641]. Ресурсы, наблюдаемые 
   клиентами, могут быть больше, чем можно с комфортом обработать или
   передается в одном сообщении CoAP. Следующие правила применяются к 
   комбинации поблочных переводов с уведомлениями. 

   Отношения наблюдения всегда применимы ко всему ресурсу; 
   block2 вариант не обеспечивает способ наблюдать один блок с 
   ресурса. 

   Как и в случае с базовыми передачами GET, клиент может указать желаемый 
   размер блока в параметре Block2 в запросе GET, устанавливающем или 
   обновляющем отношения наблюдения. Если сервер поддерживает блочные 
   передачи, ему СЛЕДУЕТ принять во внимание размер блока и применить его как 
   максимальный размер ко всем уведомлениям / ответам, полученным в результате GET 
 (до тех пор, пока клиент не будет удален из списка наблюдателей или 
   запись в этом списке не будет обновлена ​​сервером, получающим 
   от клиента новый запрос GET для ресурса). 

   При отправке уведомления 2.05 (Content) сервер отправляет только 
   первый блок представления. Клиент извлекает остальную часть 
   представления, как если бы он вызвал этот первый ответ 
   запросом GET , то есть с помощью дополнительных запросов GET с параметрами Block2, 
   содержащими значения NUM больше нуля. (Это приводит к 
   передаче всего представления, даже если только некоторые из
   блоки изменились по сравнению с предыдущим уведомлением.) 

   Как и в случае с другими динамически изменяющимися ресурсами, чтобы гарантировать, 
   что повторно 
   собираемые блоки относятся к одной и той же версии представления, серверу СЛЕДУЕТ включать параметр ETag в каждый 
   ответ, а повторно собирающий клиент ДОЛЖЕН сравните параметры ETag 
   (раздел 2.4). Даже в большей степени, чем в общем случае Block2, 
   клиенты, которые хотят получить все блоки ресурса, о которых они были 
   уведомлены с помощью первого блока, ДОЛЖНЫ стремиться сделать это без 
   неоправданной задержки. 

   Примеры см. В разделе 3.4. 

## 2.7. Комбинирование Block1 и Block2 

   При обмене PUT и особенно при обмене POST как тело запроса, так и
   тело ответа может быть достаточно большим, чтобы требовать использования поблочных 
   переводов. Сначала передача тела запроса Block1 
   выполняется в обычном режиме. При обмене последним 
   слайсом этой поблочной 
   передачи ответ несет первый слайс передачи Block2 (NUM равно нулю). Чтобы продолжить эту передачу Block2, клиент 
   продолжает отправлять запросы, аналогичные запросам на этапе Block1 
   , но не учитывает параметры Block1 и включает параметр 
   запроса Block2 с ненулевым NUM. 

   Передачи блока 2, которые извлекают тело ответа для запроса, 
   использующего блок 1, ДОЛЖНЫ выполняться в последовательном порядке. 

## 2.8. Объединение Block2 с многоадресной рассылкой

   Клиент может использовать параметр Block2 в многоадресном запросе GET с 
   NUM = 0, чтобы помочь ограничить размер ответа. 

   Точно так же ответ на многоадресный запрос GET может использовать параметр Block2 
   с NUM = 0, если представление большое, или для дальнейшего 
   ограничения размера ответа.  
   В обоих случаях клиент извлекает любые дальнейшие блоки с помощью одноадресного 
   обмена; в одноадресных запросах клиент ДОЛЖЕН учитывать любые 
   предпочтения размера блока, указанные сервером в ответе на 
   многоадресный запрос.

   Другие варианты использования параметров блокировки вместе с многоадресными 
   сообщениями подлежат дальнейшему изучению. 

## 2.9. Коды ответа 

   Помимо кодов ответа, определенных в [RFC7252], эта спецификация 
   определяет два кода ответа и расширяет значение одного. 

### 2.9.1. 2.31 Продолжить 

   Этот новый код состояния успешного завершения указывает, что передача этого 
   блока тела запроса была успешной и что сервер 
   поощряет отправку дальнейших блоков, но что окончательный результат 
   всего блочного запроса еще не может быть определен. 
   Этот код ответа не возвращает никаких полезных данных . 

### 2.9.2. 4.08 Запрос объекта не завершен

   Этот новый код состояния ошибки клиента указывает на то, что сервер не 
   получил блоки тела запроса, необходимые для продолжения. 
   Клиент не отправил все блоки, не отправил их в порядке, 
   требуемом сервером, или отправил их достаточно давно, чтобы 
   сервер уже их отбросил. 

   (Обратите внимание, что одной из причин отсутствия необходимых блоков под рукой может 
   быть несоответствие Content-Format, см. Раздел 2.3. Примечание по реализации: 
   сервер может отклонить передачу Block1 с этим кодом, когда NUM! = 0 
   и другой Content-Format - указано, чем ожидалось из 
   текущего состояния ресурса. Если он реализует передачу в
   В режиме без сохранения состояния он может сопоставить Content-Format блока 
   с форматом существующего ресурса. Если он реализует передачу 
   атомарно, он может сопоставить блок с частично 
   пересобранной частью представления, которая собирается заменить 
   состояние ресурса.) 

### 2.9.3. 4.13 Слишком большой 

   объект запроса В разделе 5.9.2.9 [RFC7252] код ответа 4.13 (Request 
   Entity Too Large) определяется как HTTP 413 «Request Entity Too 
   Large». [RFC7252] также рекомендует, чтобы этот ответ ДОЛЖЕН включать параметр 
   Size1 (раздел 4), чтобы указать максимальный размер объекта запроса, который 
   сервер может и желает обработать, если только сервер не
   не в состоянии сделать эту информацию доступной.  
   г. Настоящая спецификация позволяет серверу возвращать этот 
   код ответа в любое время во время передачи Block1, чтобы указать, что в 
   настоящее время у него нет ресурсов для хранения блоков для передачи, которую 
   он намеревался реализовать атомарно. Это также позволяет 
   серверу возвращать ответ 4.13 на запрос, который не 
   использует Block1 в качестве подсказки для клиента, чтобы попытаться отправить Block1. 
   Наконец, ответ 4.13 на запрос с опцией Block1 (элемент управления



   см. раздел 2.3), где ответ содержит меньший SZX в 
   его опции Block1, это намек на то, чтобы попробовать этот меньший SZX. 

## 2.10. Соображения по поводу кеширования

В этой спецификации делается попытка оставить    открытыми для кешей различные стратегии реализации , в частности, в прокси-серверах кэширования. 

Например, кэш может кэшировать блоки по отдельности, но также 
   может ждать получения полного представления, прежде чем обслуживать его    части. Частичное кэширование может быть более эффективным в кросс-прокси     (эквивалентном потоковому HTTP-прокси). Кэшированный блок (частично    кэшированный ответ) может использоваться вместо полного ответа для     удовлетворения блочного запроса, который представлен в кэш. Обратите внимание, что    разные блоки могут иметь разные значения Max-Age, так как они     передаются в разное время. Ответ с блоком обновляет     свежесть полного представления. Можно     проверить отдельные блоки , а проверка отдельного блока подтверждает полное    представление. Ответ с использованием параметра Block1 Option 
   с установленным битом M делает недействительными кэшированные ответы для целевого URI. 

   Кэш или прокси, которые объединяют ответы (например, для разделения блоков в 
   запросе или увеличения размера блока в ответе, или кросс-прокси), 
   возможно, потребуется объединить ответы 2.31 и 2.01 / 2.04; сервер без состояния 
   может отвечать 2.01 только на первый блок Block1
   передано, что преобладает над ответами 2,04 для последующих блоков. 

   If-None-Match корректно работает только с запросами блока 1 с (NUM = 0) 
   и НЕ ДОЛЖЕН использоваться в запросах блока 1 с NUM! = 0. 

# 3. Примеры 

   В этом разделе дается несколько коротких примеров с потоками сообщений для 
   блоков. GET, а также для PUT или POST. Эти примеры демонстрируют 
   базовую операцию, операцию при наличии 
   повторных передач и примеры операции 
   согласования размера блока . 




   Во всех этих примерах параметр блока показан в разложенном виде с 
   указанием типа параметра блока (1 или 2), за которым следует двоеточие, а 
   затем номер блока (ЧИСЛО), дополнительный бит (M) и показатель размера блока 
   ( 2 ** (SZX + 4)) через косую черту. Например, значение параметра Block2, 
   равное 33, будет отображаться как 2: 2/0/32), а значение параметра Block1 Option, равное 
   59, будет отображаться как 1: 3/1/128. 

   Как и в [RFC7252], «MID» используется как сокращение для «ID сообщения». 

## 3.1. Примеры блока 2 

   В первом примере (рисунок 2) показан запрос GET, разделенный на 
   три блока. Сервер предлагает размер блока 128, и 
   клиент соглашается. Первые два ACK содержат полезную нагрузку 128 байтов.
   каждый, а третий ACK содержит полезную нагрузку от 1 до 128 байтов. 


       CLIENT                                                     SERVER
         |                                                            |
         | CON [MID=1234], GET, /status                       ------> |
         |                                                            |
         | <------   ACK [MID=1234], 2.05 Content, 2:0/1/128          |
         |                                                            |
         | CON [MID=1235], GET, /status, 2:1/0/128            ------> |
         |                                                            |
         | <------   ACK [MID=1235], 2.05 Content, 2:1/1/128          |
         |                                                            |
         | CON [MID=1236], GET, /status, 2:2/0/128            ------> |
         |                                                            |
         | <------   ACK [MID=1236], 2.05 Content, 2:2/0/128          |
    
                      Figure 2: Simple Block-Wise GET

   Во втором примере (рисунок 3) клиент ожидает поблочной 
   передачи (например, из-за указание размера в 
   описании формата ссылки [RFC6690]) и отправляет предложение размера блока. Все ACK
   сообщения, кроме последнего, несут 64 байта полезной нагрузки; последний 
   содержит от 1 до 64 байтов. 

       CLIENT                                                     SERVER
         |                                                          |
         | CON [MID=1234], GET, /status, 2:0/0/64           ------> |
         |                                                          |
         | <------   ACK [MID=1234], 2.05 Content, 2:0/1/64         |
         |                                                          |
         | CON [MID=1235], GET, /status, 2:1/0/64           ------> |
         |                                                          |
         | <------   ACK [MID=1235], 2.05 Content, 2:1/1/64         |
         :                                                          :
         :                          ...                             :
         :                                                          :
         | CON [MID=1238], GET, /status, 2:4/0/64           ------> |
         |                                                          |
         | <------   ACK [MID=1238], 2.05 Content, 2:4/1/64         |
         |                                                          |
         | CON [MID=1239], GET, /status, 2:5/0/64           ------> |
         |                                                          |
         | <------   ACK [MID=1239], 2.05 Content, 2:5/0/64         |
    
              Рисунок 3: Блочный GET с ранним согласованием. Отслеживание стандартов Bormann & Shelby.   
   В третьем примере (рисунок 4) клиент удивлен необходимостью 
   поблочного и недовольны размером, выбранным 
   сервером в одностороннем порядке. Поскольку 
   изначально предложение размера не было отправлено , согласование влияет на размер только после второго 
   обмена сообщениями. Поскольку клиент уже получил и 
   первый, и второй 64-байтовый блок в первом 128-байтовом обмене, он 
   продолжает запрашивать третий 64-байтовый блок («2/0/64»). Ни один из этого
   понимается (или должен быть) понят сервером, который просто отвечает 
   на запросы, насколько это возможно. 


       CLIENT                                                     SERVER
         |                                                          |
         | CON [MID=1234], GET, /status                     ------> |
         |                                                          |
         | <------   ACK [MID=1234], 2.05 Content, 2:0/1/128        |
         |                                                          |
         | CON [MID=1235], GET, /status, 2:2/0/64           ------> |
         |                                                          |
         | <------   ACK [MID=1235], 2.05 Content, 2:2/1/64         |
         |                                                          |
         | CON [MID=1236], GET, /status, 2:3/0/64           ------> |
         |                                                          |
         | <------   ACK [MID=1236], 2.05 Content, 2:3/1/64         |
         |                                                          |
         | CON [MID=1237], GET, /status, 2:4/0/64           ------> |
         |                                                          |
         | <------   ACK [MID=1237], 2.05 Content, 2:4/1/64         |
         |                                                          |
         | CON [MID=1238], GET, /status, 2:5/0/64           ------> |
         |                                                          |
         | <------   ACK [MID=1238], 2.05 Content, 2:5/0/64         |
    
              Рисунок 4: Блочный GET с поздним согласованием 

   Во всех этих (и следующих) случаях повторные передачи обрабатываются 
   уровнем обмена сообщениями CoAP, поэтому они не влияют на 
   операции блока (рисунки 5 и 6).  
       CLIENT                                                     SERVER
         |                                                          |
         | CON [MID=1234], GET, /status                     ------> |
         |                                                          |
         | <------   ACK [MID=1234], 2.05 Content, 2:0/1/128        |
         |                                                          |
         | CON [MID=1235], GE/////////////////////////              |
         |                                                          |
         | (timeout)                                                |
         |                                                          |
         | CON [MID=1235], GET, /status, 2:2/0/64           ------> |
         |                                                          |
         | <------   ACK [MID=1235], 2.05 Content, 2:2/1/64         |
         :                                                          :
         :                          ...                             :
         :                                                          :
         | CON [MID=1238], GET, /status, 2:5/0/64           ------> |
         |                                                          |
         | <------   ACK [MID=1238], 2.05 Content, 2:5/0/64         |
    
        Рисунок 5: Блочный метод GET с поздним согласованием и потерей 
    
       CLIENT                                                     SERVER
         |                                                          |
         | CON [MID=1234], GET, /status                     ------> |
         |                                                          |
         | <------   ACK [MID=1234], 2.05 Content, 2:0/1/128        |
         |                                                          |
         | CON [MID=1235], GET, /status, 2:2/0/64           ------> |
         |                                                          |
         | //////////////////////////////////tent, 2:2/1/64         |
         |                                                          |
         | (timeout)                                                |
         |                                                          |
         | CON [MID=1235], GET, /status, 2:2/0/64           ------> |
         |                                                          |
         | <------   ACK [MID=1235], 2.05 Content, 2:2/1/64         |
         :                                                          :
         :                          ...                             :
         :                                                          :
         | CON [MID=1238], GET, /status, 2:5/0/64           ------> |
         |                                                          |
         | <------   ACK [MID=1238], 2.05 Content, 2:5/0/64         |
    
        Рисунок 6: Блочный метод GET с поздним согласованием и потерянным ACK 




## 3.2. Примеры блока 

   Следующие примеры демонстрируют обмен PUT; обмен POST 
   выглядит одинаково, но с разными требованиями к атомарности / идемпотентности. 
   Обратите внимание, что, как и в случае с GET, ответы на запросы, которые содержат 
   больший бит в параметре запроса Block1, являются предварительными и содержат 
   код ответа 2.31 (Продолжить); только последний ответ сообщает 
   клиенту об успешном выполнении PUT. 


       CLIENT                                                     SERVER
         |                                                          |
         | CON [MID=1234], PUT, /options, 1:0/1/128    ------>      |
         |                                                          |
         | <------   ACK [MID=1234], 2.31 Continue, 1:0/1/128       |
         |                                                          |
         | CON [MID=1235], PUT, /options, 1:1/1/128    ------>      |
         |                                                          |
         | <------   ACK [MID=1235], 2.31 Continue, 1:1/1/128       |
         |                                                          |
         | CON [MID=1236], PUT, /options, 1:2/0/128    ------>      |
         |                                                          |
         | <------   ACK [MID=1236], 2.04 Changed, 1:2/0/128        |
    
                  Рисунок 7: Простой атомарный блочный метод PUT

   Сервер без состояния, который просто создает / обновляет ресурс на месте 
   (без сохранения состояния), может указать на это, не устанавливая бит more в 
   ответе (рисунок 8); в этом случае коды ответов действительны 
   отдельно для каждого обновляемого блока. Это, конечно, 
   приемлемое поведение сервера только в том случае, если потенциальная несогласованность, 
   имеющаяся во время выполнения последовательности обмена сообщениями, не приводит 
   к проблемам, например, потому что создаваемый или изменяемый ресурс 
   еще не используется или не используется в настоящее время.  


       CLIENT                                                     SERVER
         |                                                          |
         | CON [MID=1234], PUT, /options, 1:0/1/128    ------>      |
         |                                                          |
         | <------   ACK [MID=1234], 2.04 Changed, 1:0/0/128        |
         |                                                          |
         | CON [MID=1235], PUT, /options, 1:1/1/128    ------>      |
         |                                                          |
         | <------   ACK [MID=1235], 2.04 Changed, 1:1/0/128        |
         |                                                          |
         | CON [MID=1236], PUT, /options, 1:2/0/128    ------>      |
         |                                                          |
         | <------   ACK [MID=1236], 2.04 Changed, 1:2/0/128        |
    
                 Рисунок 8: Простое блочное PUT без сохранения состояния 

   Наконец, сервер, получающий поблочное PUT или POST, может захотеть 
   указать предпочтительный размер блока меньшего размера (рисунок 9). В этом случае 
   клиент ДОЛЖЕН продолжить с меньшим размером блока; если это так, он 
   ДОЛЖЕН отрегулировать номер блока для правильного подсчета в этом меньшем размере. 

       CLIENT                                                     SERVER
         |                                                          |
         | CON [MID=1234], PUT, /options, 1:0/1/128    ------>      |
         |                                                          |
         | <------   ACK [MID=1234], 2.31 Continue, 1:0/1/32        |
         |                                                          |
         | CON [MID=1235], PUT, /options, 1:4/1/32     ------>      |
         |                                                          |
         | <------   ACK [MID=1235], 2.31 Continue, 1:4/1/32        |
         |                                                          |
         | CON [MID=1236], PUT, /options, 1:5/1/32     ------>      |
         |                                                          |
         | <------   ACK [MID=1235], 2.31 Continue, 1:5/1/32        |
         |                                                          |
         | CON [MID=1237], PUT, /options, 1:6/0/32     ------>      |
         |                                                          |
         | <------   ACK [MID=1236], 2.04 Changed, 1:6/0/32         |
    
          Рисунок 9: Простая атомарная блочная технология PUT с согласованием по стандартам Бормана и Шелби.  
3.3. Объединение Block1 и Block2 Параметры 
   блока могут использоваться в обоих направлениях одного обмена. 
   В следующем примере демонстрируется блочный запрос POST.


   приводит к отдельному блочному ответу. 

   КЛИЕНТСКИЙ СЕРВЕР 
     | | 
     | CON [MID = 1234], POST, / soap, 1: 0/1/128 ------> | 
     | | 
     | <------ ACK [MID = 1234], 2.31 Продолжить, 1: 0/1/128 | 
     | | 
     | CON [MID = 1235], POST, / soap, 1: 1/1/128 ------> | 
     | | 
     | <------ ACK [MID = 1235], 2.31 Продолжить, 1: 1/1/128 |
     | | 
     | CON [MID = 1236], POST, / soap, 1: 2/0/128 ------> | 
     | | 
     | <------ ACK [MID = 1236], изменено 2.04, 2: 0/1/128, 1: 2/0/128 | 
     | | 
     | CON [MID = 1237], POST, / soap, 2: 1/0/128 ------> | 
     | (нет полезной нагрузки для запросов с блоком 2 с NUM! = 0) | 
     | (также можно провести позднее согласование, запросив, | 
     | например, 2: 2/0/64) | 
     | |
     | <------ ACK [MID = 1237], изменено 2.04, 2: 1/1/128 | 
     | | 
     | CON [MID = 1238], POST, / soap, 2: 2/0/128 ------> | 
     | | 
     | <------ ACK [MID = 1238], изменено 2.04, 2: 2/1/128 | 
     | | 
     | CON [MID = 1239], POST, / soap, 2: 3/0/128 ------> | 
     | | 
     | <------ ACK [MID = 1239], изменено 2.04, 2: 3/0/128 | 
     
        CLIENT                                                     SERVER
         |                                                              |
         | CON [MID=1234], POST, /soap, 1:0/1/128      ------>          |
         |                                                              |
         | <------   ACK [MID=1234], 2.31 Continue, 1:0/1/128           |
         |                                                              |
         | CON [MID=1235], POST, /soap, 1:1/1/128      ------>          |
         |                                                              |
         | <------   ACK [MID=1235], 2.31 Continue, 1:1/1/128           |
         |                                                              |
         | CON [MID=1236], POST, /soap, 1:2/0/128      ------>          |
         |                                                              |
         | <------   ACK [MID=1236], 2.04 Changed, 2:0/1/128, 1:2/0/128 |
         |                                                              |
         | CON [MID=1237], POST, /soap, 2:1/0/128      ------>          |
         | нет полезной нагрузки для запросов с блоком 2 с NUM! = 0)    |
         | ((также можно провести позднее согласование, запросив,       |
         |  например, 2: 2/0/64)                                        |
         |                                                              |
         | <------   ACK [MID=1237], 2.04 Changed, 2:1/1/128            |
         |                                                              |
         | CON [MID=1238], POST, /soap, 2:2/0/128      ------>          |
         |                                                              |
         | <------   ACK [MID=1238], 2.04 Changed, 2:2/1/128            |
         |                                                              |
         | CON [MID=1239], POST, /soap, 2:3/0/128      ------>          |
         |                                                              |
         | <------   ACK [MID=1239], 2.04 Changed, 2:3/0/128            |
    
        Рисунок 10: Atomic Block-Wise POST с блочным ответом

 





   Эта модель действительно обеспечивает предварительный ввод согласования для 
   блочной передачи Block2 , как показано ниже. 

       CLIENT                                                     SERVER
         |                                                              |
         | CON [MID=1234], POST, /soap, 1:0/1/128 ------>               |
         |                                                              |
         | <------   ACK [MID=1234], 2.31 Continue, 1:0/1/128           |
         |                                                              |
         | CON [MID=1235], POST, /soap, 1:1/1/128 ------>               |
         |                                                              |
         | <------   ACK [MID=1235], 2.31 Continue, 1:1/1/128           |
         |                                                              |
         | CON [MID=1236], POST, /soap, 1:2/0/128, 2:0/0/64 ------>     |
         |                                                              |
         | <------   ACK [MID=1236], 2.04 Changed, 1:2/0/128, 2:0/1/64  |
         |                                                              |
         | CON [MID=1237], POST, /soap, 2:1/0/64      ------>           |
         | (no payload for requests with Block2 with NUM != 0)          |
         |                                                              |
         | <------   ACK [MID=1237], 2.04 Changed, 2:1/1/64             |
         |                                                              |
         | CON [MID=1238], POST, /soap, 2:2/0/64      ------>           |
         |                                                              |
         | <------   ACK [MID=1238], 2.04 Changed, 2:2/1/64             |
         |                                                              |
         | CON [MID=1239], POST, /soap, 2:3/0/64      ------>           |
         |                                                              |
         | <------   ACK [MID=1239], 2.04 Changed, 2:3/0/64             |
    
        Рисунок 11: Атомарный блочный метод POST с блочным ответом, 
                             раннее согласование 

3.4. Комбинирование Observe и Block2 

   В следующем примере сервер сначала отправляет прямой ответ 
   (порядковый номер Observe 62350) на начальный запрос GET ( 
   результирующая поблочная передача такая, как на рисунке 4, и поэтому 
   не учитывается). Вторая передача начинается с 
   уведомления 2.05, которое содержит только первый блок ( 
   обратите внимание на порядковый номер 62354); затем клиент переходит к получению остальных 
   блоков. [Стр. 26]

       CLIENT  SERVER
         |      |
         +----->|     Header: GET 0x41011636
         | GET  |      Token: 0xfb
         |      |   Uri-Path: status-icon
         |      |    Observe: (empty)
         |      |
         |<-----+     Header: 2.05 0x61451636
         | 2.05 |      Token: 0xfb
         |      |     Block2: 0/1/128
         |      |    Observe: 62350
         |      |       ETag: 6f00f38e
         |      |    Payload: [128 bytes]
         |      |
         |      |  (Usual GET transfer left out)
           ...
         |      |  (Notification of first block)
         |      |
         |<-----+     Header: 2.05 0x4145af9c
         | 2.05 |      Token: 0xfb
         |      |     Block2: 0/1/128
         |      |    Observe: 62354
         |      |       ETag: 6f00f392
         |      |    Payload: [128 bytes]
         |      |
         +- - ->|     Header: 0x6000af9c
         |      |
         |      |  (Retrieval of remaining blocks)
         |      |
         +----->|     Header: GET 0x41011637
         | GET  |      Token: 0xfc
         |      |   Uri-Path: status-icon
         |      |     Block2: 1/0/128
         |      |
         |<-----+     Header: 2.05 0x61451637
         | 2.05 |      Token: 0xfc
         |      |     Block2: 1/1/128
         |      |       ETag: 6f00f392
         |      |    Payload: [128 bytes]
         |      |
         +----->|     Header: GET 0x41011638
         | GET  |      Token: 0xfc
         |      |   Uri-Path: status-icon
         |      |     Block2: 2/0/128
         |      |
         |<-----+     Header: 2.05 0x61451638
         | 2.05 |      Token: 0xfc
         |      |     Block2: 2/0/128
         |      |       ETag: 6f00f392
         |      |    Payload: [53 bytes]
    
           Рисунок 12: Наблюдение за последовательностью с 

   блочным ответом (обратите внимание, что выбор токена 0xfc в этом примере произвольный; 
   токены показаны в этом примере только 
   для того, чтобы проиллюстрировать, что запросы дополнительных блоков не могут использовать токен 
   отношения наблюдения . В качестве общего комментария 
   к токенам в этом документе нет другого упоминания токенов, поскольку блочные передачи обрабатывают 
   токены, как и любой другой обмен CoAP. Как обычно, клиент волен 
   выбирать токены для каждого обмена как нравится.)

   В следующем примере клиент также использует раннее согласование, чтобы 
   ограничить размер блока 64 байтами. 

       CLIENT  SERVER
         |      |
         +----->|     Header: GET 0x41011636
         | GET  |      Token: 0xfb
         |      |   Uri-Path: status-icon
         |      |    Observe: (empty)
         |      |     Block2: 0/0/64
         |      |
         |<-----+     Header: 2.05 0x61451636
         | 2.05 |      Token: 0xfb
         |      |     Block2: 0/1/64
         |      |    Observe: 62350
         |      |       ETag: 6f00f38e
         |      |    Max-Age: 60
         |      |    Payload: [64 bytes]
         |      |
         |      |  (Usual GET transfer left out)
           ...
         |      |  (Notification of first block)
         |      |
         |<-----+     Header: 2.05 0x4145af9c
         | 2.05 |      Token: 0xfb
         |      |     Block2: 0/1/64
         |      |    Observe: 62354
         |      |       ETag: 6f00f392
         |      |    Payload: [64 bytes]
         |      |
         +- - ->|     Header: 0x6000af9c
         |      |
         |      |  (Retrieval of remaining blocks)
         |      |
         +----->|     Header: GET 0x41011637
         | GET  |      Token: 0xfc
         |      |   Uri-Path: status-icon
         |      |     Block2: 1/0/64
         |      |
         |<-----+     Header: 2.05 0x61451637
         | 2.05 |      Token: 0xfc
         |      |     Block2: 1/1/64
         |      |       ETag: 6f00f392
         |      |    Payload: [64 bytes]
           ....
         |      |
         +----->|     Header: GET 0x41011638
         | GET  |      Token: 0xfc
         |      |   Uri-Path: status-icon
         |      |     Block2: 4/0/64
         |      |
         |<-----+     Header: 2.05 0x61451638
         | 2.05 |      Token: 0xfc
         |      |     Block2: 4/0/64
         |      |       ETag: 6f00f392
         |      |    Payload: [53 bytes]
    
            Рисунок 13: Наблюдение за последовательностью с ранним согласованием 

# 4. Опции Size2 и Size1 

   Во многих случаях при передаче большого представления ресурса блок 
   за блоком полезно знать общий размер на ранней стадии 
   процесса. Некоторое указание может быть доступно из 
   атрибута оценки максимального размера «sz», предоставленного в описании ресурса [RFC6690].
   Однако размер может изменяться динамически, поэтому 
   может оказаться полезным более актуальное указание. 

   Эта спецификация определяет две опции CoAP: Size1 для указания 
   размера представления, передаваемого в запросах, и Size2 для 
   указания размера представления, передаваемого в ответах. 
   (Размер 1 уже определен в разделе 5.10.9 [RFC7252] для 
   предоставления «информации о размере представления ресурса в 
   запросе»; однако в этом разделе подробно описывается только узкий случай 
   указания в ответах 4.13 максимального размера полезной нагрузки запроса, которая 
   сервер может и желает обрабатывать. Настоящая спецификация
   предоставляет подробные сведения о его использовании в качестве варианта запроса.)   
   Параметр Size2 может использоваться для двух целей: 
* В запросе, чтобы запросить сервер, чтобы предоставить оценку размера вместе 
      с обычным ответом («запрос размера»). Для этого использования 
      значение ДОЛЖНО быть установлено на 0. 
* В ответе, несущем опцию Block2, для указания текущей 
      оценки сервером общего размера представления ресурса 
      , измеренного в байтах («указание размера»). 
   Точно так же параметр Size1 может использоваться для двух целей:

* В запросе, содержащем параметр Block1, чтобы указать текущую 
      оценку клиентом общего размера представления ресурса 
      , измеренного в байтах («указание размера»). 

* В ответе 4.13, чтобы указать максимальный размер, который был бы 
      приемлем [RFC7252], измеренный в байтах. 


   Помимо передачи / запроса информации о размере, параметры размера 
   не имеют другого влияния на обработку запроса или ответа. 
   Если клиент хочет минимизировать размер полезной нагрузки в 
   результирующем ответе, он должен добавить к запросу параметр Block2 с 
   небольшим размером блока (например, установив SZX = 0). 

   Параметры размера являются «выборочными», т.е. клиент ДОЛЖЕН быть готов к
   сервер игнорирует запрос оценки размера. Любая опция размера 
   НЕ ДОЛЖНА встречаться более одного раза в одном сообщении. 

        +-----+---+---+---+---+-------+--------+--------+---------+
        | No. | C | U | N | R | Name  | Format | Length | Default |
        +-----+---+---+---+---+-------+--------+--------+---------+
        |  60 |   |   | x |   | Size1 | uint   |    0-4 | (none)  |
        |     |   |   |   |   |       |        |        |         |
        |  28 |   |   | x |   | Size2 | uint   |    0-4 | (none)  |
        +-----+---+---+---+---+-------+--------+--------+---------+ 
      
                       Таблица 2: Номера вариантов размера 

   Примечания по реализации:

* В качестве соображений качества реализации 
      ожидается, что поблочные передачи, 
      для которых общий размер значительно превышает размер одного блока, будут включать указания размера, если они могут 
      быть предоставлены без излишних усилий (предпочтительно с 
      обменом первым блоком ). Если оценка размера не меняется, индикацию 
      нет необходимости повторять для каждого блока.  
* Окончание поблочной передачи определяется битами M в параметрах 
      блока, _не_ исчерпанием обмениваемых оценок размера.

* Как обычно для опции типа uint, значение 0 лучше всего выражать 
      как пустую опцию (0 байтов). Для 
      любого параметра размера нет значения по умолчанию . 

* Параметры размера не являются ни критическими, ни небезопасными и помечены 
      как No-Cache-Key. 


# 5. Соображения по HTTP-отображению. 

   В этом подразделе мы приводим несколько кратких примеров влияния, которое 
   параметры блокировки могут иметь на посредников, отображающих между CoAP 
   и HTTP. 

   Для отображения запросов CoAP в HTTP посредник может захотеть отобразить 
   последовательность поблочных передач в одну передачу HTTP. 
   Например, для запроса GET посредник может выполнить
   HTTP-запрос после того, как был запрошен первый блок, и затем мог 
   выполнять все последующие запросы блоков из своего кеша. Ограниченная 
   реализация может не иметь возможности кэшировать весь объект и может использовать 
   комбинацию управления потоком TCP и (в частности, если 
   возникают таймауты ) запросы диапазона HTTP для получения информации, необходимой для 
   следующей передачи блока в нужное время. 

   Для запросов PUT или POST исторически существовало больше вариантов 
   реализации диапазонов HTTP-серверами; недавно [RFC7233] 
   определил, что поля заголовка диапазона, полученные с помощью метода запроса, отличного 
   от GET, не должны интерпретироваться. Итак, в общем, CoAP-to-HTTP
   посредник должен будет попытаться отправить полезную нагрузку всех блоков 
   поблочной передачи для этих других методов в одном HTTP- 
   запросе. Если доступно достаточное количество буферизации, этот запрос может быть 
   запущен, когда будет получен последний блок CoAP. Ограниченная 
   реализация может захотеть облегчить свою буферизацию, уже начав 
   отправлять HTTP-запрос в момент получения первого блока CoAP 
   ; любой код состояния HTTP 408, указывающий на то, что 
   сервер HTTP стал нетерпеливым с полученной передачей, затем может быть 
   отображен в код ответа CoAP 4.08 (аналогично, 413 отображается на 4.13). 

   Для сопоставления HTTP с CoAP посредник может захотеть сопоставить один
   Передача HTTP в последовательности поблочных передач. Если HTTP- 
   клиент слишком медленно доставляет тело запроса в PUT или POST, 
   сервер CoAP может истечь тайм-аут и вернуть код ответа 4.08, который, в 
   свою очередь, хорошо соответствует коду состояния HTTP 408 (опять же, 4.13 соответствует 413). 
   Запросы диапазона HTTP, полученные на стороне HTTP, могут обслуживаться из 
   кеша и / или отображаться на запросы GET, которые запрашивают последовательность блоков 
   , охватывающих диапазон. 
   (Обратите внимание, что, хотя семантика CoAP 4.08 и HTTP 408 различается,

   это различие в значительной степени связано с различным способом 
   отображения двух протоколов для транспорта. HTTP имеет базовое TCP-соединение, 
   которое предоставляет состояние соединения, поэтому код состояния HTTP 408 можно 
   сразу использовать, чтобы указать, что тайм-аут произошел во время 
   передачи запроса через это активное TCP-соединение. Код 
   ответа CoAP 4.08 указывает один или несколько отсутствующих блоков, которые могут быть 
   вызваны тайм-аутом или ограничениями ресурсов; поскольку нет 
   состояния подключения , нет возможности доставить такой ответ немедленно; 
   вместо этого он доставляется при следующей блочной передаче. Тем не менее, HTTP 408 
   , вероятно, является лучшим сопоставлением с HTTP, так как тайм-аут является самым большим.
   вероятная причина CoAP 4.08. Обратите внимание, что нет способа 
   отличить тайм-аут от отсутствующего блока для сервера без 
   создания дополнительного состояния, необходимость которого мы хотим избежать.) 

# 6. Соображения IANA В 

   этом документе к « 
   Номерам вариантов CoAP» добавляются следующие номера опций. реестр, определенный в [RFC7252]: 

                      +--------+--------+-----------+
                      | Number | Name   | Reference |
                      +--------+--------+-----------+
                      | 23     | Block2 | RFC 7959  |
                      |        |        |           |
                      | 27     | Block1 | RFC 7959  |
                      |        |        |           |
                      | 28     | Size2  | RFC 7959  |
                      +--------+--------+-----------+
       
                       Таблица 3: Номера опций CoAP 

   Этот документ добавляет следующие коды ответов к « 
   Коды ответов CoAP. "реестр, определенный в [RFC7252]: 

             +------+---------------------------+-----------+
             | Code | Description               | Reference |
             +------+---------------------------+-----------+
             | 2.31 | Continue                  | RFC 7959  |
             |      |                           |           |
             | 4.08 | Request Entity Incomplete | RFC 7959  |
             +------+---------------------------+-----------+
       
                       Таблица 4 : Коды ответа CoAP  

# 7. Соображения безопасности 
   Предоставление доступа к блокам внутри ресурса может привести к неожиданным 
   уязвимостям. Если запросы не реализуются атомарно, 
   злоумышленник может воспользоваться состоянием гонки или запутать сервер 
   , заставив его использовать частично обновленное представление ресурса. 
   Частичная передача может также сделать некоторые проблемные данные невидимыми для 
   систем обнаружения вторжений (IDS); РЕКОМЕНДУЕТСЯ, чтобы IDS

   который анализирует представления ресурсов, переданные CoAP, реализуют 
   параметры блокировки для получения доступа ко всем представлениям ресурсов. 
   Тем не менее, такие подходы, как передача блоков с четными номерами по одному 
   пути и блоков с нечетными номерами по другому пути или даже 
   многократная передача блоков с разным содержимым и получение 
   другой интерпретации временного порядка на IDS, чем на 
   сервере, могут предотвратить IDS от просмотра всей картины. Эти 
   виды атак хорошо известны из фрагментации IP и 
   сегментации TCP ; CoAP не добавляет принципиально новых соображений. 

   Если доступ к ресурсу предоставляется только клиентам, использующим
   определенные ассоциации безопасности, все блоки этого ресурса ДОЛЖНЫ 
   подвергаться одинаковым проверкам безопасности; НЕ ДОЛЖНО быть возможным для 
   незащищенных обменов влиять на блоки иным образом защищенного 
   ресурса. В качестве сопутствующего соображения, когда используется безопасность объекта 
   , PUT / POST должен быть реализован атомарно, 
   если только операция защиты объекта не выполняется при каждом доступе и 
   создание непригодных для использования ресурсов не допускается. Будущие 
   механизмы сквозной безопасности, которые могут быть добавлены в сам CoAP, могут иметь 
   связанные соображения безопасности, включая соображения о 
   кэшировании блоков в клиентах и ​​прокси-серверах (см. Разделы 2.10 и 5.
   для разных стратегий выполнения этого кеширования); эти соображения безопасности 
   необходимо будет описать в спецификациях 
   этих механизмов. 

   Сервер без состояния может быть восприимчив к атаке, когда 
   злоумышленник отправляет блок Block1 (например, PUT) с большим номером блока: 
   наивная реализация может исчерпать его ресурсы, создав огромное 
   представление ресурса. 

   Вводящие в заблуждение индикаторы размера могут использоваться злоумышленником, чтобы вызвать 
   переполнение буфера в плохих реализациях, к которым 
   применимы обычные соображения. 

## 7.1. Смягчение атак на исчерпание ресурсов 

   Некоторые блочные запросы могут побудить сервер создать состояние,
   например, для создания моментального снимка для блочного GET быстро меняющегося 
   ресурса, чтобы обеспечить согласованный доступ к одной и той же версии 
   ресурса для всех блоков, или для создания временного ресурса, которые собираются до тех пор, пока не будут введены в эксплуатацию с помощью 
   окончательной PUT или POST с неустановленным битом more. Все механизмы, которые 
   побуждают сервер создавать состояние, которое нельзя просто очистить, 
   создают возможности для атак типа «отказ в обслуживании». Серверам СЛЕДУЕТ 
   избегать исчерпания ресурсов из-за состояния, созданного




   ненадежные источники. Но даже если это будет сделано, смягчение может 
   вызвать отказ в обслуживании законного запроса, когда он заглушается 
   другими запросами, создающими состояние. По возможности, серверы 
   должны минимизировать возможности создания состояния для 
   ненадежных источников, например, используя подходы без сохранения состояния. 

   Выполнение сегментации на прикладном уровне почти всегда 
   лучше в этом отношении, чем на транспортном уровне или ниже (IP- 
   фрагментация, фрагментация на уровне адаптации), например, потому что 
   существует семантика прикладного уровня, которая может использоваться для смягчения последствий, 
   или потому что более низкие уровни обеспечить ассоциации безопасности, которые могут
   предотвращать атаки. Однако 
   на прикладном уровне реже применяются тайм-ауты и механизмы поддержки активности, чем на более низких уровнях. 
   Серверы МОГУТ пожелать очистить накопленное состояние, выбрав его по таймауту (см. 
   Код ответа 4.08), и клиенты ДОЛЖНЫ быть готовы к выполнению поблочных 
   передач целесообразным способом, чтобы минимизировать вероятность возникновения 
   такого тайм-аута. 

## 7.2. Смягчение атак с усилением 

   [RFC7252] обсуждает уязвимость конечных точек CoAP для использования в 
   атаках с усилением. 

   Сервер CoAP может уменьшить степень усиления, которую он предоставляет 
   злоумышленнику, предлагая большие представления ресурсов только в
   относительно небольшие блоки. При этом, например, для 1000-байтового ресурса, 
   10-байтовый запрос может привести к 80-байтовому ответу (с 64-байтовым 
   блоком) вместо 1016-байтового ответа, что значительно снижает 
   обеспечиваемое усиление. 

# 8. Ссылки 

## 8.1. Нормативные ссылки 

   [RFC2119] Bradner, S., «Ключевые слова для использования в RFC для обозначения 
              уровней требований», BCP 14, RFC 2119, 
              DOI 10.17487 / RFC2119, март 1997, 
              <http://www.rfc-editor.org/ info / rfc2119>. 

   [RFC7252] Шелби, З., Хартке, К., и К. Борман, «Протокол ограниченного 
              приложения (CoAP)», RFC 7252, 
              DOI 10.17487 / RFC7252, июнь 2014 г.,
              <http://www.rfc-editor.org/info/rfc7252>. 
   [RFC7641] Хартке, К., «Наблюдение за ресурсами в 
              протоколе с ограничениями приложений (CoAP)», RFC 7641, 
              DOI 10.17487 / RFC7641, сентябрь 2015 г. , 
              <http://www.rfc-editor.org/info/rfc7641>. 
## 8.2. Информативные ссылки 
   [REST] Филдинг, Р., «Архитектурные стили и проектирование 
              сетевых архитектур программного обеспечения», доктор философии. Диссертация, 
              Калифорнийский университет, Ирвин, 2000 г.,  <http://www.ics.uci.edu/~fielding/pubs/disssment/fielding_disssment.pdf>. 

   [RFC4919] Кушалнагар, Н., Черногория, Г., и К. Шумахер, «IPv6 
              по беспроводным персональным сетям с низким энергопотреблением (6LoWPAN): 
              обзор, предположения, постановка проблемы и цели», 
              RFC 4919, DOI 10.17487 / RFC4919 , Август 2007 г., 
              <http://www.rfc-editor.org/info/rfc4919>. 

   [RFC4944] Черногория, Г., Кушалнагар, Н., Хуэй, Дж. И Д. Каллер, 
              «Передача пакетов IPv6 по сетям IEEE 802.15.4 
              », RFC 4944, DOI 10.17487 / RFC4944, сентябрь 2007 г., 
              <http: //www.rfc-editor.org/info/rfc4944>.

   [RFC6690] Шелби, З., « 
              Формат ссылок на ограниченные среды RESTful (CoRE) », RFC 6690, DOI 10.17487 / RFC6690, август 2012 г., 
              <http://www.rfc-editor.org/info/rfc6690>. 

   [RFC7228] Борман, К., Эрсу, М., и А. Керанен, «Терминология для 
              сетей с ограниченными узлами», RFC 7228, 
              DOI 10.17487 / RFC7228, май 2014 г., 
              <http://www.rfc-editor.org / info / rfc7228>. 

   [RFC7230] Филдинг Р., Эд. и J. Reschke, Ed., «Протокол передачи 
              гипертекста (HTTP / 1.1): синтаксис сообщений и маршрутизация», 
              RFC 7230, DOI 10.17487 / RFC7230, июнь 2014 г., 
              <http://www.rfc-editor.org/info/ rfc7230>.

   [RFC7233] Филдинг, Р., ред., Лафон, Ю., ред., И Дж. Решке, ред., 
              «Протокол передачи гипертекста (HTTP / 1.1): запросы диапазона», 
              RFC 7233, DOI 10.17487 / RFC7233, июнь 2014 г., 
              <http://www.rfc-editor.org/info/rfc7233>.   Благодарности 
   Большая часть содержания этого документа является результатом обсуждений 
   с авторами [RFC7252] и многих обсуждений в Рабочей группе CoRE. 
   Чарльз Палмер предоставил обширные редакционные комментарии к предыдущей 
   версии этого документа, некоторые из которых были рассмотрены в

   этот документ. Эско Дейк рассмотрел более свежую версию, которая привела к 
   ряду дальнейших редакционных улучшений, решению 
   проблемы неоднозначности 4.13 и разделу о комбинировании блочной и 
   многоадресной рассылки (раздел 2.8). Маркус Беккер предложил избавиться от 
   непродуманного значения по умолчанию для параметров Block2 и Block1. Питер 
   Бигот настаивал на более систематическом описании вариантов и 
   кода ответа. Цинь Ву предоставил обзор операционному 
   управлению IETF , а Гоэран Селандер прокомментировал соображения безопасности 
   . 

   Кепенг Ли, Линьи Тянь и Барри Лейба написали раннюю версию 
   опции «Размер», которая описана в этом документе. Клаус Хартке
   написал часть текста, описывающую взаимодействие Block2 с 
   Observe. Матиас Ковач представил ряд существенных 
   упрощений протокола. 

   Рецензенты IESG предоставили очень полезные комментарии. Спенсер Докинз 
   даже предложил новый текст. Он и Мирья Кюлевинд настаивали на более 
   подробной информации о многоуровневой передаче данных 
   поверх базового протокола. Бен Кэмпбелл помог распутать 
   суп « ДОЛЖЕН / ДОЛЖЕН». Комментарии Алексея Мельникова, а также 
   обзор Gen-ART Йоуни Корхонена привели к дальнейшим улучшениям 
   текста. [Стр. 36]
