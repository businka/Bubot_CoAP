Инженерная группа Интернета (IETF) З. Шелби
Запрос комментариев: 7252 ARM
Категория: Стандарты трассы К. Хартке
ISSN: 2070-1721 К. Борман
Университет Бремена TZI
Июнь 2014 г.

https://tools.ietf.org/html/rfc7252 Google translate 2021

# Протокол ограниченного приложения (CoAP)

Абстрактный

 Протокол ограниченного приложения (CoAP) - это специализированный веб-сайт.
 протокол передачи для использования с узлами с ограничениями и с ограничениями
 (например, маломощные сети с потерями). Узлы часто имеют 8-битные
 микроконтроллеры с небольшими объемами ПЗУ и ОЗУ, в то время как ограниченные
 сети, такие как IPv6 по беспроводным персональным сетям с низким энергопотреблением
 (6LoWPAN) часто имеют высокий уровень ошибок пакетов и типичный
 пропускная способность 10 кбит / с. Протокол разработан для машинного
 к машинам (M2M) приложениям, таким как интеллектуальная энергетика и строительство
 автоматизация.

 CoAP предоставляет модель взаимодействия запрос / ответ между
 конечные точки приложений, поддерживает встроенное обнаружение сервисов и
 ресурсы и включает ключевые концепции Интернета, такие как URI и
 Типы интернет-СМИ. CoAP разработан для простого взаимодействия с HTTP.
 для интеграции с Интернетом при соблюдении специальных требований
 такие как поддержка многоадресной рассылки, очень низкие накладные расходы и простота для
 стесненные среды.

Статус этой памятки

 Это документ Internet Standards Track.

 Этот документ является продуктом Инженерной группы Интернета.
 (IETF). Он представляет собой консенсус сообщества IETF. Оно имеет
 получил публичное рецензирование и одобрен к публикации
 Инженерная группа управления Интернетом (IESG). Дополнительная информация о
 Интернет-стандарты доступны в разделе 2 RFC 5741.

 Информация о текущем статусе этого документа, исправлениях,
 а о том, как оставить отзыв, можно узнать по адресу
 http://www.rfc-editor.org/info/rfc7252.


Уведомление об авторских правах

Авторские права (c) IETF Trust 2014 г. и лица, указанные как
авторы документа. Все права защищены.

Этот документ подпадает под действие BCP 78 и Правового регулирования IETF Trust.
Положения, касающиеся документов IETF
(http://trustee.ietf.org/license-info) действует на дату
публикация этого документа. Пожалуйста, просмотрите эти документы
внимательно, поскольку они уважительно описывают ваши права и ограничения
к этому документу. Компоненты кода, извлеченные из этого документа, должны
включить упрощенный текст лицензии BSD, как описано в Разделе 4.e
Правовые положения Trust и предоставляются без гарантии, как
описано в упрощенной лицензии BSD.

# 1. Введение

Использование веб-сервисов (веб-API) в Интернете стало
повсеместно используется в большинстве приложений и зависит от фундаментальных
Репрезентативная архитектура передачи состояния [REST] сети.

Работа над ограниченными средами RESTful (CoRE) направлена на реализацию
архитектура REST в подходящей форме для самых ограниченных
узлы (например, 8-битные микроконтроллеры с ограниченным ОЗУ и ПЗУ) и
сети (например, 6LoWPAN, [RFC4944]). Ограниченные сети, такие как
6LoWPAN поддерживает фрагментацию пакетов IPv6 в небольшие каналы -
слойные рамки; однако это приводит к значительному сокращению пакета
вероятность доставки. Одна из целей дизайна CoAP состояла в том, чтобы сохранить
накладные расходы на сообщение небольшие, что ограничивает необходимость фрагментации.

Одна из основных целей CoAP - разработать общий веб-протокол для
особые требования этой стесненной среды, особенно
с учетом энергетики, автоматизации зданий и прочего межмашинного взаимодействия
(M2M) приложения. Цель CoAP не в том, чтобы слепо сжимать HTTP.
[RFC2616], а скорее для реализации подмножества REST, общего с HTTP.
но оптимизирован для приложений M2M. Хотя CoAP можно использовать для
преобразование простых HTTP-интерфейсов в более компактный протокол,
что еще более важно, он также предлагает функции для M2M, такие как встроенные
обнаружение, поддержка многоадресной рассылки и асинхронный обмен сообщениями.

Этот документ определяет протокол ограниченного приложения (CoAP),
который легко переводится в HTTP для интеграции с существующей сетью
при соблюдении специальных требований, таких как поддержка многоадресной рассылки,
очень низкие накладные расходы и простота для ограниченных сред и
Приложения M2M.

## 1.1. Функции

 CoAP имеет следующие основные особенности:
* Веб-протокол, удовлетворяющий требованиям M2M в ограниченных окружающая среда
* Привязка UDP [RFC0768] с дополнительной надежностью, поддерживающая одноадресную рассылку и многоадресные запросы.
* Асинхронный обмен сообщениями.
* Низкие накладные расходы на заголовок и сложность синтаксического анализа.
* Поддержка URI и Content-type.
* Простые возможности прокси и кеширования.
* Отображение HTTP без сохранения состояния, позволяющее создавать прокси, обеспечивая  доступ к ресурсам CoAP по HTTP единообразно или по HTTP  простые интерфейсы, которые могут быть реализованы альтернативно через CoAP.
* Привязка безопасности к Datagram Transport Layer Security (DTLS)  [RFC6347].

## 1.2. Терминология

Ключевые слова «ДОЛЖНЫ», «НЕ ДОЛЖНЫ», «ОБЯЗАТЕЛЬНО», «ДОЛЖНЫ», 
«НЕ ДОЛЖНЫ»,  «ДОЛЖЕН», «НЕ ДОЛЖЕН», «РЕКОМЕНДУЕТСЯ», 
«НЕ РЕКОМЕНДУЕТСЯ», «МОЖЕТ» и «ДОПОЛНИТЕЛЬНО» в этом документе следует 
толковать, как описано в [RFC2119], когда они появляются ВСЕМИ ЗАГЛАВНЫМИ БУКВАМИ. Эти слова также могут появляться  в этом документе строчными буквами, без их нормативных значений.

 Эта спецификация требует, чтобы читатели были знакомы со всеми терминами  и концепции, которые обсуждаются в [RFC2616], включая «ресурс»,  «представление», «кэш» и «свежий». (После завершения  до того, как обновленный набор HTTP RFC, от RFC 7230 до RFC 7235, стал  доступны, эта спецификация конкретно ссылается на предшественника
 версия - RFC 2616.) Кроме того, эта спецификация определяет  следующая терминология:

Конечная точка
Сущность, участвующая в протоколе CoAP. В разговорной речи   конечная точка живет на «Узле», хотя «Хост» будет более   в соответствии с использованием стандартов Интернета, и, кроме того,   идентифицируется с помощью информации мультиплексирования транспортного уровня, которая может   включить номер порта UDP и ассоциацию безопасности  (Раздел 4.1).

**Отправитель** -  Исходная конечная точка сообщения. Когда аспект   идентификация конкретного отправителя находится в центре внимания, также "источник   конечная точка ".

**Получатель** -   Конечная точка назначения сообщения. Когда аспект   идентификация конкретного получателя находится в центре внимания, также   "конечная точка назначения".

**Клиент** -  Исходная конечная точка запроса; конечная точка назначения ответ.

**Сервер** - Конечная точка назначения запроса; исходная конечная точка ответ.

**Исходный сервер** -   Сервер, на котором данный ресурс находится или должен быть создан.

**Посредник** -   Конечная точка CoAP, которая действует как сервер и как клиент по отношению к   исходный сервер (возможно, через других посредников). Общий   форма посредника - доверенность; несколько классов таких   прокси обсуждаются в этой спецификации.

**Прокси** -   Посредник, который в основном занимается пересылкой запросов   и ретранслируя ответы, возможно, выполняя кеширование,   трансляция пространства имен или трансляция протокола в процессе. В виде   в отличие от посредников в общем смысле, прокси обычно   не реализуют конкретную семантику приложения. На основе   место в общей структуре переадресации запроса, есть   представляют собой две распространенные формы прокси: прямой прокси и обратный прокси. 
В некоторых случаях одна конечная точка может выступать в качестве исходного сервера,   прокси-сервер или обратный прокси-сервер, поведение переключения на основе   характер каждого запроса.

**Форвард-прокси** -   Конечная точка, выбранная клиентом, обычно через локальную конфигурацию   правила, выполнять запросы от имени клиента, делая любые   необходимые переводы. Некоторые переводы минимальны, например    для прокси-запросов для "копируемых" URI, тогда как другие запросы могут   требуется перевод в и из совершенно другого приложения -   протоколы уровня.

**Обратный прокси ** -   Конечная точка, которая заменяет один или несколько других серверов и   удовлетворяет запросы от их имени, делая все необходимое   переводы. В отличие от прокси-сервера, клиент может не знать   что он обменивается данными с обратным прокси-сервером; обратный прокси   получает запросы, как если бы это был исходный сервер для цели   ресурс.

**Прокси CoAP-to-CoAP** -   Прокси-сервер, который отображает запрос CoAP на запрос CoAP, т. Е.   использует протокол CoAP как на сервере, так и на стороне клиента.   В отличие от кросс-прокси.

**Кросс-прокси** -   Межпротокольный прокси, или для краткости «кросс-прокси», - это прокси.   который преобразуется между различными протоколами, такими как CoAP-to-  Прокси-сервер HTTP или прокси-сервер HTTP-to-CoAP. Хотя эта спецификация   предъявляет очень специфические требования к прокси CoAP-to-CoAP, есть еще   возможны вариации в кросс-прокси.

**Подтверждаемое сообщение** -   Некоторые сообщения требуют подтверждения. Эти сообщения   называется "Подтверждаемый". Если пакеты не потеряны, каждый Подтверждаемый   message вызывает ровно одно ответное сообщение типа Acknowledgment  или введите Reset.

**Сообщение, не подлежащее подтверждению** -   Некоторые другие сообщения не требуют подтверждения. Это   особенно актуально для сообщений, которые регулярно повторяются для   требования приложения, такие как повторяющиеся показания датчика.

**Сообщение с подтверждением** -   Сообщение подтверждения подтверждает, что конкретный   Подтверждаемое сообщение пришло. Само по себе признание   сообщение не указывает на успех или неудачу какого-либо запроса   инкапсулировано в подтверждаемое сообщение, но подтверждение   сообщение также может содержать совмещенный ответ (см. ниже).

**Сбросить сообщение** -   Сообщение сброса указывает, что конкретное сообщение (Подтверждаемое или   Неподтвержденный) был получен, но отсутствует некоторый контекст для   правильно его обработать. Это состояние обычно возникает, когда   принимающий узел перезагрузился и забыл какое-то состояние, которое   потребуется интерпретировать сообщение. Провоцирование сброса   сообщение (например, отправив пустое подтверждаемое сообщение) также   полезен как недорогая проверка работоспособности конечной точки   («Пинг CoAP»).

**Совмещенный ответ** -  Совмещенный ответ включается прямо в подтверждение CoAP.   (ACK) сообщение, которое отправляется для подтверждения получения запроса.   для этого ответа (раздел 5.2.1).

**Отдельный ответ** -   Когда Подтверждаемое сообщение, несущее запрос, подтверждается с помощью   пустое сообщение (например, потому что у сервера нет ответа   сразу), отдельный ответ отправляется отдельным сообщением   exchange (раздел 5.2.2).

** Пустое сообщение** -   Сообщение с кодом 0.00; ни запрос, ни ответ.   Пустое сообщение содержит только 4-байтовый заголовок.

**Критический вариант** -   Вариант, который должен быть понят конечной точкой   в конечном итоге получение сообщения для правильной обработки   сообщение (раздел 5.4.1). Обратите внимание, что реализация критического   options является, как следует из названия "Option", как правило, необязательным:   неподдерживаемые критические параметры приводят к ответу об ошибке или сводке   отклонение сообщения.

**Выборный вариант** -   Параметр, который предназначен для игнорирования конечной точкой,   не понимаю. Обработка сообщения даже без   понимание варианта приемлемо (раздел 5.4.1).

**Небезопасный вариант** -   Вариант, который должен быть понят прокси, получающим   сообщение для безопасной пересылки сообщения   (Раздел 5.4.2). Не каждый критический вариант является небезопасным.

**Вариант безопасной пересылки** -   Вариант, который предназначен для безопасной пересылки через прокси   тот этого не понимает. Пересылка сообщения даже без   понимание варианта приемлемо (раздел 5.4.2).

**Обнаружение ресурсов** -   Процесс, при котором клиент CoAP запрашивает у сервера список   размещенные ресурсы (т. е. ссылки, как определено в разделе 7).

**Content-Format** -   Комбинация типа Интернет-СМИ, потенциально с   определенные параметры и кодирование содержимого (которое часто   кодирование содержимого идентичности), идентифицируемый числовым идентификатором   определяется реестром «CoAP Content-Formats». Когда в центре внимания   меньше по числовому идентификатору, чем по их комбинации   характеристики представления ресурса, это также называется   «формат представления».

 Дополнительная терминология для ограниченных узлов и ограниченных узлов  сети можно найти в [RFC7228].

 В этой спецификации термин «байт» используется в его теперь обычном  смысл как синоним слова «октет».

 Все многобайтовые целые числа в этом протоколе интерпретируются в сети.  порядок байтов.

 Там, где используется арифметика, в данной спецификации используется обозначение  знаком по языку программирования C, за исключением того, что оператор  «**» означает возведение в степень.

# 2. Протокол ограниченного приложения

 Модель взаимодействия CoAP аналогична модели клиент / сервер HTTP. Однако межмашинное взаимодействие обычно приводит к
 в реализации CoAP, действующей как в роли клиента, так и в роли сервера. А  Запрос CoAP эквивалентен запросу HTTP и отправляется клиентом в
 запросить действие (используя код метода) над ресурсом (обозначенным  URI) на сервере. Затем сервер отправляет ответ с Response
 Код; этот ответ может включать в себя представление ресурса.

 В отличие от HTTP, CoAP обрабатывает эти обмены асинхронно через
 ориентированный на дейтаграммы транспорт, такой как UDP. Это сделано логично
 используя уровень сообщений, который поддерживает дополнительную надежность (с
 экспоненциальный откат). CoAP определяет четыре типа сообщений:
 Подтверждаемый, Неподтверждаемый, Подтверждение, Сброс. Коды методов
 и коды ответа, включенные в некоторые из этих сообщений, заставляют их нести
 запросы или ответы. Основные биржи четырех типов
 сообщения несколько ортогональны запросу / ответу
 взаимодействия; запросы могут быть подтверждены и не
 подтверждаемые сообщения, а также в них могут передаваться ответы.
 как совмещены в сообщениях подтверждения.

 Логически CoAP можно рассматривать как использование двухуровневого подхода,
 Уровень обмена сообщениями CoAP, используемый для работы с UDP и асинхронными
 характер взаимодействий и взаимодействия запросов / ответов
 используя коды метода и ответа (см. рисунок 1). CoAP, однако,
 единый протокол, с обменом сообщениями и запросом / ответом как просто функциями
 заголовка CoAP.

    |---------------------- |
    | Приложение            |
    |---------------------- |
    |---------------------- | \
    | Запросы / ответы      | |
    | ----------------------| | CoAP
    | Сообщения             | |
    |---------------------- | /
    |---------------------- |
    | UDP                   |
    |---------------------- |

    Рисунок 1: Абстрактное наслоение CoAP



## 2.1. Модель обмена сообщениями

Модель обмена сообщениями CoAP основана на обмене сообщениями через  UDP между конечными точками.

Модель обмена сообщениями CoAP основана на обмене сообщениями по UDP между конечными точками.

CoAP использует короткий двоичный заголовок фиксированной длины (4 байта), за которым могут следовать компактные двоичные параметры и полезная нагрузка. Этот формат сообщения используется в запросах и ответах. Формат сообщения CoAP указан в разделе 3. Каждое сообщение содержит идентификатор сообщения, используемый для обнаружения дубликатов и дополнительной надежности. (Идентификатор сообщения компактный; его 16-битный размер позволяет передавать до 250 сообщений в секунду от одной конечной точки к другой с параметрами протокола по умолчанию.)

Надежность обеспечивается пометкой сообщения как Подтверждаемое (CON).
Подтверждаемое сообщение повторно передается с использованием тайм-аута по умолчанию и экспоненциальной задержки между повторными передачами, пока получатель не отправит сообщение подтверждения (ACK) с тем же идентификатором сообщения (в этом примере 0x7d34) от соответствующей конечной точки; см. рисунок 2.
Когда получатель вообще не может обработать подтверждаемое сообщение (т. Е. Даже не может предоставить подходящий ответ об ошибке), он отвечает сообщением сброса (RST) вместо подтверждения (ACK).

            Client              Server
               |                  |
               |   CON [0x7d34]   |
               +----------------->|
               |                  |
               |   ACK [0x7d34]   |
               |<-----------------+
               |                  |

        Рисунок 2: Надежная передача сообщений

 Сообщение, не требующее надежной передачи (например,  каждое отдельное измерение из потока данных датчика) может быть отправлено
 как неподтвержденное сообщение (NON). Это не признается, но  все еще есть идентификатор сообщения для обнаружения дубликатов (в этом примере  0x01a0); см. рисунок 3. Когда получатель не может обработать  Неподтвержденное сообщение, он может ответить сообщением сброса (RST).

                Client              Server
                   |                  |
                   |   NON [0x01a0]   |
                   +----------------->|
                   |                  |

        Рисунок 3: Ненадежная передача сообщений

 См. Раздел 4 для получения подробной информации о сообщениях CoAP.

 Поскольку CoAP работает через UDP, он также поддерживает использование многоадресного IP.
 адреса назначения, позволяющие выполнять многоадресные запросы CoAP. Раздел 8
 обсуждает правильное использование сообщений CoAP с многоадресными адресами.
 и меры предосторожности, чтобы избежать перегрузки ответа.

 В разделе 9 для CoAP определены несколько режимов безопасности, начиная от
 нет безопасности для безопасности на основе сертификатов. В этом документе указывается
 привязка к DTLS для защиты протокола; использование IPsec с CoAP
 обсуждается в [IPsec-CoAP].

## 2.2. Модель запроса / ответа

 Семантика запроса и ответа CoAP передается в сообщениях CoAP,
 которые включают либо код метода, либо код ответа, соответственно.
 Необязательная (или по умолчанию) информация о запросе и ответе, например
 URI и тип носителя полезной нагрузки передаются как опции CoAP. Токен - это
 используется для сопоставления ответов на запросы независимо от основного
 сообщения (раздел 5.3). (Обратите внимание, что Токен - это отдельная концепция
 из идентификатора сообщения.)

 Запрос передается в подтверждаемом (CON) или неподтвержденном (NON)
 сообщение, и, если доступно сразу, ответ на запрос
 переносится в Подтверждаемом сообщении, переносится в результирующем
 Сообщение подтверждения (ACK). Это называется совмещенным
 ответ, подробно описанный в разделе 5.2.1. (Нет необходимости в
 отдельное подтверждение совмещенного ответа, поскольку клиент будет
 повторно передать запрос, если сообщение подтверждения, несущее
 совмещенный ответ теряется.) Два примера для базового запроса GET
 с совмещенным ответом показаны на рисунке 4, один успешный, один
 в результате будет получен ответ 4,04 (не найдено).

        Client              Server       Client              Server
           |                  |             |                  |
           |   CON [0xbc90]   |             |   CON [0xbc91]   |
           | GET /temperature |             | GET /temperature |
           |   (Token 0x71)   |             |   (Token 0x72)   |
           +----------------->|             +----------------->|
           |                  |             |                  |
           |   ACK [0xbc90]   |             |   ACK [0xbc91]   |
           |   2.05 Content   |             |  4.04 Not Found  |
           |   (Token 0x71)   |             |   (Token 0x72)   |
           |     "22.5 C"     |             |   "Not found"    |
           |<-----------------+             |<-----------------+
           |                  |             |                  |
    Рисунок 4: Два запроса GET с совмещенными ответами

 Если сервер не может немедленно ответить на переданный запрос
 в подтверждающем сообщении он просто отвечает пустым
 Сообщение с подтверждением, чтобы клиент мог прекратить повторную передачу
 запрос. Когда ответ готов, сервер отправляет его в
 новое подтверждаемое сообщение (которое, в свою очередь, должно быть подтверждено
 заказчиком). Это называется «отдельный ответ», как показано на рисунке.
 на рисунке 5 и более подробно описано в разделе 5.2.2.

                        Client              Server
                           |                  |
                           |   CON [0x7a10]   |
                           | GET /temperature |
                           |   (Token 0x73)   |
                           +----------------->|
                           |                  |
                           |   ACK [0x7a10]   |
                           |<-----------------+
                           |                  |
                           ... Time Passes  ...
                           |                  |
                           |   CON [0x23bb]   |
                           |   2.05 Content   |
                           |   (Token 0x73)   |
                           |     "22.5 C"     |
                           |<-----------------+
                           |                  |
                           |   ACK [0x23bb]   |
                           +----------------->|
                           |                  |

        Рисунок 5: Запрос GET с отдельным ответом

 Если запрос отправляется в сообщении без подтверждения, то ответ  отправляется с использованием нового неподтвержденного сообщения, хотя сервер может  вместо этого отправьте подтверждающее сообщение. Этот тип обмена  проиллюстрировано на рисунке 6.


                        Client              Server
                           |                  |
                           |   NON [0x7a11]   |
                           | GET /temperature |
                           |   (Token 0x74)   |
                           +----------------->|
                           |                  |
                           |   NON [0x23bc]   |
                           |   2.05 Content   |
                           |   (Token 0x74)   |
                           |     "22.5 C"     |
                           |<-----------------+
                           |                  |

    Рисунок 6: Запрос и ответ, не подлежащие подтверждению Сообщения

 CoAP использует методы GET, PUT, POST и DELETE в аналогичных  в HTTP, с семантикой, указанной в Разделе 5.8. (Примечание
 что подробная семантика методов CoAP "почти, но не полностью в отличие от "[HHGTTG] методов HTTP: интуиция взята из
 HTTP-опыт обычно применим, но и этого достаточно  различия, из-за которых действительно стоит прочитать настоящее
 Технические характеристики.)

 Методы, выходящие за рамки четырех основных, могут быть добавлены в CoAP отдельно.
 технические характеристики. Новые методы не обязательно должны использовать запросы
 и ответы в парах. Даже для существующих методов один запрос
 может давать несколько ответов, например, для многоадресного запроса
 (Раздел 8) или с опцией Наблюдать [НАБЛЮДАТЬ].

 Поддержка URI на сервере упрощена, поскольку клиент уже анализирует
 URI и разбивает его на компоненты хоста, порта, пути и запроса,
 использование значений по умолчанию для повышения эффективности. Коды ответов относятся
 к небольшому подмножеству кодов состояния HTTP с несколькими кодами, специфичными для CoAP
 добавлен, как определено в Разделе 5.9.

## 2.3. Посредники и кеширование

 Протокол поддерживает кеширование ответов, чтобы
 оперативно выполнять запросы. Простое кеширование включается с помощью
 информация о свежести и достоверности, содержащаяся в ответах CoAP. А
 кеш может быть расположен в конечной точке или посреднике. Кеширование
 функциональность указана в разделе 5.6.

 Проксирование полезно в ограниченных сетях по нескольким причинам.
 в том числе для ограничения сетевого трафика, для повышения производительности, для доступа
 ресурсы спальных устройств и по соображениям безопасности. В
 поддерживается проксирование запросов от имени другой конечной точки CoAP
 в протоколе. При использовании прокси URI ресурса для
 запрос включен в запрос, а IP-адрес назначения
 устанавливается на адрес прокси. См. Раздел 5.7 для получения дополнительной информации.
 информация о функционале прокси.

 Поскольку CoAP был разработан в соответствии с архитектурой REST [REST], и
 таким образом демонстрирует функциональность, аналогичную протоколу HTTP, он
 довольно просто отобразить из CoAP в HTTP и из HTTP в
 CoAP. Такое сопоставление может использоваться для реализации интерфейса HTTP REST.
 с помощью CoAP или для преобразования между HTTP и CoAP. Это преобразование может
 будет осуществляться через межпротокольный прокси («кросс-прокси»), который
 преобразует метод или код ответа, тип мультимедиа и параметры в
 соответствующая функция HTTP. Раздел 10 содержит более подробную информацию о
 Отображение HTTP.

## 2.4. Обнаружение ресурсов

 Обнаружение ресурсов важно для межмашинного взаимодействия  и поддерживается с использованием формата ссылки CoRE [RFC6690], как описано в Раздел 7.

# 3. Формат сообщения

 CoAP основан на обмене компактными сообщениями, которые по умолчанию
 транспортируются по UDP (т. е. каждое сообщение CoAP занимает данные
 раздел одной дейтаграммы UDP). CoAP также может использоваться поверх дейтаграммы.
 Безопасность транспортного уровня (DTLS) (см. Раздел 9.1). Это также могло быть
 используется поверх других транспортных средств, таких как SMS, TCP или SCTP,
 спецификация которого выходит за рамки этого документа. (UDP-lite
 [RFC3828] и нулевая контрольная сумма UDP [RFC6936] не поддерживаются CoAP.)

 Сообщения CoAP кодируются в простом двоичном формате. Сообщение
 формат начинается с 4-байтового заголовка фиксированного размера. Далее следует
 значение токена переменной длины, длина которого может составлять от 0 до 8 байтов.

 После значения токена следует последовательность из нуля или более CoAP.
 Опции в формате Тип-Длина-Значение (TLV), за которым может следовать
 полезная нагрузка, занимающая остальную часть дейтаграммы.

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |Ver| T |  TKL  |      Code     |          Message ID           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Token (if any, TKL bytes) ...
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Options (if any) ...
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |1 1 1 1 1 1 1 1|    Payload (if any) ...
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
                             Figure 7: Message Format


Поля в заголовке определены следующим образом:

 Версия (Ver): 2-битное целое число без знака. Указывает версию CoAP
  номер. Реализации этой спецификации ДОЛЖНЫ установить это поле
  в 1 (01 двоичный). Другие значения зарезервированы для будущих версий.
  Сообщения с неизвестными номерами версий ДОЛЖНЫ игнорироваться.

 Тип (T): 2-битовое целое число без знака. Указывает, принадлежит ли это сообщение
  тип Подтверждаемый (0), Неподтвержденный (1), Подтверждение (2) или
  Сброс (3). Семантика этих типов сообщений определена в
  Раздел 4.

 Длина токена (TKL): 4-битовое целое число без знака. Указывает длину
  поле токена переменной длины (0-8 байтов). Длины 9-15 ар
  зарезервировано, НЕ ДОЛЖНО быть отправлено и ДОЛЖНО обрабатываться как сообщение
  ошибка формата.

 Код: 8-битное целое число без знака, разделенное на 3-битный класс (большинство
  значащие биты) и 5-битная деталь (младшие значащие биты),
  задокументировано как «c.dd», где «c» - это цифра от 0 до 7 для
  3-битное подполе и "dd" - две цифры от 00 до 31 для 5-битного
  подполе. Класс может указывать на запрос (0), успех
  ответ (2), ответ об ошибке клиента (4) или ошибка сервера
  ответ (5). (Все остальные значения класса зарезервированы.) Как
  В особом случае код 0.00 указывает на пустое сообщение. В случае
  запрос, поле Код указывает Метод запроса; в случае
  ответ, код ответа. Возможные значения сохраняются в
  Реестры кодов CoAP (раздел 12.1). Семантика запросов
  и ответы определены в Разделе 5.

 Идентификатор сообщения: 16-битовое целое число без знака в сетевом порядке байтов. Привыкший
  обнаруживать дублирование сообщений и сопоставлять сообщения типа
  Подтверждение / Возврат к сообщениям типа Подтверждаемый / Не-
  подтверждаемый. Правила генерации идентификатора сообщения и сопоставления
  сообщения определены в разделе 4.

 За заголовком следует значение токена, которое может составлять от 0 до 8 байтов,
 как указано в поле «Длина токена». Значение токена используется для
 соотносите запросы и ответы. Правила генерации токена
 а соответствующие запросы и ответы определены в Разделе 5.3.1.

 За заголовком и токеном следует ноль или более опций (раздел 3.1).
 За Option может следовать конец сообщения, другой
 Option или маркером полезной нагрузки и полезной нагрузкой.

 После заголовка, токена и параметров, если таковые имеются, идет необязательный
 полезная нагрузка. Если присутствует и имеет ненулевую длину, ему предшествует префикс
 фиксированный однобайтовый маркер полезной нагрузки (0xFF), который указывает конец
 параметры и начало полезной нагрузки. Данные полезной нагрузки простираются от
 после маркера до конца дейтаграммы UDP, т.е.
 Длина рассчитывается исходя из размера дейтаграммы. Отсутствие
 Маркер полезной нагрузки обозначает полезную нагрузку нулевой длины. Наличие
 маркер, за которым следует полезная нагрузка нулевой длины, ДОЛЖЕН обрабатываться как
 ошибка формата сообщения.

 Примечание по реализации: значение байта 0xFF может также встречаться в
  длина или значение параметра, поэтому простое побайтовое сканирование для 0xFF является
  не жизнеспособный метод для поиска маркера полезной нагрузки. Байт
  0xFF имеет значение маркера полезной нагрузки только там, где начало
  возможен другой вариант.

## 3.1. Формат опций

 CoAP определяет ряд параметров, которые могут быть включены в сообщение.
 Каждый экземпляр параметра в сообщении указывает номер параметра
 определенный параметр CoAP, длина значения параметра и параметр
 Цените себя.

 Вместо того, чтобы указывать номер опции напрямую, экземпляры ДОЛЖНЫ
 появляются в порядке их номеров опций, и используется дельта-кодировка
 между ними: номер варианта для каждого экземпляра рассчитывается как
 сумма его дельты и номера опции предыдущего экземпляра
 в сообщении. Для первого экземпляра сообщения предшествующий
 предполагается экземпляр опции с нулевым номером опции. Несколько
 экземпляры одного и того же параметра могут быть включены с помощью дельты
 нуль.

 Номера опций хранятся в реестре «Номера опций CoAP».
 (Раздел 12.2). См. Раздел 5.4 о семантике опций.
 определено в этом документе.


         0   1   2   3   4   5   6   7
       +---------------+---------------+
       |               |               |
       |  Option Delta | Option Length |   1 byte
       |               |               |
       +---------------+---------------+
       \                               \
       /         Option Delta          /   0-2 bytes
       \          (extended)           \
       +-------------------------------+
       \                               \
       /         Option Length         /   0-2 bytes
       \          (extended)           \
       +-------------------------------+
       \                               \
       /                               /
       \                               \
       /         Option Value          /   0 or more bytes
       \                               \
       /                               /
       \                               \
       +-------------------------------+
    
    Рисунок 8: Формат опций

 Поля в опции определены следующим образом:

 Опция Delta: 4-битное целое число без знака. Значение от 0 до 12
  указывает Дельта Опциона. Три значения зарезервированы для специальных
  конструкции:

  13: 8-битовое целое число без знака следует за начальным байтом и
   указывает Дельта опциона минус 13.

  14: 16-битовое целое число без знака в сетевом порядке байтов следует за
   начальный байт и указывает дельту опций минус 269.

  15: Зарезервировано для маркера полезной нагрузки. Если в поле установлено это
   значение, но весь байт не является маркером полезной нагрузки, это ДОЛЖНО
   обрабатываться как ошибка формата сообщения.


  Результирующая дельта опций используется как разница между
  Вариант Номер этой опции и предыдущей опции (или
  ноль для первого варианта). Другими словами, номер варианта
  рассчитывается простым суммированием значений Option Delta этого и
  все предыдущие варианты перед ним.

 Длина опции: 4-битовое целое число без знака. Значение от 0 до 12
  указывает длину значения параметра в байтах. Три значения
  зарезервированы для специальных конструкций:

  13: 8-битовое целое число без знака предшествует значению параметра и
   указывает длину опции минус 13.

  14: 16-битное целое число без знака в сетевом порядке байтов предшествует
   Значение параметра и указывает длину параметра минус 269.

  15: Зарезервировано для использования в будущем. Если в поле установлено это значение,
   он ДОЛЖЕН обрабатываться как ошибка формата сообщения.

 Значение: последовательность ровно байтов длины параметра. Длина и
  формат значения параметра зависит от соответствующего параметра, который
  МОЖЕТ определять значения переменной длины. См. Раздел 3.2 для
  форматы, используемые в этом документе; параметры, определенные в других документах
  МОЖЕТ использовать другие форматы значений опций.

## 3.2. Форматы значений параметров

 Параметры, определенные в этом документе, используют следующие параметры
 форматы значений.

 empty: последовательность байтов нулевой длины.

 непрозрачный: непрозрачная последовательность байтов.

 uint: неотрицательное целое число, представленное в сетевом байте
заказ, используя количество байтов, указанное в параметре Длина
поле.

В определении опции может быть указан диапазон допустимых значений.
количество байтов; если у него есть выбор, отправитель ДОЛЖЕН
представляют целое число с минимальным количеством байтов, т. е.
без начальных нулевых байтов. Например, число 0 - это
представлен пустым значением параметра (нулевой
последовательность байтов) и число 1 одним байтом с
числовое значение 1 (битовая комбинация 00000001 в большинстве
обозначение первого значащего бита). Получатель ДОЛЖЕН быть
подготовлен к обработке значений с начальными нулевыми байтами.


Примечание по реализации: разрешенное исключительное поведение
 для отправителя предназначен для сильно ограниченных,
 шаблонные реализации (например, аппаратное обеспечение
 реализации), которые используют параметры фиксированного размера в
 шаблоны.

 строка: строка Unicode, закодированная с использованием UTF-8 [RFC3629] в
Форма Net-Unicode [RFC5198].

Обратите внимание, что здесь и во всех других местах, где UTF-8
кодирование используется в протоколе CoAP, намерение
что закодированные строки можно напрямую использовать и сравнивать
как непрозрачные байтовые строки реализациями протокола CoAP.
Нет никаких ожиданий и нет необходимости выполнять
нормализация в реализации CoAP (кроме случаев, когда
Строки Unicode, которые, как известно, не нормализованы:
импортированы из источников вне протокола CoAP). Примечание
также строки ASCII (в которых не используются специальные
управляющие символы) всегда действительны UTF-8 Net-Unicode
струны.

# 4. Передача сообщений

 Обмен сообщениями CoAP осуществляется асинхронно между конечными точками CoAP.
 Они используются для передачи запросов и ответов CoAP, семантика
 из которых определены в разделе 5.

 Поскольку CoAP привязан к ненадежным транспортам, таким как UDP, сообщения CoAP
 может прибыть из строя, выглядеть дублированным или пропасть без вести
 уведомление. По этой причине CoAP обеспечивает легкую надежность.
 механизм, не пытаясь воссоздать полный набор функций
 транспорт вроде ПТС. Он имеет следующие особенности:

* Простая надежность повторной передачи с остановкой и ожиданием с экспоненциальной  отсрочка для подтверждаемых сообщений.
* Двойное обнаружение как для Подтверждаемых, так и для Неподтверждаемых   Сообщения.

## 4.1. Сообщения и конечные точки

 Конечная точка CoAP - это источник или место назначения сообщения CoAP. В
 конкретное определение конечной точки зависит от транспортного средства
 используется для CoAP. Для транспортов, определенных в этой спецификации,
 конечная точка идентифицируется в зависимости от используемого режима безопасности (см. Раздел 9): Без защиты конечная точка идентифицируется исключительно по  IP-адрес и номер порта UDP. С другими режимами безопасности  конечная точка определяется в соответствии с режимом безопасности.

 Есть разные типы сообщений. Тип сообщения  определяется полем Тип заголовка CoAP.

 Помимо типа сообщения, сообщение может содержать запрос,  ответ, или быть пустым. Об этом сигнализирует код запроса / ответа.  в заголовке CoAP и относится к запросу / ответу  модель. Возможные значения для поля поддерживаются в коде CoAP.  Реестры (раздел 12.1).

 В пустом сообщении в поле Код установлено значение 0,00. Длина токена  поле ДОЛЖНО быть установлено в 0, и байты данных НЕ ДОЛЖНЫ присутствовать после  поле Идентификатор сообщения. Если есть байты, они ДОЛЖНЫ быть обработаны  как ошибка формата сообщения.

## 4.2. Сообщения передаются надежно

 Надежная передача сообщения инициируется отметкой  сообщение как Подтверждаемое в заголовке CoAP. Подтверждаемое сообщение
 всегда несет либо запрос, либо ответ, если только он не используется  чтобы вызвать сообщение сброса, в этом случае оно пусто. Получатель
 ДОЛЖЕН либо (а) подтвердить Подтверждаемое сообщение с помощью
 Сообщение с подтверждением или (б) отклонить сообщение, если получатель
 не хватает контекста для правильной обработки сообщения, включая ситуации
 где сообщение пусто, используется код с зарезервированным классом (1, 6,
 или 7), или имеется ошибка формата сообщения. Отклонение подтверждаемого
 сообщение осуществляется путем отправки соответствующего сообщения сброса, а в противном случае
 игнорируя это. Сообщение подтверждения ДОЛЖНО отражать идентификатор сообщения
 подтверждаемое сообщение и ДОЛЖНО содержать ответ или быть пустым (см.
 Разделы 5.2.1 и 5.2.2). Сообщение сброса ДОЛЖНО повторять сообщение
 ID подтверждаемого сообщения ДОЛЖЕН быть пустым. Отклонение
 Сообщение подтверждения или сброса (включая случай, когда
 Подтверждение содержит запрос или код с зарезервированным классом, или
 сообщение сброса не является пустым) выполняется путем его молчаливого игнорирования.
 В более общем плане получатели сообщений подтверждения и сброса ДОЛЖНЫ
 НЕ отвечать сообщениями подтверждения или сброса.

 Отправитель повторно передает подтверждаемое сообщение по экспоненциальной
 увеличивая интервалы, пока не получит подтверждение (или сброс
 сообщение) или заканчиваются попытки.

 Повторная передача контролируется двумя вещами, которые ДОЛЖНА конечная точка CoAP.
 отслеживать каждое подтверждаемое сообщение, которое он отправляет, ожидая
 подтверждение (или сброс): тайм-аут и повторная передача
 прилавок. Для нового подтверждаемого сообщения устанавливается начальный тайм-аут.
 на случайную продолжительность (часто не целое число секунд)
 между ACK_TIMEOUT и (ACK_TIMEOUT * ACK_RANDOM_FACTOR) (см.
 Раздел 4.8), а счетчик повторных передач установлен на 0. Когда
 срабатывает тайм-аут и счетчик повторных передач меньше чем
 MAX_RETRANSMIT, сообщение передано повторно, повторная передача
 счетчик увеличивается, а время ожидания удваивается. Если
 счетчик повторных передач достигает MAX_RETRANSMIT по таймауту, или если
 конечная точка получает сообщение Reset, затем попытка передать
 сообщение отменяется, а процесс подачи заявки информируется об ошибке.
 С другой стороны, если конечная точка получает подтверждение в
 время передача считается успешной.

 Эта спецификация не предъявляет строгих требований к точности
 часы, используемые для реализации указанного выше двоичного экспоненциального отката
 алгоритм. В частности, конечная точка может опоздать на определенное
 повторная передача из-за его режима сна и может наверстать упущенное в следующий
 один. Однако минимальный интервал до следующей повторной передачи составляет
 ACK_TIMEOUT, и вся последовательность (повторных) передач ДОЛЖНА оставаться
 в конверте MAX_TRANSMIT_SPAN (см. Раздел 4.8.2), даже если
 это означает, что отправитель может упустить возможность передать.

 Конечная точка CoAP, отправившая сообщение с подтверждением, МОЖЕТ сдаться в
 попытка получить ACK даже до счетчика MAX_RETRANSMIT
 значение достигнуто. Например, приложение отменило
 запрос, так как он больше не требует ответа, или есть другой
 индикация того, что сообщение CON действительно пришло. В частности, CoAP
 сообщение запроса могло вызвать отдельный ответ, и в этом случае
 запрашивающей стороне ясно, что был потерян только ACK и
 повторная передача запроса бесполезна. Однако
 ответчик НЕ ДОЛЖЕН, в свою очередь, полагаться на это межуровневое поведение из
 запрашивающий, то есть он ДОЛЖЕН сохранять состояние для создания ACK для
 запрос, если необходимо, даже если Подтверждаемый ответ уже был
 подтверждено запрашивающим.

 Другой причиной отказа от ретрансляции МОЖЕТ быть получение
 Ошибки ICMP. Если желательно учесть ошибки ICMP,
 смягчить потенциальные атаки спуфинга, реализации ДОЛЖНЫ позаботиться
 для проверки информации об исходной дейтаграмме в ICMP
 сообщение, включая номера портов и информацию заголовка CoAP, такую как
 тип и код сообщения, идентификатор сообщения и токен; если это невозможно
 из-за ограничений API службы UDP, ошибки ICMP ДОЛЖНЫ быть
 игнорируется. Слишком большой пакет ошибок [RFC4443] ("требуется фрагментация и
 DF set "для IPv4 [RFC0792]) не может произойти должным образом и ДОЛЖЕН быть
 игнорируется, если соблюдается примечание по реализации в Разделе 4.6;
 в противном случае они ДОЛЖНЫ использоваться в алгоритме определения MTU пути.
 [RFC4821]. Сообщения ICMP о прекращении подачи и превышении времени ДОЛЖНЫ быть
 игнорируется. Ошибки хоста, сети, порта или протокола, или
 ошибки проблемы с параметром МОГУТ после соответствующей проверки использоваться для
 сообщить приложению об отказе в отправке.

## 4.3. Сообщения, передаваемые без надежности

 Некоторые сообщения не требуют подтверждения. Это
 особенно актуально для сообщений, которые регулярно повторяются для
 требования приложения, такие как повторяющиеся показания датчика
 где возможного успеха достаточно.

 В качестве более легкой альтернативы сообщение может передаваться меньше
 надежно, пометив сообщение как неподтвержденное. Не-
 подтверждаемое сообщение всегда содержит либо запрос, либо ответ и
 НЕ ДОЛЖЕН быть пустым. Неподтвержденное сообщение НЕ ДОЛЖНО быть
 подтверждено получателем. Получатель ДОЛЖЕН отклонить сообщение
 если ему не хватает контекста для правильной обработки сообщения, включая
 случай, когда сообщение пусто, использует код с зарезервированным классом
 (1, 6 или 7) или имеет ошибку формата сообщения. Отклонение не-
 подтверждаемое сообщение МОЖЕТ включать отправку соответствующего сообщения сброса и
 кроме сообщения сброса, отклоненное сообщение ДОЛЖНО быть молчаливым.
 игнорируется.

 На уровне CoAP отправитель не может определить, не
 было получено подтверждаемое сообщение или нет. Отправитель МОЖЕТ выбрать
 передать несколько копий неподтвержденного сообщения в пределах
 MAX_TRANSMIT_SPAN (ограничено положениями Раздела 4.7 в
 в частности, PROBING_RATE, если ответ не получен), или
 сеть может дублировать сообщение в пути. Чтобы включить ресивер
 действовать только один раз в сообщении, в неподтвержденных сообщениях указывается
 Идентификатор сообщения тоже. (Этот идентификатор сообщения взят из того же номера
 пробел в качестве идентификаторов сообщений для подтверждаемых сообщений.)

 Обобщая разделы 4.2 и 4.3, можно использовать четыре типа сообщений.
 как в таблице 1. "*" означает, что комбинация не используется в обычных
 операции, но только для вызова сообщения сброса («эхо-запрос CoAP»).

|        | CON  | NON  | ACK  | RST  |
| ------ | ---- | ---- | ---- | ---- |
| Запрос | X    | X    | -    | -    |
| Ответ  | X    | X    | X    | -    |
| Пусто  | *    | -    | X    | X    |

Таблица 1: Использование типов сообщений

## 4.4. Корреляция сообщений

 Сообщение подтверждения или сброса связано с подтверждаемым
 сообщение или неподтвержденное сообщение с помощью идентификатора сообщения вместе
 с дополнительной адресной информацией соответствующей конечной точки.
 Идентификатор сообщения представляет собой 16-битовое беззнаковое целое число, которое Generat - й изд самыми
 отправитель Подтверждаемого или Неподтвержденного сообщения и включен в
 заголовок CoAP. Идентификатор сообщения ДОЛЖЕН отражаться в
 Подтверждение или сброс сообщения получателем.

 Тот же идентификатор сообщения НЕ ДОЛЖЕН использоваться повторно (при обмене данными с
 та же конечная точка) в EXCHANGE_LIFETIME (раздел 4.8.2).

 Примечание по реализации: можно использовать несколько стратегий реализации.
  используется для генерации идентификаторов сообщений. В простейшем случае CoAP
  конечная точка генерирует идентификаторы сообщений, сохраняя один идентификатор сообщения
  переменная, которая изменяется каждый раз, когда появляется новое Подтверждаемое или Не-
  подтверждаемое сообщение отправлено независимо от адреса назначения
  или порт. Конечные точки, обрабатывающие большое количество транзакций
  может хранить несколько переменных идентификатора сообщения, например, для каждого префикса
  или адрес назначения. (Обратите внимание, что некоторые принимающие конечные точки могут
  не может различать одноадресные и многоадресные пакеты, адресованные
  к нему, поэтому конечные точки, генерирующие идентификаторы сообщений, должны убедиться, что эти
  не перекрываются.) Настоятельно рекомендуется, чтобы начальная
  значение переменной (например, при запуске) должно быть рандомизировано в порядке
  чтобы снизить вероятность успешных атак на протокол вне маршрута.

 Чтобы сообщение подтверждения или сброса соответствовало подтверждаемому или
 Неподтвержденное сообщение, идентификатор сообщения и конечная точка источника
 Сообщение подтверждения или сброса ДОЛЖНО соответствовать идентификатору сообщения и
 конечная точка назначения подтверждаемого или неподтвержденного сообщения.

## 4.5. Дедупликация сообщений

 Получатель может получить такое же подтверждаемое сообщение (как указано  по идентификатору сообщения и исходной конечной точке) несколько раз в пределах  EXCHANGE_LIFETIME (раздел 4.8.2), например, когда его  Подтверждение пропало или не дошло до исходного отправителя  до первого тайм-аута. Получатель ДОЛЖЕН подтвердить каждый  дубликат Подтверждаемого сообщения с использованием того же  Сообщение подтверждения или сброса, но СЛЕДУЕТ обработать любой запрос или ответ в сообщении только один раз. Это правило МОЖЕТ быть ослаблено в случае  Подтверждаемое сообщение передает идемпотентный запрос (см.  Раздел 5.1) или может быть обработан идемпотентным способом. Примеры  для упрощенной дедупликации сообщений:

* Сервер может ослабить требование отвечать на все повторные передачи     идемпотентного запроса с тем же ответом (раздел 4.2), поэтому  что ему не нужно поддерживать состояние идентификаторов сообщений. Для  Например, реализация может захотеть обработать повторяющиеся   передачи запроса GET, PUT или DELETE как отдельные  запросы, если затраты на повторную обработку меньнее дорогие, чем отслеживание предыдущих ответов.
* Ограниченный сервер может даже захотеть ослабить это требование для     определенные неидемпотентные запросы, если семантика приложения делает   этот компромисс выгоден. Например, если результат POST  запрос - это просто создание некоторого кратковременного состояния на   сервер, это может быть менее затратно, если потребуется несколько     раз для запроса, чем отслеживание того, был ли предыдущий     передача того же запроса уже была обработана.
* Получатель может получить такое же неподтвержденное сообщение (как  указывается идентификатором сообщения и исходной конечной точкой) несколько раз  в течение NON_LIFETIME (Раздел 4.8.2). Как правило, это МОЖЕТ быть  смягчены в зависимости от конкретной семантики сообщения, получатель  СЛЕДУЕТ молча игнорировать любое повторяющееся неподтвержденное сообщение и  СЛЕДУЕТ обрабатывать любой запрос или ответ в сообщении только один раз.

## 4.6. Размер сообщения

 В то время как определенные канальные уровни позволяют сохранять сообщения CoAP,
 достаточно малы, чтобы поместиться в их пакеты канального уровня (см. Раздел 1),
 это вопрос качества реализации. Спецификация CoAP
 сам по себе обеспечивает только верхнюю границу размера сообщения. Сообщения
 размер больше, чем IP-пакет, приводит к нежелательной фрагментации пакета.
 Сообщение CoAP, должным образом инкапсулированное, ДОЛЖНО вписываться в
 один IP-пакет (т. е. избежать фрагментации IP) и
 одна полезная нагрузка UDP), очевидно, должна уместиться в одной дейтаграмме IP.
 Если значение MTU пути для пункта назначения неизвестно, значение MTU IP равно 1280.
 СЛЕДУЕТ предполагать байты; если ничего не известно о размере
 заголовки, хорошие верхние границы составляют 1152 байта для размера сообщения и
 1024 байта для размера полезной нагрузки.

 Примечание по реализации: выбор параметров размера сообщения CoAP работает   хорошо работает с IPv6 и с большинством современных путей IPv4. (Тем не мение,   с IPv4 сложнее полностью гарантировать отсутствие IP   фрагментация. Если поддержка IPv4 в необычных сетях является    рассмотрение, реализации могут захотеть ограничиться   более консервативные размеры дейтаграммы IPv4, например 576 байт; на  [RFC0791], абсолютное минимальное значение IP MTU для IPv4 равно   меньше 68 байт, что оставит только 40 байт минус безопасность   накладные расходы на полезную нагрузку UDP. Реализации чрезвычайно ориентированы на   этот набор проблем может также установить бит IPv4 DF и выполнить некоторые   форма определения MTU пути [RFC4821]; это обычно должно быть   Однако в реальных случаях использования CoAP это не нужно.)   важным видом фрагментации во многих сетях с ограничениями является  что на уровне адаптации (например, пакеты 6LoWPAN L2 ограничены   до 127 байт, включая различные накладные расходы); это может мотивировать   реализации, чтобы быть экономными в размерах своих пакетов и перейти на   поблочные переводы [БЛОК] при приближении трехзначного сообщения   размеры.

  Размеры сообщений также имеют большое значение для
  реализации на ограниченных узлах. Многие реализации будут
  необходимо выделить буфер для входящих сообщений. Если
  реализация слишком ограничена, чтобы позволить выделить
  вышеупомянутую верхнюю границу, можно было бы применить следующие
  Стратегия реализации для сообщений, не использующих безопасность DTLS:
  Реализации, получающие дейтаграмму в буфер, который тоже
  small обычно способны определить, является ли конечная часть
  дейтаграмма была отброшена и для получения начальной части. Так,
  хотя бы заголовок и параметры CoAP, если не всю полезную нагрузку,
  скорее всего уместятся в буфере. Таким образом, сервер может полностью
  интерпретировать запрос и вернуть 4.13 (Request Entity Too Large;
  см. Раздел 5.9.2.9) Код ответа, если полезная нагрузка была усечена.
  Клиент, отправляющий идемпотентный запрос и получающий ответ
  больше, чем поместится в буфере, можно повторить запрос с
  подходящее значение для параметра блокировки [BLOCK].

## 4.7. Контроль перегрузки

 Базовый контроль перегрузки для CoAP обеспечивается экспоненциальным
 обратный механизм в разделе 4.2.

 Чтобы не вызывать перегрузки, клиенты (включая прокси) ДОЛЖНЫ
 строго ограничивайте количество одновременных невыполненных взаимодействий
 что они поддерживают для данного сервера (включая прокси) NSTART.
 Выдающееся взаимодействие - это либо CON, для которого ACK не имеет
 еще не получено, но ожидается (уровень сообщения) или запрос
 для которого еще не получено ни ответа, ни сообщения подтверждения.
 был получен, но все еще ожидается (что может произойти одновременно
 время, считая как одно выдающееся взаимодействие). Значение по умолчанию
 NSTART для этой спецификации равен 1.

 Дальнейшие оптимизации управления перегрузкой и соображения
 ожидается в будущем, может, например, предоставлять автоматические
 инициализация параметров передачи CoAP, определенных в
 Раздел 4.8, и, таким образом, может разрешить значение NSTART больше единицы.

 После EXCHANGE_LIFETIME клиент перестает ожидать ответа на
 Подтверждаемый запрос, для которого не было получено подтверждающее сообщение.

Конкретный алгоритм, по которому клиент перестает «ожидать» ответа.
 на Подтверждаемый запрос, который был подтвержден, или на Не-
 подтверждаемый запрос, не определен. Если это не изменено
 дополнительные оптимизации управления перегрузкой, это ДОЛЖНО быть выбрано в
 таким образом, чтобы конечная точка не превышала среднюю скорость передачи данных
 PROBING_RATE при отправке на другую конечную точку, которая не отвечает.

 Примечание. CoAP возлагает бремя контроля за перегрузкой в основном на
  клиентов. Однако клиенты могут работать со сбоями или действительно
  злоумышленники, например, для выполнения атак усиления (раздел 11.3).
  Чтобы ограничить ущерб (сети и собственной энергии
  ресурсов), серверу СЛЕДУЕТ реализовать некоторое ограничение скорости для своих
  передача ответа на основе разумных предположений о
  Требования к кандидатам. Это наиболее полезно, если ограничение скорости
  можно сделать эффективными только для некорректно функционирующих конечных точек.

## 4.8. Параметры передачи

 Передача сообщений контролируется следующими параметрами:

| имя  | значение по умолчанию |
| ---- | --------------------- |
| ACK_TIMEOUT | 2 секунды |
| ACK_RANDOM_FACTOR | 1.5 |
| MAX_RETRANSMIT | 4 |
| NSTART | 1 |
| DEFAULT_LEISURE | 5 секунд |
| PROBING_RATE | 1 байт в секунду |


  Таблица 2: Параметры протокола CoAP

### 4.8.1. Изменение параметров

 Значения ACK_TIMEOUT, ACK_RANDOM_FACTOR, MAX_RETRANSMIT,
 NSTART, DEFAULT_LEISURE (раздел 8.2) и PROBING_RATE могут быть
 настроен на значения, специфичные для среды приложения
 (включая динамически регулируемые значения); однако конфигурация
 метод выходит за рамки этого документа. РЕКОМЕНДУЕТСЯ, чтобы
 среда приложения использует согласованные значения для этих параметров;
 специфические эффекты работы с несовместимыми значениями в
 прикладная среда выходит за рамки настоящего
 Технические характеристики.

 Параметры передачи были выбраны для достижения поведения в  наличие безопасной перегрузки в Интернете. Если
 конфигурация желает использовать разные значения, ответственность лежит на конфигурации, чтобы гарантировать, что эти свойства управления перегрузкой не  нарушено. В частности, уменьшение ACK_TIMEOUT ниже 1 секунды
 нарушит рекомендации [RFC5405]. ([RTO-CONSIDER] предоставляет
 некоторые дополнительные сведения.) CoAP был разработан, чтобы позволить
 реализации, которые не поддерживают время приема-передачи (RTT)
 измерения. Однако там, где желательно уменьшить
 ACK_TIMEOUT или увеличить NSTART, это можно сделать только
 безопасно при проведении таких измерений. Конфигурации НЕ ДОЛЖНЫ
 уменьшите ACK_TIMEOUT или увеличьте NSTART без использования механизмов, которые
 обеспечить безопасность управления перегрузками, определенную в конфигурации
 или в будущих стандартах.

 ACK_RANDOM_FACTOR НЕ ДОЛЖЕН быть уменьшен ниже 1.0, и он ДОЛЖЕН иметь
 значение, которое достаточно отличается от 1.0, чтобы обеспечить некоторые
 защита от эффектов синхронизации.

 MAX_RETRANSMIT можно свободно регулировать, но значение слишком маленькое.
 уменьшит вероятность того, что подтверждаемое сообщение действительно
 получено, в то время как большее значение, чем указано здесь, потребует дальнейшего
 корректировки значений времени (см. раздел 4.8.2).

 Если выбор параметров передачи приводит к увеличению
 производные значения времени (см. раздел 4.8.2), механизм конфигурации
 ДОЛЖЕН гарантировать, что скорректированное значение также доступно для всех конечных точек.
 с которыми эти скорректированные значения должны использоваться для связи.

### 4.8.2. Значения времени, полученные из параметров передачи

 Комбинация ACK_TIMEOUT, ACK_RANDOM_FACTOR и MAX_RETRANSMIT
 влияет на время повторных передач, что, в свою очередь, влияет на
 как долго определенные информационные элементы должны храниться
 выполнение. Чтобы иметь возможность однозначно ссылаться на эти производные
 значения времени, мы даем им следующие названия:

* MAX_TRANSMIT_SPAN - максимальное время от первой передачи
  Подтверждаемого сообщения до его последней повторной передачи. Для
  параметры передачи по умолчанию, значение (2 + 4 + 8 + 16) * 1,5 = 45
  секунд или, в более общем смысле:

   ACK_TIMEOUT * ((2 ** MAX_RETRANSMIT) - 1) * ACK_RANDOM_FACTOR

* MAX_TRANSMIT_WAIT - максимальное время с первой передачи
  Подтверждаемого сообщения до того момента, когда отправитель откажется от
  получение подтверждения или сброса. По умолчанию
  параметры передачи, значение равно (2 + 4 + 8 + 16 + 32) * 1,5 = 93
  секунд или, в более общем смысле:

   ACK_TIMEOUT * ((2 ** (MAX_RETRANSMIT + 1)) - 1) *
   ACK_RANDOM_FACTOR

 Кроме того, необходимо сделать некоторые предположения относительно характеристик
 сети и узлов.

* MAX_LATENCY - максимальное время ожидания дейтаграммы.
  от начала передачи до завершения
  прием. Эта константа связана с MSL (Максимальный сегмент
  Lifetime) [RFC0793], который "произвольно определен как 2
  минут "([RFC0793] глоссарий, стр. 81). Обратите внимание, что это не
  обязательно меньше MAX_TRANSMIT_WAIT, так как MAX_LATENCY не
  предназначен для описания ситуации, когда протокол работает хорошо, но
  наихудшая ситуация, от которой протокол должен остерегаться.
  Мы также произвольно определяем MAX_LATENCY равным 100 секундам. Отдельно
  от разумной реалистичности для большинства конфигураций, поскольку
  а также близко к историческому выбору TCP, это значение также
  позволяет отображать таймеры времени существования идентификатора сообщения в 8 битах
  (при измерении в секундах). В этих расчетах нет
  предположение, что направление передачи не имеет значения
  (т. е. что сеть симметрична); есть только
  предположение, что одно и то же значение можно разумно использовать как максимум
  значение для обоих направлений. Если это не так, следующие
  вычисления лишь немного усложняются.

* PROCESSING_DELAY - время, необходимое узлу, чтобы развернуть
  Подтверждаемое сообщение в подтверждение. Мы предполагаем, что узел
  попытается отправить ACK до истечения времени ожидания отправителя, поэтому
  в качестве консервативного предположения мы установили его равным ACK_TIMEOUT.

* MAX_RTT - максимальное время приема-передачи, или:

   (2 * MAX_LATENCY) + PROCESSING_DELAY

 Из этих значений мы можем получить следующие значения, относящиеся к
 протокол операции:

* EXCHANGE_LIFETIME - время от начала отправки подтверждаемого
  сообщение до того момента, когда подтверждение больше не ожидается,
  т.е. информация уровня сообщения об обмене сообщениями может быть
  очищен. EXCHANGE_LIFETIME включает MAX_TRANSMIT_SPAN, a
  MAX_LATENCY вперед, PROCESSING_DELAY и MAX_LATENCY для

  путь назад. Обратите внимание, что нет необходимости учитывать
  MAX_TRANSMIT_WAIT, если конфигурация выбрана так, что
  последний период ожидания (ACK_TIMEOUT * (2 \** MAX_RETRANSMIT) или
  разница между MAX_TRANSMIT_SPAN и MAX_TRANSMIT_WAIT) составляет
  меньше MAX_LATENCY - вероятный выбор, так как MAX_LATENCY
  это значение наихудшего случая, которое вряд ли будет встречено в реальном мире. В
  в этом случае EXCHANGE_LIFETIME упрощается до:

   MAX_TRANSMIT_SPAN + (2 * MAX_LATENCY) + PROCESSING_DELAY

  или 247 секунд с параметрами передачи по умолчанию.

* NON_LIFETIME - время от отправки неподтвержденного сообщения на
  время, когда его идентификатор сообщения может быть безопасно повторно использован. Если несколько
  передача сообщения NON не используется, его значение
  MAX_LATENCY, или 100 секунд. Однако отправитель CoAP может отправить
  NON сообщение несколько раз, в частности, для многоадресной рассылки
  Приложения. Хотя период повторного использования не ограничен
  спецификация, ожидание надежного обнаружения дублирования
  в приемнике находится в масштабе MAX_TRANSMIT_SPAN.
  Поэтому для этой цели безопаснее использовать значение:

   MAX_TRANSMIT_SPAN + MAX_LATENCY

  или 145 секунд с параметрами передачи по умолчанию; тем не мение,
  реализация, которая просто хочет использовать одно значение тайм-аута
  для удаления идентификаторов сообщений можно безопасно использовать большее значение для
  EXCHANGE_LIFETIME.

 В таблице 3 перечислены производные параметры, представленные в этом подразделе.
 со значениями по умолчанию.

| имя | значение по умолчанию |
| -------------------| --------------- |
| MAX_TRANSMIT_SPAN | 45 с |
| MAX_TRANSMIT_WAIT | 93 с |
| MAX_LATENCY | 100 с |
| PROCESSING_DELAY | 2 с |
| MAX_RTT | 202 с |
| EXCHANGE_LIFETIME | 247 с |
| NON_LIFETIME | 145 с |
  Таблица 3: Производные параметры протокола



# 5. Семантика запроса / ответа

 CoAP работает по той же модели запроса / ответа, что и HTTP: CoAP.
 конечная точка в роли «клиента» отправляет один или несколько запросов CoAP на
 «сервер», который обслуживает запросы, отправляя ответы CoAP.
 В отличие от HTTP, запросы и ответы не отправляются через ранее
 установлено соединение, но обмен осуществляется асинхронно через CoAP
 Сообщения.

## 5.1. Запросы

 Запрос CoAP состоит из метода, применяемого к ресурсу,
 идентификатор ресурса, полезная нагрузка и тип интернет-носителя (если
 any) и дополнительные метаданные о запросе.

 CoAP поддерживает основные методы GET, POST, PUT и DELETE, которые
 легко сопоставляются с HTTP. Они обладают такими же свойствами безопасных
 (только поиск) и идемпотент (вы можете вызывать его несколько раз
 с теми же эффектами), что и HTTP (см. раздел 9.1 [RFC2616]). В
 Метод GET безопасен; следовательно, он НЕ ДОЛЖЕН предпринимать никаких других действий с
 ресурс, отличный от поиска. Методы GET, PUT и DELETE ДОЛЖНЫ
 выполняться таким образом, чтобы они были идемпотентными. POST не
 идемпотент, потому что его эффект определяется исходным сервером и
 зависит от целевого ресурса; это обычно приводит к новому
 ресурс создается или целевой ресурс обновляется.

 Запрос инициируется установкой поля Код в заголовке CoAP.
 Подтверждаемого или Неподтвержденного сообщения на Код метода и
 в том числе запросить информацию.

 Методы, используемые в запросах, подробно описаны в Разделе 5.8.

## 5.2. Ответы

 После получения и интерпретации запроса сервер отвечает
 Ответ CoAP, который сопоставляется с запросом с помощью клиента-
 сгенерированный токен (раздел 5.3); обратите внимание, что это отличается от
 Идентификатор сообщения, который соответствует подтвержденному сообщению с его подтверждением.

 Ответ идентифицируется по полю Код в заголовке CoAP,
 установлен на Код ответа. Подобно коду состояния HTTP, CoAP
 Код ответа указывает на результат попытки понять и
 просьбу удовлетворить. Эти коды полностью определены в Разделе 5.9.
 Номера кодов ответа, которые должны быть установлены в поле кода CoAP.
 заголовок хранятся в Реестре кодов ответа CoAP
 (Раздел 12.1.2).

                              0
                              0 1 2 3 4 5 6 7
                             +-+-+-+-+-+-+-+-+
                             |class|  detail |
                             +-+-+-+-+-+-+-+-+

    Рисунок 9: Структура кода ответа

 Три верхних бита 8-битного номера кода ответа определяют
 класс ответа. Младшие пять битов не имеют
 роль категоризации; они придают дополнительную информацию всему классу
 (Рисунок 9).

 В виде удобочитаемых обозначений для спецификаций и протокола
 диагностики, номера кода CoAP, включая код ответа,
 задокументирован в формате "c.dd", где "c" - это класс в десятичной системе счисления,
 а «дд» - это деталь в виде двузначного десятичного числа. Например,
 «Запрещено» записывается как 4.03, что указывает на 8-битное значение кода
 шестнадцатеричный 0x83 (4 * 0x20 + 3) или десятичный 131 (4 * 32 + 3).

 Есть 3 класса кодов ответа:

 2 - Успех: запрос был успешно получен, понят и  принял.

 4 - Ошибка клиента: запрос содержит неверный синтаксис или не может быть  выполнен.

 5 - Ошибка сервера: серверу не удалось выполнить явно действительный запрос.

 Коды ответа разработаны с возможностью расширения: коды ответов в
 класс Client Error или Server Error, которые не распознаются
 конечная точка рассматривается как эквивалент универсального кода ответа
 этого класса (4,00 и 5,00 соответственно). Однако нет  общий код ответа, указывающий на успех, поэтому код ответа в
 Класс успеха, который не распознается конечной точкой, может использоваться только для
 определить, что запрос был успешным, без дальнейших действий
 подробности.

 Возможные коды ответа подробно описаны в разделе 5.9.

 Ответы можно отправлять разными способами, которые определены в
 следующие подразделы.

### 5.2.1. Совмещенный

 В самом простом случае ответ передается прямо в
 Сообщение с подтверждением, подтверждающее запрос (которое требует
 что запрос был передан в Подтверждаемом сообщении). Это
 называется «отклик с совмещением».

 Ответ возвращается в сообщении подтверждения, независимо от
 от того, указывает ли ответ на успех или неудачу. По сути,
 ответ совмещен с сообщением подтверждения, и нет
 отдельное сообщение требуется для возврата ответа.

 Примечание по реализации: протокол оставляет решение, следует ли
  совмещать ответ или нет (т. е. отправлять отдельный ответ) на
  сервер. Клиент ДОЛЖЕН быть готов получить и то, и другое. На
  уровень качества реализации, есть большие ожидания
  что серверы будут реализовывать код для совмещения, когда это возможно -
  экономия ресурсов в сети и как на клиенте, так и на
  сервер.

### 5.2.2. Отдельный

 Возможно, не во всех случаях удастся вернуть совмещенный ответ.
 Например, серверу может потребоваться больше времени для получения представления
 запрошенного ресурса, чем он может ждать, чтобы отправить обратно
 Сообщение с подтверждением, без повторного риска для клиента
 повторная передача сообщения запроса (см. также обсуждение
 PROCESSING_DELAY в Разделе 4.8.2). Ответ на запрос
 в неподтвержденном сообщении всегда отправляется отдельно (как
 сообщения подтверждения нет).

 Один из способов реализовать это на сервере - инициировать попытку
 получить представление ресурса и, пока оно выполняется,
 истекло время таймера подтверждения. Сервер также может сразу
 отправить подтверждение, если он заранее знает, что не будет
 совмещенный ответ. В обоих случаях подтверждение эффективно
 это обещание, что запрос будет обработан позже.

 Когда сервер наконец получил представление ресурса, он
 отправляет ответ. Когда желательно, чтобы это сообщение не
 утеряно, оно отправляется как подтверждающее сообщение с сервера на
 клиент и ответил клиентом Подтверждением, повторяя
 новый идентификатор сообщения, выбранный сервером. (Его также можно отправить как
 Неподтвержденное сообщение; см. раздел 5.2.3.)

 Когда сервер решает использовать отдельный ответ, он отправляет
 Подтверждение подтверждаемого запроса как пустое сообщение. Один раз
 сервер отправляет пустое подтверждение, он НЕ ДОЛЖЕН отправлять обратно  ответ в другом Подтверждении, даже если клиент
 повторно передает другой идентичный запрос. Если повторно переданный запрос
 получено (возможно, из-за того, что исходное Подтверждение было задержано),
 отправляется еще одно пустое подтверждение, и любой ответ ДОЛЖЕН быть отправлен
 как отдельный ответ.

 Если сервер затем отправляет подтверждающий ответ, клиентский
 Подтверждение этого ответа также ДОЛЖНО быть пустым сообщением (одним
 который не несет ни запроса, ни ответа). Сервер ДОЛЖЕН остановиться
 повторная передача своего ответа на любое совпадающее Подтверждение (молча
 игнорируя любой код ответа или полезную нагрузку) или сообщение сброса.

 Замечания по реализации: обратите внимание, что в качестве базовой дейтаграммы
  транспорт может не сохранять последовательность, подтверждаемое сообщение
  ответ может быть доставлен до или после
  Сообщение с подтверждением запроса; Для целей
  завершение последовательности повторной передачи, это также служит
  подтверждение. Отметим также, что, хотя сам протокол CoAP
  здесь не предъявляет особых требований, есть ожидание
  что ответ будет в разумные сроки
  с точки зрения приложения. Поскольку нет никакой основы
  транспортный протокол, которому можно дать указание запустить проверку активности
  механизм, запрашивающий может захотеть установить тайм-аут, который
  не связаны с таймерами повторной передачи CoAP в случае, если сервер
  уничтожены или иным образом не могут отправить ответ.

### 5.2.3. Неподтвержденный

 Если сообщение запроса не подтверждается, то ответ ДОЛЖЕН
 также должны быть возвращены в неподтвержденном сообщении. Однако
 конечная точка ДОЛЖНА быть готова к получению неподтвержденного ответа
 (до или после пустого сообщения подтверждения) в ответ
 на Подтверждаемый запрос или Подтверждаемый ответ в ответ на
 Неподтвержденный запрос.

## 5.3. Соответствие запроса / ответа

 Независимо от того, как отправляется ответ, он сопоставляется с запросом
 средства токена, включенного клиентом в запрос, вместе
 с дополнительной адресной информацией соответствующей конечной точки.

### 5.3.1. Токен

 Токен используется для сопоставления ответа с запросом. Токен
 значение - это последовательность от 0 до 8 байтов. (Обратите внимание, что каждое сообщение
 содержит токен, даже если он нулевой длины.) Каждый запрос
 несет сгенерированный клиентом токен, который сервер ДОЛЖЕН передать эхом (без
 модификация) в любом полученном ответе.

 Токен предназначен для использования в качестве локального идентификатора клиента для
 различение параллельных запросов (см. раздел 5.3); Это
 можно было бы назвать «идентификатором запроса».

 Клиент ДОЛЖЕН генерировать токены таким образом, чтобы токены в настоящее время
 используются для данной пары конечных точек источника / назначения уникальны.
 (Обратите внимание, что клиентская реализация может использовать один и тот же токен для любых
 запросить, использует ли он каждый раз другую конечную точку, например, другую
 номер порта источника.) Подходит пустое значение токена, например, когда
 никакие другие токены не используются для пункта назначения, или когда запросы
 выполняются поочередно для каждого пункта назначения и получают отклики с дополнительными данными.
 Однако существует несколько возможных стратегий реализации
 выполнить это.

 Клиент, отправляющий запрос без использования Transport Layer Security
 (Раздел 9) СЛЕДУЕТ использовать нетривиальный рандомизированный токен для защиты
 против подделки ответов (раздел 11.4). Это защитное использование
 токены - это причина, по которой им разрешено иметь размер до 8 байтов.
 Фактический размер случайного компонента, который будет использоваться для токена.
 зависит от требований безопасности клиента и уровня
 угроза, связанная с подделкой ответов. Клиент, подключенный к
 в общем Интернет ДОЛЖЕН использовать не менее 32 бит случайности,
 помня, что отсутствие прямого подключения к Интернету
 не обязательно достаточная защита от спуфинга. (Обратите внимание, что
 Идентификатор сообщения добавляет немного защиты, как обычно
 последовательно назначены, т. е. предполагаемые, и их можно обойти с помощью
 подделка отдельного ответа.) Клиенты, которые хотят оптимизировать
 Длина токена может также потребоваться для определения уровня продолжающихся атак.
 (например, подсчитывая недавние несоответствия токенов во входящих сообщениях) и
 соответствующим образом отрегулируйте длину токена вверх. [RFC4086] обсуждает
 требования случайности для безопасности.

 Конечная точка, получившая маркер, который она не сгенерировала, ДОЛЖНА обрабатывать
 токен как непрозрачный и не делать никаких предположений о его содержании или
 состав.

### 5.3.2. Правила сопоставления запросов и ответов

 Точные правила сопоставления ответа на запрос следующие:

 1. Исходная конечная точка ответа ДОЛЖНА быть такой же, как и конечная точка
 конечная точка назначения исходного запроса.

 2. В совмещенном ответе идентификатор сообщения подтверждаемого
 запрос и подтверждение ДОЛЖНЫ совпадать, а токены
 ответ и исходный запрос ДОЛЖНЫ совпадать. В отдельном
 ответ, только токены ответа и исходного запроса
 ДОЛЖЕН совпадать.

 Если сообщение, несущее ответ, является неожиданным (клиент
 не дожидаясь ответа от идентифицированной конечной точки, на
 адресуется конечная точка и / или с данным токеном), ответ
 отклонено (разделы 4.2 и 4.3).

 Примечание по реализации: клиент, который получает ответ в CON
  message может захотеть очистить состояние сообщения сразу после отправки
  ACK. Если этот ACK потерян и сервер повторно передает CON,
  у клиента больше не может быть состояния, с которым можно было бы соотнести это
  ответ, что делает повторную передачу неожиданным сообщением; в
  клиент, скорее всего, отправит сообщение сброса, поэтому он не получит никаких
  больше ретрансляций. Такое поведение нормальное, а не
  индикация ошибки. (Клиенты, которые не агрессивно
  оптимизированное в их состоянии использование памяти по-прежнему будет иметь сообщение
  состояние, которое идентифицирует второй CON как повторную передачу.
  Клиенты, которые действительно ожидают большего количества сообщений от сервера
  [НАБЛЮДАТЬ] должен будет сохранять состояние в любом случае.)

## 5.4. Параметры

 И запросы, и ответы могут включать в себя список из одного или нескольких
 параметры. Например, URI в запросе передается в нескольких
 параметры и метаданные, которые будут передаваться в заголовке HTTP в HTTP
 также поставляется в качестве опций.

 CoAP определяет единый набор опций, которые используются в обоих запросах.
 и ответы:

* Content-Format
* ETag
* Location-Path
* Location-Query
* Max-Age
* Proxy-Uri
* Proxy-Scheme
* Uri-Host
* Uri-Path
* Uri-Port
* Uri-Query
* Accept
* If-Match
* If-None-Match
* Size1

Семантика этих параметров вместе с их свойствами  подробно определено в разделе 5.10.

 Не все параметры определены для использования со всеми методами и ответами.
 Коды. Возможные варианты методов и кодов ответа:
 определены в разделах 5.8 и 5.9 соответственно. Если есть вариант
 не определен для метода или кода ответа, он НЕ ДОЛЖЕН включаться
 отправителя и ДОЛЖЕН рассматриваться как нераспознанный вариант со стороны
 получатель.

### 5.4.1. Критический / выборный

 Опции делятся на два класса: «критические» или «факультативные». В
 разница между ними в том, как параметр не распознается конечной точкой
 обрабатывается:

* При приеме непризнанные варианты класса "факультатив" ДОЛЖНЫ быть   молча игнорируется.
* Нераспознанные варианты класса «критический», встречающиеся в
  Подтверждаемый запрос ДОЛЖЕН вызывать возврат 4,02 (неверный вариант)
  отклик. Этот ответ ДОЛЖЕН включать диагностические данные.
  описание нераспознанной опции (ов) (см. Раздел 5.5.2).

* Нераспознанные варианты класса «критический», встречающиеся в
  Подтверждаемый ответ или совмещенный с подтверждением ДОЛЖЕН
  вызвать отклонение ответа (раздел 4.2).

* Нераспознанные варианты класса «критический», которые встречаются в Не-
  подтверждаемое сообщение ДОЛЖНО вызывать отклонение сообщения
  (Раздел 4.3).

 Обратите внимание, что независимо от того, является ли он критическим или факультативным, вариант никогда не  "обязательный" (всегда необязательный): эти правила определены в порядке  чтобы реализации могли остановить обработку параметров, которых они не  понять или реализовать.

 Критические / выборные правила применяются к конечным точкам без прокси. Прокси
 обрабатывает параметры на основе классов Unsafe / Safe-to-Forward, как определено
 в разделе 5.7.

### 5.4.2. Прокси-сервер Небезопасный или Безопасный для пересылки и NoCacheKey

 Помимо того, что вариант отмечен как критический или выборный,
 варианты также классифицируются в зависимости от того, как прокси-сервер должен работать с
 вариант, если он его не распознает. Для этого можно воспользоваться опцией.
 либо считается Небезопасным для пересылки (установлен параметр UnSafe), либо Безопасным для пересылки.
 Вперед (UnSafe ясно).

 Кроме того, для параметра, помеченного как Safe-to-Forward, параметр
 число указывает, предназначен ли он для того, чтобы быть частью
 Cache-Key (раздел 5.6) в запросе. Если некоторые из битов NoCacheKey
 равны 0, это так; если все биты NoCacheKey равны 1, это не так (см.
 Раздел 5.4.6).

 Примечание. Индикация Cache-Key актуальна только для прокси, которые
  не реализовывать данную опцию как опцию запроса, а вместо этого
  полагаться только на индикацию Unsafe / Safe-to-Forward. Например,
  для ETag, фактически используя опцию запроса как часть
  Cache-Key крайне неэффективен, но это лучшее, что можно
  делать, если ETag не реализован прокси, так как ответ идет
  отличаться в зависимости от наличия опции запроса. Более того
  полезный прокси, который реализует опцию запроса ETag, не
  используя ETag как часть Cache-Key.

  NoCacheKey указывается в трех битах, так что только один из
  восемь кодовых точек квалифицируются как NoCacheKey, оставляя семь из
  восемь кодовых точек для наиболее вероятного случая.

 Поведение прокси по отношению к этим классам определено в
 Раздел 5.7.

### 5.4.3. Длина

 Значения параметров определены как имеющие определенную длину, часто в
 форма верхней и нижней границы. Если длина значения опциона
 в запросе находится за пределами определенного диапазона, эта опция ДОЛЖНА быть
 рассматривается как нераспознанный вариант (см. Раздел 5.4.1).

### 5.4.4. Значения по умолчанию

 Параметры могут иметь значение по умолчанию. Если значение
 предполагается, что это значение по умолчанию, параметр НЕ ДОЛЖЕН быть
 включены в сообщение. Если параметр отсутствует, по умолчанию
 значение ДОЛЖНО приниматься.

 Если критический параметр имеет значение по умолчанию, он выбирается в таком
 способ обработки отсутствия опции в сообщении
 правильно как реализациями, не знающими о критическом параметре, так и
 реализациями, интерпретирующими это отсутствие как наличие
 значение по умолчанию для параметра.

### 5.4.5. Повторяемые параметры

 В определении некоторых опций указывается, что эти опции
 повторяемый. Повторяемая опция МОЖЕТ включать один или несколько
 раз в сообщении. Неповторимый вариант НЕ ДОЛЖЕН быть
 включен более одного раза в сообщение.

 Если в сообщении есть параметр с большим количеством вхождений, чем параметр
 определяется для каждого появившегося нештатного вхождения опции
 впоследствии в сообщении ДОЛЖНО рассматриваться как нераспознанное
 вариант (см. раздел 5.4.1).

### 5.4.6. Номера вариантов

 Вариант идентифицируется номером опции, который также предоставляет некоторые
 дополнительная информация о семантике, например, нечетные числа указывают на
 критический вариант, в то время как четные числа указывают на выборный вариант.
 Обратите внимание, что это не просто соглашение, это особенность
 протокол: является ли вариант выборным или критическим, полностью
 определяется тем, является ли его номер опции четным или нечетным.

 В более общем смысле, номер варианта состоит из битов.
 маска, чтобы указать, является ли вариант критическим или выборным, небезопасным или
 Safe-to-Forward и, в случае Safe-to-Forward, для обеспечения
 Индикация ключа кэша, как показано на следующем рисунке. в
 после текста битовая маска выражается в виде одного байта, который
 применяется к младшему байту номера опции в
 беззнаковое целочисленное представление. Когда бит 7 (наименее значимый
 бит) равен 1, опция - Критическая (и аналогично Выборочная, когда 0).
 Когда бит 6 равен 1, опция Unsafe (и аналогично Safe-to-Forward
 когда 0). Когда бит 6 равен 0, т. Е. Параметр не является небезопасным, он не
 Cache-Key (NoCacheKey) тогда и только тогда, когда все биты 3-5 установлены в 1;
 все другие битовые комбинации означают, что это действительно ключ кэша. Эти
 классы опций объясняются в следующих разделах.

                       0   1   2   3   4   5   6   7
                     +---+---+---+---+---+---+---+---+
                     |           | NoCacheKey| U | C |
                     +---+---+---+---+---+---+---+---+

    Рисунок 10: Маска номера опции (младший байт)

 Конечная точка может использовать эквивалент кода C на рисунке 11, чтобы
 вывести характеристики варианта номер «онум».

 Критический = (onum & 1);
 UnSafe = (onum & 2);
 NoCacheKey = ((onum & 0x1e) == 0x1c);

   Рисунок 11: Определение характеристик по номеру опции

 Номера опций для опций, определенных в этом документе:
 перечислены в реестре «Номера вариантов CoAP» (Раздел 12.2).

## 5.5. Полезные данные и представления

 И запросы, и ответы могут включать полезную нагрузку, в зависимости от
 Код метода или ответа соответственно. Если метод или код ответа
 не определен как имеющий полезную нагрузку, то отправитель НЕ ДОЛЖЕН включать ее,
 и получатель ДОЛЖЕН игнорировать это.

### 5.5.1. Представление

 Полезная нагрузка запросов или ответов, указывающих на успех, равна
 обычно представление ресурса («представление ресурса»)
 или результат запрошенного действия («результат действия»). Его формат
 определяется типом Интернет-носителя и кодировкой контента, заданной
 Параметр Content-Format. В отсутствие этого параметра по умолчанию
 значение предполагается, и формат должен быть выведен из
 приложение (например, из контекста приложения). "Обнюхивание" полезной нагрузки
 СЛЕДУЕТ предпринимать попытки только в том случае, если не указан тип содержимого.

 Примечание по реализации: на уровне качества реализации существует
  сильное ожидание, что индикация Content-Format будет
  по возможности снабжены представлениями ресурсов. Это
  не является требованием уровня "ДОЛЖЕН" только потому, что это не
  требование протокола, а также было бы трудно очертить
  в каких именно случаях это ожидание может быть нарушено.

 Для ответов, указывающих на ошибку клиента или сервера, полезная нагрузка
 считается представлением результата запрошенного действия
 только если задана опция Content-Format. В отсутствие этого
 вариант, полезная нагрузка является диагностической полезной нагрузкой (раздел 5.5.2).

### 5.5.2. Диагностическая полезная нагрузка

 Если параметр Content-Format не указан, полезная нагрузка ответов
 указание на ошибку клиента или сервера - краткое, удобочитаемое
 диагностическое сообщение, объясняющее ситуацию ошибки. Эта диагностика
 сообщение ДОЛЖНО быть закодировано с использованием UTF-8 [RFC3629], более конкретно
 с использованием формы Net-Unicode [RFC5198].

 Сообщение аналогично фразе-причине в строке состояния HTTP.
 Он предназначен не для конечных пользователей, а для разработчиков программного обеспечения, которые
 при отладке необходимо интерпретировать это в контексте настоящего,
 Англоязычная спецификация; следовательно, нет механизма для языка
 теги необходимы или предусмотрены. В отличие от обычного HTTP,
 полезная нагрузка ДОЛЖНА быть пустой, если нет дополнительной информации
 за пределами кода ответа.

### 5.5.3. Выбранное представление

 Не все ответы несут полезную нагрузку, которая обеспечивает представление
 ресурс, к которому обращается запрос. Однако иногда
 полезно иметь возможность ссылаться на такое представление по отношению к
 ответ, независимо от того, был ли он действительно приложен.

 Мы используем термин «выбранное представление» для обозначения текущего
 представление целевого ресурса, который был бы выбран в
 успешный ответ, если соответствующий запрос использовал
 метод GET и исключил любые параметры условного запроса
 (Раздел 5.10.8).

 Некоторые варианты ответа предоставляют метаданные о выбранных
 представление, которое может отличаться от представленного
 в сообщении для ответов на некоторые методы изменения состояния. Принадлежащий
 варианты ответа, определенные в этой спецификации, только ETag
 вариант ответа (раздел 5.10.6) определяется как метаданные о
 выбранное представление.

### 5.5.4. Согласование содержания

 Сервер может предоставить представление ресурса в одном
 нескольких форматов представления. Без дополнительной информации от
 клиент предоставит представление в том формате, в котором
 предпочитает.

 Используя опцию принятия (раздел 5.10.4) в запросе, клиент
 может указать, какой формат контента он предпочитает получать.

## 5.6. Кеширование

 Конечные точки CoAP МОГУТ кэшировать ответы, чтобы уменьшить количество ответов.
 потребление времени и пропускной способности сети в будущем, эквивалент
 Запросы.

 Целью кэширования в CoAP является повторное использование предыдущего ответного сообщения для
 удовлетворить текущий запрос. В некоторых случаях сохраненный ответ может быть
 повторно используется без сетевого запроса, что снижает задержку и
 сети туда и обратно; для этого используется механизм «свежести»
 (см. раздел 5.6.1). Даже когда требуется новый запрос, он
 часто возможно повторно использовать полезную нагрузку предыдущего ответа, чтобы удовлетворить
 запрос, тем самым уменьшая использование полосы пропускания сети; "проверка"
 для этого используется механизм (см. раздел 5.6.2).

 В отличие от HTTP кэшируемость ответов CoAP не зависит от
 метод запроса, но это зависит от кода ответа. В
 кэшируемость каждого кода ответа определяется в коде ответа.
 определения в разделе 5.9. Коды ответа, указывающие на успех и
 не распознаются конечной точкой, НЕ ДОЛЖНЫ кэшироваться.

 Для представленного запроса конечная точка CoAP НЕ ДОЛЖНА использовать сохраненный
 ответ, если:

* представленный метод запроса и тот, который использовался для получения сохраненного
  совпадение ответа,

* все варианты совпадают между теми, которые указаны в представленном запросе, и теми,
  запроса, используемого для получения сохраненного ответа (который включает
  URI запроса), за исключением того, что нет необходимости в совпадении каких-либо
  параметры запроса, отмеченные как NoCacheKey (раздел 5.4) или распознанные
  кешем и полностью интерпретируется с учетом указанного
  поведение кеша (например, параметр запроса ETag, описанный в
  Раздел 5.10.6; см. также Раздел 5.4.2), и

* сохраненный ответ либо свежий, либо успешно проверен как
  определено ниже.

 Набор параметров запроса, который используется для сопоставления записи кэша
 также собирательно именуется «ключ кэширования». Для схем URI
 кроме coap и coaps, сопоставление тех вариантов, которые составляют
 URI запроса может выполняться в соответствии с правилами, специфичными для URI
 схема.

### 5.6.1. Модель свежести

 Когда ответ "свежий" в кеше, его можно использовать для удовлетворения
 последующие запросы без обращения к исходному серверу, тем самым
 повышение эффективности.

 Механизм определения актуальности заключается в том, что исходный сервер
 указать время истечения срока действия в будущем, используя параметр Max-Age
 Вариант (см. Раздел 5.10.5). Параметр Max-Age указывает, что
 ответ считается несвежим после того, как его возраст превышает
 указанное количество секунд.

 Параметр Max-Age по умолчанию имеет значение 60. Таким образом, если это не так
 присутствует в кешируемом ответе, то ответ считается не
 свежий после его выдержки более 60 секунд. Если исходный сервер
 желает предотвратить кеширование, он ДОЛЖЕН явно включать Max-Age
 Вариант со значением ноль секунд.

 Если у клиента есть свежий сохраненный ответ и он делает новый запрос
 соответствует запросу для этого сохраненного ответа, новый ответ
 аннулирует старый ответ.

### 5.6.2. Модель валидации

 Когда конечная точка имеет один или несколько сохраненных ответов на запрос GET,
 но не может использовать ни один из них (например, потому что они не свежие), он может
 используйте опцию ETag (раздел 5.10.6) в запросе GET, чтобы указать
 исходный сервер возможность как выбрать сохраненный ответ, который будет
 используется, и для обновления его свежести. Этот процесс известен как
 «проверка» или «повторная проверка» сохраненного ответа.

 При отправке такого запроса конечной точке СЛЕДУЕТ добавить параметр ETag.
 указание тега объекта каждого применимого сохраненного ответа.

 Ответ 2.03 (действительный) указывает сохраненный ответ, идентифицированный
 тег объекта, указанный в опции ETag ответа, можно использовать повторно
 после обновления, как описано в Разделе 5.9.1.3.

 Любой другой код ответа указывает, что ни один из сохраненных ответов
 номинированный в заявке подходит. Вместо этого ответ ДОЛЖЕН
 использоваться для удовлетворения запроса и МОЖЕТ заменить сохраненный ответ.

## 5.7. Прокси

 Прокси-сервер - это конечная точка CoAP, которой клиенты CoAP могут поручить
 выполнять запросы от их имени. Это может быть полезно, например,
 когда запрос не мог быть выполнен иным образом, или для обслуживания
 ответ из кеша, чтобы сократить время отклика и сеть
 пропускная способность или потребление энергии.

 В общей архитектуре среды RESTful с ограничениями
 прокси могут служить совершенно разным целям. Прокси могут быть
 явно выбираемая клиентами, роль, которую мы называем «прокси-сервер».
 Прокси-серверы также могут быть вставлены вместо исходных серверов, роль
 что мы называем «обратным прокси». Ортогонально этому различию, a
 прокси-сервер может отображать запрос CoAP на запрос CoAP (CoAP-to-CoAP
 прокси) или переводить с другого протокола или на другой («кросс-прокси»).
 Полные определения этих терминов приведены в Разделе 1.2.

 Примечания: Терминология в этой спецификации была выбрана
  культурно совместим с терминологией, используемой в более широкой сети
  среды приложений, не обязательно сопоставляя их во всех
  деталь (которая может даже не иметь отношения к ограниченному RESTful
  Среды). Не следует приписывать слишком много семантики
  компоненты терминов (например, «вперед», «назад» или
  "Пересекать").

  HTTP-прокси, помимо работы в качестве HTTP-прокси, часто предлагают
  функция проксирования транспортного протокола ("CONNECT") для включения сквозного
  конечная безопасность транспортного уровня через прокси. Нет такой функции
  определен для прокси CoAP-to-CoAP в этой спецификации, как
  пересылка пакетов UDP вряд ли будет иметь большое значение в
  Ограниченные среды RESTful. См. Также Раздел 10.2.7 для
  случай кросс-прокси.

 Когда клиент использует прокси для отправки запроса, который будет использовать безопасный
 Схема URI (например, «coaps» или «https»), запрос к прокси
 СЛЕДУЕТ отправлять с использованием DTLS, за исключением случаев, когда эквивалентный нижний уровень
 безопасность используется для отрезка между клиентом и прокси.

### 5.7.1. Прокси-операция

 Прокси-серверу обычно нужен способ определения потенциального запроса.
 параметры для запроса, который он помещает в пункт назначения, на основе
 запрос, полученный от своего клиента. Этот способ полностью определен для
 прокси-сервер, но может зависеть от конкретной конфигурации для
 обратный прокси. В частности, клиент обратного прокси
 обычно не указывает указатель места назначения, требуя некоторой формы перевода пространства имен в обратном направлении -
 прокси. Однако некоторые аспекты работы прокси являются общими.
 ко всем его формам.

 Если прокси-сервер не использует кеш, он просто пересылает
 переведенный запрос в определенное место назначения. В противном случае, если это
 использует кеш, но не имеет сохраненного ответа, который соответствует
 переведенный запрос и считается свежим, тогда его нужно
 обновите его кеш в соответствии с Разделом 5.6. Для опций в
 запрос, который распознает прокси, он знает, является ли опция
 предназначен для работы как часть ключа, используемого при поиске кэшированного
 значение или нет. Например, поскольку запросы на разные Uri-Path
 значения относятся к разным ресурсам, значения Uri-Path всегда являются частью
 ключа кэша, в то время как, например, значения токена никогда не являются частью
 Кэш-ключ. Для параметров, которые прокси-сервер не распознает, но которые
 помечены как Safe-to-Forward в номере опции, опция также
 указывает, должен ли он быть включен в Cache-Key (NoCacheKey
 не все установлено) или нет (NoCacheKey установлен полностью). (Варианты, которые
 нераспознанные и отмеченные как Небезопасные приводят к 4.02 Плохой Вариант.)

 Если время ожидания запроса к месту назначения истекло, то 5.04 (шлюз
 Тайм-аут) ДОЛЖЕН быть возвращен. Если запрос в
 пункт назначения возвращает ответ, который не может быть обработан прокси
 (например, из-за нераспознанных критических параметров или ошибок формата сообщения),
 тогда ДОЛЖЕН быть возвращен ответ 5.02 (плохой шлюз). В противном случае
 прокси возвращает ответ клиенту.

 Если ответ генерируется из кеша, сгенерированный (или подразумеваемый)
 Опция максимального возраста НЕ ДОЛЖНА увеличивать максимальный возраст, изначально установленный
 сервер, учитывая время, потраченное представлением ресурса в
 кеш. Например, параметр максимального возраста можно отрегулировать с помощью
 прокси для каждого ответа по формуле:

  proxy-max-age = original-max-age - возраст кеша

 Например, если запрос сделан к прокси-ресурсу, который был
 обновлено 20 секунд назад и имело исходное значение Max-Age 60 секунд,
 тогда максимальный возраст этого ресурса составляет 40 секунд. Учитывая
 возможные задержки сети на пути от исходного сервера, прокси
 должны быть консервативными в предлагаемых значениях максимального возраста.

 Все параметры, представленные в запросе прокси, ДОЛЖНЫ обрабатываться на
 прокси. Небезопасные варианты запроса, которые не распознаются
 прокси ДОЛЖЕН привести к ответу 4.02 (неверный вариант), возвращаемому
 прокси. Прокси-сервер CoAP-to-CoAP ДОЛЖЕН пересылать исходному серверу все
 Параметры Safe-to-Forward, которые он не распознает. По аналогии,

 Небезопасные варианты ответа, которые не распознаются CoAP-to-
 Прокси-сервер CoAP ДОЛЖЕН привести к ответу 5.02 (Плохой шлюз). Очередной раз,
 Опции Safe-to-Forward, которые не распознаются, ДОЛЖНЫ пересылаться.

 Дополнительные соображения по межпротокольному проксированию между CoAP
 и HTTP обсуждаются в разделе 10.

### 5.7.2. Форвард-прокси

 CoAP различает запросы, сделанные (как если бы) к исходному серверу
 и запросы, сделанные через прокси-сервер. CoAP запросы к
 forward-proxy выполняются как обычные Подтверждаемые или Неподтверждаемые
 запросы к конечной точке прямого прокси, но они указывают запрос
 URI по-другому: URI запроса в запросе прокси
 указывается как строка в опции Proxy-Uri (см. Раздел 5.10.2),
 в то время как URI запроса в запросе к исходному серверу разбивается на
 параметры Uri-Host, Uri-Port, Uri-Path и Uri-Query (см.
 Раздел 5.10.1). В качестве альтернативы URI в запросе прокси может быть
 собранный из варианта Proxy-Scheme и упомянутых вариантов разделения.

 Когда к конечной точке делается запрос прокси, и конечная точка
 не желая или неспособный действовать в качестве прокси для URI запроса, он ДОЛЖЕН
 вернуть ответ 5.05 (проксирование не поддерживается). Если власть
 (хост и порт) распознаются как идентифицирующие конечную точку прокси
 сам (см. Раздел 5.10.2), то запрос ДОЛЖЕН рассматриваться как
 локальный (не проксированный) запрос.

 Если прокси не настроен для пересылки запроса прокси другому
 прокси, он ДОЛЖЕН транслировать запрос следующим образом: схема
 URI запроса определяет исходящий протокол и его детали (например, CoAP
 используется через UDP для схемы «копы» и через DTLS для «копов»
 Схема.) Для прокси CoAP-to-CoAP IP-адрес исходного сервера
 и порт определяются авторитетным компонентом запроса
 URI, а URI запроса декодируется и разделяется на Uri-Host, Uri-
 Параметры порта, Uri-Path и Uri-Query. Это потребляет Proxy-Uri или
 Параметр Proxy-Scheme, который поэтому не пересылается источнику
 сервер.

### 5.7.3. Обратные прокси

 Обратные прокси не используют Proxy-Uri или Proxy-Scheme
 параметры, но необходимо определить пункт назначения (следующий переход) запроса
 из информации в запросе и информации в своих
 конфигурация. Например, обратный прокси-сервер может предлагать различные
 ресурсы, как если бы они были его собственными ресурсами, после того, как узнал о
 их существование через открытие ресурсов. Обратный прокси-сервер
 бесплатно, чтобы создать пространство имен для URI, которые идентифицируют эти ресурсы.
 Обратный прокси-сервер также может создавать пространство имен, которое дает клиенту больше  контроль того, куда идет запрос, например, с помощью встроенного хоста
 идентификаторы и номера портов в пути URI ресурсов
 предложил.

 При обработке ответа обратный прокси-сервер должен следить за тем, чтобы
 Значения опционов ETag из разных источников не смешиваются в одном
 ресурс, предлагаемый своим клиентам. Во многих случаях ETag может быть
 пересылается без изменений. Если отображение из ресурса, предлагаемого
 обратный прокси-сервер для ресурсов, предлагаемых его различными исходными серверами,
 не уникальна, обратному прокси-серверу может потребоваться сгенерировать новый ETag, что сделает
 убедитесь, что семантика этой опции правильно сохранена.

## 5.8. Определения методов

 В этом разделе каждый метод определяется вместе с его поведением. А
 запрос с нераспознанным или неподдерживаемым кодом метода ДОЛЖЕН генерировать
 совмещенный ответ 4.05 (метод запрещен).

### 5.8.1. GET

 Метод GET извлекает представление информации, которая
 в настоящее время соответствует ресурсу, указанному в URI запроса.
 Если запрос включает вариант принятия, это указывает на то, что
 предпочтительный контент-формат ответа. Если запрос включает
 Параметр ETag, метод GET запрашивает проверку ETag и
 представление будет передано только в том случае, если проверка не удалась. На
 Успешно, ДОЛЖЕН быть код ответа 2,05 (Содержание) или 2,03 (Действительный).
 присутствует в ответе.

 Метод GET безопасен и идемпотентен.

### 5.8.2. POST

 Метод POST запрашивает представление, заключенное в
 запрос будет обработан. Фактическая функция, выполняемая POST
 метод определяется исходным сервером и зависит от цели
 ресурс. Обычно это приводит к созданию нового ресурса или
 целевой ресурс обновляется.

 Если на сервере был создан ресурс, в ответ возвращается
 сервер ДОЛЖЕН иметь код ответа 2.01 (Создан) и ДОЛЖЕН
 включить URI нового ресурса в последовательность из одного или нескольких
 Параметры Location-Path и / или Location-Query (раздел 5.10.7). Если
 POST успешен, но не приводит к созданию нового ресурса на
 сервер, ответ ДОЛЖЕН иметь код ответа 2.04 (измененный).
 Если POST успешен и приводит к тому, что целевой ресурс
 удален, ответ ДОЛЖЕН иметь код ответа 2.02 (удален).
 POST не является ни безопасным, ни идемпотентным.

5.8.3. PUT

 Метод PUT запрашивает, чтобы ресурс, указанный в запросе
 URI должен быть обновлен или создан с вложенным представлением. В
 формат представления определяется типом носителя и содержанием
 кодирование, указанное в параметре Content-Format Option, если оно предусмотрено.

 Если ресурс существует в URI запроса, вложенное представление
 СЛЕДУЕТ рассматривать как модифицированную версию этого ресурса, а версию 2.04
 (Изменено) СЛЕДУЕТ возвращать код ответа. Если ресурса нет,
 тогда сервер МОЖЕТ создать новый ресурс с этим URI, что приведет к
 Код ответа 2.01 (создан). Если ресурс не удалось создать
 или изменен, то ДОЛЖЕН быть отправлен соответствующий код ответа об ошибке.

 Дополнительные ограничения на PUT могут быть наложены путем включения If-Match
 (см. Раздел 5.10.8.1) или If-None-Match (см. Раздел 5.10.8.2)
 варианты в запросе.

 PUT небезопасен, но идемпотентен.

### 5.8.4. DELETE

 Метод DELETE запрашивает ресурс, идентифицированный
 запросить удаление URI. Код ответа 2.02 (удален) ДОЛЖЕН быть
 используется в случае успеха или в случае, если ресурс не существовал до
 запрос.

 DELETE небезопасно, но идемпотентно.

## 5.9. Определения кода ответа

 Каждый код ответа описан ниже, включая все необходимые параметры.
 в ответ. При необходимости некоторые коды будут
 указано в отношении связанных кодов ответа в HTTP [RFC2616];
 это не означает, что любые такие отношения изменяют HTTP
 отображение, указанное в разделе 10.

### 5.9.1. Успех 2.xx

 Этот класс кода ответа указывает, что запрос клиента был
 успешно получен, понят и принят.

#### 5.9.1.1. 2.01 Создано

 Подобно HTTP 201 «Создано», но используется только в ответ на POST и PUT.
 Запросы. Полезная нагрузка, возвращенная с ответом, если таковая имеется, является
 представление результата действия.

 Если ответ включает один или несколько Location-Path и / или Location-
 Параметры запроса, значения этих параметров указывают местоположение в
 какой ресурс был создан. В противном случае ресурс был создан
 по запросу URI. Кэш, получающий этот ответ, ДОЛЖЕН пометить любые
 сохраненный ответ для созданного ресурса как несвежий.

 Этот ответ не кэшируется.

#### 5.9.1.2. 2.02 Удалено

 Этот код ответа похож на HTTP 204 «Нет содержимого», но используется только в
 ответ на запросы, из-за которых ресурс перестает быть
 доступны, например УДАЛИТЬ и, при определенных обстоятельствах, ПОЧТУ. В
 полезная нагрузка, возвращенная с ответом, если таковая имеется, является представлением
 результат действия.

 Этот ответ не кэшируется. Однако кеш ДОЛЖЕН отмечать любые
 сохраненный ответ для удаленного ресурса как несвежий.

#### 5.9.1.3. 2.03 Действительно

 Этот код ответа относится к HTTP 304 «Не изменено», но только
 используется, чтобы указать, что ответ, идентифицированный тегом объекта
 идентифицируется включенной опцией ETag. Соответственно,
 ответ ДОЛЖЕН включать параметр ETag и НЕ ДОЛЖЕН включать полезную нагрузку.

 Когда кеш, который распознает и обрабатывает опцию ответа ETag
 получает ответ 2.03 (действительный), он ДОЛЖЕН обновить сохраненный ответ
 со значением параметра Max-Age, включенным в ответ
 (явно или неявно как значение по умолчанию; см. также
 Раздел 5.6.2). Для каждого типа опции Safe-to-Forward, представленной в
 ответ, (возможно, пустой) набор опций этого типа,
 присутствующие в сохраненном ответе ДОЛЖНЫ быть заменены набором
 варианты этого типа в полученном ответе. (Небезопасные варианты могут
 запускать аналогичную обработку, зависящую от параметра, как определено параметром.

#### 5.9.1.4. 2.04 Изменено

 Этот код ответа похож на HTTP 204 «Нет содержимого», но используется только в
 ответ на запросы POST и PUT. Полезная нагрузка возвращается с
 ответ, если таковой имеется, является представлением результата действия.

 Этот ответ не кэшируется. Однако кеш ДОЛЖЕН отмечать любые
 сохраненный ответ для измененного ресурса как несвежий.

#### 5.9.1.5. 2.05 Содержание

 Этот код ответа похож на HTTP 200 «ОК», но используется только в ответ на
 GET запросы.

 Полезная нагрузка, возвращаемая с ответом, является представлением
 целевой ресурс.

 Этот ответ можно кэшировать: кеши могут использовать параметр Max-Age для
 определить свежесть (см. раздел 5.6.1) и (если есть) ETag
 Возможность проверки (см. Раздел 5.6.2).

### 5.9.2. Ошибка клиента 4.xx

 Этот класс кода ответа предназначен для случаев, когда клиент
 похоже, ошибся. Эти коды ответа применимы к любому
 метод запроса.

 Серверу СЛЕДУЕТ включать диагностические данные при условиях
 подробно описано в Разделе 5.5.2.

 Ответы этого класса кэшируются: кеши могут использовать Max-Age
 Возможность определения свежести (см. Раздел 5.6.1). Они не могут быть
 подтверждено.

#### 5.9.2.1. 4.00 неверный запрос

 Этот код ответа похож на HTTP 400 «Плохой запрос».

#### 5.9.2.2. 4.01 Несанкционированный

 Клиент не авторизован для выполнения запрошенного действия. В
 клиент НЕ ДОЛЖЕН повторять запрос без предварительного улучшения его
 статус аутентификации на сервере. Какой конкретный механизм может быть
 используется для этого, выходит за рамки этого документа; см. также Раздел 9.

#### 5.9.2.3. 4.02 Плохой вариант

 Запрос не может быть понят сервером из-за одного или нескольких
 нераспознанные или искаженные варианты. Клиенту НЕ СЛЕДУЕТ повторять
 запрос без изменений.

#### 5.9.2.4. 4.03 Запрещено

 Этот код ответа похож на HTTP 403 «Запрещено».

#### 5.9.2.5. 4.04 Не найдено

 Этот код ответа похож на HTTP 404 «Не найдено».

#### 5.9.2.6. 4.05 Метод запрещен

 Этот код ответа похож на HTTP 405 «Метод запрещен», но без
 параллельно с полем заголовка «Разрешить».

#### 5.9.2.7. 4.06 Неприемлемо

 Этот код ответа похож на HTTP 406 «Неприемлемо», но без
 объект ответа.

#### 5.9.2.8. 4.12 Ошибка предварительного условия

 Этот код ответа похож на HTTP 412 «Ошибка предварительного условия».

#### 5.9.2.9. 4.13 Слишком большой объект запроса

 Этот код ответа похож на HTTP 413 «Request Entity Too Large».

 Ответ ДОЛЖЕН включать параметр Size1 (раздел 5.10.9) для
 указать максимальный размер объекта запроса, который может сервер
 готов обработать, если сервер не в состоянии сделать
 эта информация доступна.

#### 5.9.2.10. 4.15 Неподдерживаемый формат содержимого

 Этот код ответа похож на HTTP 415 «Неподдерживаемый тип носителя».

### 5.9.3. Ошибка сервера 5.xx

 Этот класс кода ответа указывает на случаи, когда сервер
 знает, что допустил ошибку или не может выполнить запрос.
 Эти коды ответа применимы к любому методу запроса.

 Серверу СЛЕДУЕТ включать диагностические данные при условиях
 подробно описано в Разделе 5.5.2.

 Ответы этого класса кэшируются: кеши могут использовать Max-Age
 Возможность определения свежести (см. Раздел 5.6.1). Они не могут быть
 подтверждено.

#### 5.9.3.1. 5.00 Внутренняя ошибка сервера

 Этот код ответа похож на HTTP 500 «Внутренняя ошибка сервера».

#### 5.9.3.2. 5.01 Не реализовано

 Этот код ответа похож на HTTP 501 «Не реализовано».

#### 5.9.3.3. 5.02 Плохой шлюз

 Этот код ответа похож на HTTP 502 «Плохой шлюз».

#### 5.9.3.4. 5.03 Служба недоступна

 Этот код ответа похож на HTTP 503 «Служба недоступна», но использует
 параметр Max-Age вместо поля заголовка Retry-After, чтобы
 укажите количество секунд, по истечении которых следует повторить попытку.

#### 5.9.3.5. 5.04 Тайм-аут шлюза

 Этот код ответа похож на HTTP 504 «Тайм-аут шлюза».

#### 5.9.3.6. 5.05 Проксирование не поддерживается

 Сервер не может или не хочет действовать в качестве прокси-сервера для
 URI, указанный в опции Proxy-Uri или с помощью Proxy-Scheme (см.
 Раздел 5.10.2).

## 5.10. Определения опций

 Отдельные варианты CoAP приведены в таблице 4 и объяснены.
 в подразделах этого раздела.

 В этой таблице столбцы C, U и N указывают свойства
 Critical, UnSafe и NoCacheKey соответственно. Поскольку NoCacheKey
 имеет значение только для параметров, которые безопасны для пересылки (не отмечены
 Небезопасно), в столбце отображается прочерк, обозначающий небезопасные параметры.


    
       +-----+---+---+---+---+----------------+--------+--------+----------+
       | No. | C | U | N | R | Name           | Format | Length | Default  |
       +-----+---+---+---+---+----------------+--------+--------+----------+
       |   1 | x |   |   | x | If-Match       | opaque | 0-8    | (none)   |
       |   3 | x | x | - |   | Uri-Host       | string | 1-255  | (see     |
       |     |   |   |   |   |                |        |        | below)   |
       |   4 |   |   |   | x | ETag           | opaque | 1-8    | (none)   |
       |   5 | x |   |   |   | If-None-Match  | empty  | 0      | (none)   |
       |   7 | x | x | - |   | Uri-Port       | uint   | 0-2    | (see     |
       |     |   |   |   |   |                |        |        | below)   |
       |   8 |   |   |   | x | Location-Path  | string | 0-255  | (none)   |
       |  11 | x | x | - | x | Uri-Path       | string | 0-255  | (none)   |
       |  12 |   |   |   |   | Content-Format | uint   | 0-2    | (none)   |
       |  14 |   | x | - |   | Max-Age        | uint   | 0-4    | 60       |
       |  15 | x | x | - | x | Uri-Query      | string | 0-255  | (none)   |
       |  17 | x |   |   |   | Accept         | uint   | 0-2    | (none)   |
       |  20 |   |   |   | x | Location-Query | string | 0-255  | (none)   |
       |  35 | x | x | - |   | Proxy-Uri      | string | 1-1034 | (none)   |
       |  39 | x | x | - |   | Proxy-Scheme   | string | 1-255  | (none)   |
       |  60 |   |   | x |   | Size1          | uint   | 0-4    | (none)   |
       +-----+---+---+---+---+----------------+--------+--------+----------+
    
    C = критический, U = небезопасный, N = NoCacheKey, R = повторяемый
        
     Таблица 4: Опции

### 5.10.1. Uri-Host, Uri-Port, Uri-Path и Uri-Query

 Параметры Uri-Host, Uri-Port, Uri-Path и Uri-Query используются для
 укажите целевой ресурс запроса к исходному серверу CoAP.
 Параметры кодируют различные компоненты URI запроса в
 способ, которым не отображается процентное кодирование в значениях параметров и что
 полный URI может быть восстановлен на любой задействованной конечной точке. В
 синтаксис CoAP URI определен в Разделе 6.

 Шаги для разбора URI на параметры определены в Разделе 6.4.
 Эти шаги приводят к нулю или более Uri-Host, Uri-Port, Uri-Path и
 Параметры Uri-запроса, включенные в запрос, где каждый параметр
 содержит следующие значения:

* Параметр Uri-Host указывает Интернет-хост ресурса  запрашивается,
* Опция Uri-Port определяет номер порта транспортного уровня для  ресурс,
* каждая опция Uri-Path определяет один сегмент абсолютного пути к ресурс и
* каждая опция Uri-Query задает один аргумент, параметризующий  ресурс.

 Примечание. Фрагменты ([RFC3986], раздел 3.5) не являются частью запроса.
 URI и, следовательно, не будет передаваться в запросе CoAP.

 Значение по умолчанию для параметра Uri-Host - литерал IP.
 представляющий IP-адрес назначения сообщения запроса.
 Аналогичным образом, значение по умолчанию для параметра Uri-Port - это пункт назначения.
 Порт UDP. Значения по умолчанию для параметров Uri-Host и Uri-Port.
 достаточно для запросов к большинству серверов. Явный Uri-Host и
 Параметры Uri-Port обычно используются, когда на конечной точке размещается несколько
 виртуальные серверы.

 Uri-Path и Uri-Query Option могут содержать любую последовательность символов.
 Процентное кодирование не выполняется. Значение опции Uri-Path
 Не должно быть "." или ".." (поскольку URI запроса должен быть разрешен перед
 разбирая его на варианты).

 Шаги для создания URI запроса из опций:
 определено в разделе 6.5. Обратите внимание, что реализация не
 обязательно нужно построить URI; он может просто найти
 целевой ресурс, изучив отдельные варианты.

 Примеры можно найти в Приложении Б.

### 5.10.2. Proxy-Uri и Proxy-Scheme

 Параметр Proxy-Uri используется для отправки запроса к прокси-серверу.
 (см. раздел 5.7). Прямой прокси-сервер запрашивает пересылку
 запросить или обслужить его из допустимого кеша и вернуть ответ.

 Значение параметра - это абсолютный URI ([RFC3986], раздел 4.3).

 Обратите внимание, что прокси-сервер МОЖЕТ перенаправить запрос другому
 прокси или напрямую на сервер, указанный в absolute-URI. В
 чтобы избежать зацикливания запросов, прокси ДОЛЖЕН быть в состоянии распознавать все
 имен его серверов, включая любые псевдонимы, локальные варианты и
 числовые IP-адреса.

 Конечная точка, получающая запрос с опцией Proxy-Uri,
 не может или не желает действовать в качестве прокси-сервера для запроса ДОЛЖЕН
 вызывает возврат ответа 5.05 (проксирование не поддерживается).

 Параметр Proxy-Uri ДОЛЖЕН иметь приоритет над любым из Uri-Host,
 Параметры Uri-Port, Uri-Path или Uri-Query (каждый из которых НЕ ДОЛЖЕН быть
 включен в запрос, содержащий параметр Proxy-Uri).

 В качестве особого случая для упрощения многих прокси-клиентов, absolute-URI
 может быть сконструирован из опций Uri- *. Когда прокси-схема
 Опция присутствует, абсолютный URI строится следующим образом: CoAP
 URI состоит из опций Uri- *, как определено в Разделе 6.5.
 В результирующем URI исходная схема до, но не включая,
 следующее двоеточие затем заменяется содержимым прокси-сервера.
 Вариант схемы. Обратите внимание, что этот случай применим только в том случае, если
 компоненты желаемого URI, отличные от компонента схемы
 фактически может быть выражено с помощью параметров Uri- *; например, чтобы
 представляют URI с компонентом userinfo в полномочиях, только
 Можно использовать Proxy-Uri.

### 5.10.3. Content-Format

 Параметр Content-Format указывает формат представления
 полезная нагрузка сообщения. Формат представления дается как числовой
 Идентификатор Content-Format, который определен в «CoAP Content-
 Форматы »(раздел 12.3). При отсутствии опции нет
 предполагается значение по умолчанию, т. е. формат представления любого
 полезная нагрузка сообщения представления не определена (раздел 5.5).

### 5.10.4. Accept

 Параметр «Принять CoAP» можно использовать, чтобы указать, какой формат содержимого
 приемлемо для клиента. Формат представления задается как
 числовой идентификатор Content-Format, который определен в «CoAP
 Content-Formats "(раздел 12.3). Если нет опции" Принять ",
 учитывая, что клиент не выражает предпочтения (таким образом, нет значения по умолчанию
 значение предполагается). Клиент предпочитает представление, возвращаемое
 сервер должен быть в указанном Content-Format. Сервер возвращает
 предпочтительный Content-Format, если он доступен. Если предпочтительный контент-
 Формат не может быть возвращен, тогда ДОЛЖЕН быть отправлен 4.06 "Not Acceptable"
 в качестве ответа, если для этого не имеет значения другой код ошибки.
 отклик.

### 5.10.5. Max-Age

 Параметр Max-Age указывает максимальное время, в течение которого может быть получен ответ.
 кэшируется до того, как он будет считаться несвежим (см. Раздел 5.6.1).

 Значение параметра - это целое число секунд от 0 до
 2 ** 32-1 включительно (около 136,1 года). Значение по умолчанию 60 секунд.
 предполагается при отсутствии опции в ответе.

 Значение должно быть текущим на момент передачи.
 Серверы, которые предоставляют ресурсы со строгими допусками по стоимости
 Max-Age СЛЕДУЕТ обновлять значение перед каждой повторной передачей. (Видеть
 также Раздел 5.7.1.)

### 5.10.6. ETag

 Объект-тег предназначен для использования в качестве локального идентификатора ресурса для
 различать представления одного и того же ресурса, который
 меняются со временем. Он генерируется сервером, предоставляющим
 ресурс, который может генерировать его любым количеством способов, включая
 версия, контрольная сумма, хэш или время. Конечная точка, получающая объект-
 тег ДОЛЖЕН рассматривать его как непрозрачный и не делать никаких предположений о его содержании.
 или структура. (Конечные точки, которые генерируют тег объекта, приветствуются
 использовать максимально компактное представление, в частности в
 Относительно клиентов и посредников, которые могут захотеть хранить несколько
 Значения ETag.)

#### 5.10.6.1. ETag как вариант ответа

 Опция ETag в ответе предоставляет текущее значение (т. Е. После
 запрос был обработан) объекта-тега для "отмеченного
 представление ". Если параметры Location- * отсутствуют, помеченный
 представление - это выбранное представление (раздел 5.5.3)
 целевой ресурс. Если присутствует один или несколько вариантов Location- * и
 таким образом указывается URI местоположения (раздел 5.10.7), тегированный
 представление - это представление, которое будет получено GET
 запрос к URI местоположения.

 Вариант ответа ETag может быть включен в любой ответ, для которого
 есть помеченное представление (например, оно не будет иметь смысла в
 ответ 4.04 или 4.00). Опция ETag НЕ ДОЛЖНА встречаться более чем
 один раз в ответ.

 Для опции ETag нет значения по умолчанию; если его нет
 в ответ сервер не делает никаких заявлений о теге объекта для
 помеченное представление.

#### 5.10.6.2. ETag как вариант запроса

 В запросе GET конечная точка, имеющая одно или несколько представлений.
 ранее полученный с ресурса, и получил ответ ETag
 с ними, можно указать экземпляр опции ETag для
 один или несколько из этих сохраненных ответов.

 Сервер может выдать правильный ответ 2.03 (раздел 5.9.1.3) на месте
 ответа 2.05 Content, если один из заданных ETag является объектом -
 тег для текущего представления, т. е. действителен; 2.03 Valid
 response затем повторяет этот конкретный ETag в опции ответа.

 Фактически, клиент может определить, есть ли какие-либо из сохраненных
 представления актуальны (см. Раздел 5.6.2) без необходимости
 перенесите их снова.

 Опция ETag МОЖЕТ встречаться в запросе ноль, один или несколько раз.

### 5.10.7. Location-Path и Location-Query

 Параметры Location-Path и Location-Query вместе указывают на
 относительный URI, который состоит либо из абсолютного пути, либо из запроса
 строка или и то, и другое. Комбинация этих опций включена в
 2.01 (Создано) ответ для указания местоположения ресурса
 созданный в результате запроса POST (см. Раздел 5.8.2). В
 location разрешается относительно URI запроса.

 Если ответ с одним или несколькими Location-Path и / или Location-Query
 Параметры проходят через кеш, который интерпретирует эти параметры и
 подразумеваемый URI идентифицирует один или несколько текущих сохраненных ответов, те
 записи ДОЛЖНЫ быть отмечены как не свежие.

 Каждый параметр Location-Path указывает один сегмент абсолютного пути
 к ресурсу, и каждый параметр запроса местоположения указывает один
 аргумент, параметризующий ресурс. Местоположение-Путь и
 Параметр Location-Query Option может содержать любую последовательность символов. Нет
 процентное кодирование. Значение параметра Location-Path
 Не должно быть "." или же "..".

 Шаги для создания URI местоположения из опций:
 аналогично разделу 6.5, за исключением того, что первые пять шагов
 пропускается, и результатом является относительная ссылка на URI, которая затем
 интерпретируется относительно URI запроса. Обратите внимание, что относительный URI-
 ссылка, построенная таким образом, всегда включает абсолютный путь
 (например, исключая Location-Path, но предоставляя Location-Query, значит
 компонент пути в URI - "/").

 Параметры, которые используются для вычисления относительной ссылки URI:
 вместе называемые опциями Location- *. Помимо Location-Path и
 Location-Query, дополнительные параметры Location- * могут быть определены в будущем
 и были зарезервированы номера опций 128, 132, 136 и 140. Если есть
 из этих зарезервированных номеров опций встречается в дополнение к Location-Path
 и / или Location-Query и не поддерживаются, тогда 4.02 (плохой вариант)
 ошибка ДОЛЖНА быть возвращена.

### 5.10.8. Параметры условного запроса

 Параметры условного запроса позволяют клиенту запрашивать у сервера
 выполнять запрос только при определенных условиях, указанных в
 вариант отработаны.

 Для каждого из этих вариантов, если данное условие не выполняется,
 тогда сервер НЕ ДОЛЖЕН выполнять запрошенный метод. Вместо этого
 сервер ДОЛЖЕН ответить 4.12 (ошибка предварительного условия).
 Код.

 Если условие выполнено, сервер выполняет метод запроса
 как если бы параметры условного запроса отсутствовали.

 Если запрос без параметров условного запроса приведет к
 в любом другом коде ответа, кроме 2.xx или 4.12, затем любой
 параметры условного запроса МОГУТ игнорироваться.

#### 5.10.8.1. If-Match

 Опция If-Match МОЖЕТ использоваться, чтобы сделать запрос условным на
 текущее существование или значение ETag для одного или нескольких представлений
 целевого ресурса. Если-Match обычно полезен для ресурса
 запросы на обновление, такие как запросы PUT, как средство защиты
 от случайной перезаписи, когда несколько клиентов действуют в
 параллельно на том же ресурсе (то есть проблема «потерянного обновления»).

 Значение параметра If-Match - либо ETag, либо пустое поле.
 нить. Параметр If-Match с ETag соответствует представлению
 именно с этим ETag. Параметр If-Match с пустым значением соответствует
 любое существующее представление (т. е. ставит предварительное условие на
 наличие любого текущего представления для целевого ресурса).

 Параметр If-Match может использоваться несколько раз. Если любой из вариантов
 совпадение, то условие выполнено.

 Если есть один или несколько параметров If-Match, но ни один из вариантов
 совпадение, то условие не выполняется.

#### 5.10.8.2. If-None-Match

 Опция If-None-Match МОЖЕТ использоваться для того, чтобы сделать запрос условным
 несуществование целевого ресурса. If-None-Match полезно для
 запросы на создание ресурсов, такие как запросы PUT, как средство для
 защита от случайной перезаписи, когда несколько клиентов
 действуют параллельно на одном и том же ресурсе. Вариант If-None-Match
 не несет никакой ценности.

 Если целевой ресурс существует, то условие не
 выполнено.

 (Не очень полезно комбинировать параметры If-Match и If-None-Match
 в одном запросе, потому что тогда условие никогда не будет выполнено.)

### 5.10.9. Size1 Option

 Параметр Size1 предоставляет информацию о размере ресурса.
 представительство в запросе. Значение параметра - целое число.
 байтов. Его основное использование - поблочные переводы [BLOCK]. в
 в данной спецификации, он используется в ответах 4.13 (раздел 5.9.2.9)
 чтобы указать максимальный размер объекта запроса, который сервер
 способны и готовы справиться.

# 6. CoAP URI

 CoAP использует схемы URI "coap" и "coaps" для идентификации CoAP.
 ресурсы и предоставление средств поиска ресурса. Ресурсы
 организованы иерархически и управляются потенциальным источником CoAP
 сервер прослушивает запросы CoAP (coap) или CoAP, защищенный DTLS
 запросы («копы») на заданный порт UDP. Сервер CoAP
 идентифицируется через авторитетный компонент универсального синтаксиса, который
 включает компонент хоста и необязательный номер порта UDP. В
 остаток URI считается идентифицирующим ресурс, который
 может работать с методами, определенными протоколом CoAP. В
 Таким образом, схемы URI "coap" и "coaps" можно сравнить с http и
 Схемы URI https соответственно.

 Синтаксис схем URI "coap" и "coaps" указан в этом
 раздел в расширенной форме Бэкуса-Наура (ABNF) [RFC5234]. В
 определения "host", "port", "path-abempty", "query", "segment",
 "IP-литерал", "IPv4address" и "reg-name" взяты из
 [RFC3986].

 Примечание по реализации: к сожалению, со временем формат URI изменился.
  приобрела значительную сложность. Разработчикам рекомендуется
  внимательно изучите [RFC3986]. Например, ABNF для IPv6
  адреса сложнее, чем можно было ожидать. Также,
  разработчикам следует позаботиться о выполнении обработки
  процентное декодирование или процентное кодирование ровно один раз на пути от
  URI к его декодированным компонентам или обратно. Процентное кодирование
  имеет решающее значение для прозрачности данных, но может привести к необычным результатам, таким
  как косая черта в компоненте пути.

## 6.1. схема URI coap

 coap-URI = "coap:" "//" хост [":" порт] path-abempty ["?" запрос ]

 Если компонент хоста указан как IP-литерал или IPv4-адрес,
 тогда по этому IP-адресу можно будет связаться с сервером CoAP. Если хост - это
 зарегистрированное имя, то это имя считается косвенным идентификатором
 и конечная точка может использовать службу разрешения имен, например DNS, для
 найти адрес этого хоста. Хост НЕ ДОЛЖЕН быть пустым; если URI

 получен с отсутствующими полномочиями или с пустым хостом, тогда он ДОЛЖЕН
 считаться недействительным. Подкомпонент порта указывает порт UDP.
 на котором расположен сервер CoAP. Если он пуст или не указан,
 тогда предполагается порт по умолчанию 5683.

 Путь определяет ресурс в пределах хоста и порта.
 Он состоит из последовательности сегментов пути, разделенных косой чертой.
 символ (U + 002F SOLIDUS "/").

 Запрос служит для дальнейшей параметризации ресурса. Это состоит
 последовательности аргументов, разделенных символом амперсанда
 (U + 0026 АМПЕРСАНД "&"). Аргумент часто имеет форму
 пара "ключ = значение".

 Схема URI "coap" поддерживает префикс пути "/.well-known/"
 определено [RFC5785] для "хорошо известных местоположений" в пространстве имен
 хозяин. Это позволяет обнаруживать политику или другую информацию о
 хост («метаданные для всего сайта»), например размещенные ресурсы (см.
 Раздел 7).

 Разработчикам приложений рекомендуется использовать короткие, но
 описательные URI. Поскольку среды, в которых используется CoAP, являются
 обычно ограничены пропускной способностью и энергией, компромисс между
 эти два качества должны склоняться к краткости, без
 игнорирование информативности.

## 6.2. Coaps URI Scheme

 coaps-URI = "coaps:" "//" хост [":" порт] путь-abempty ["?" запрос ]

 Все вышеперечисленные требования для схемы «копилка» также
 требования к схеме "копы", за исключением того, что порт UDP по умолчанию
 из 5684 предполагается, если подкомпонент порта пуст или не задан,
 и дейтаграммы UDP ДОЛЖНЫ быть защищены с помощью DTLS в качестве
 описано в Разделе 9.1.

 Соображения по кешированию ответов на выявленные "копы"
 запросы обсуждаются в Разделе 11.2.

 Ресурсы, предоставляемые по схеме «копы», не имеют общих
 идентичность со схемой "coap", даже если их идентификаторы ресурсов
 указать тот же орган (тот же хост слушает один и тот же UDP
 порт). Это разные пространства имен и считаются
 разные серверы происхождения.

## 6.3. Правила нормализации и сравнения

 Поскольку схемы "coap" и "coaps" соответствуют универсальному URI
 синтаксис, такие URI нормализуются и сравниваются в соответствии с
 алгоритм, определенный в [RFC3986], раздел 6, с использованием значений по умолчанию
 описано выше для каждой схемы.

 Если порт равен порту по умолчанию для схемы, нормальный
 форма должна исключить подкомпонент порта. Точно так же пустой путь
 компонент эквивалентен абсолютному пути "/", поэтому нормальный
 форма должна вместо этого предоставить путь "/". Схема и хост
 без учета регистра и обычно вводятся в нижнем регистре; IP-литералы
 в рекомендованной форме [RFC5952]; все остальные компоненты сравниваются в
 чувствительный к регистру способ. Персонажи, отличные от указанных в "зарезервированных"
 set эквивалентны их байтам, закодированным в процентах (см. [RFC3986],
 Раздел 2.1): нормальная форма - не кодировать их.

 Например, следующие три URI эквивалентны и вызывают
 те же параметры и значения параметров, которые будут отображаться в сообщениях CoAP:

 coap: //example.com: 5683 / ~ сенсоры / temp.xml
 coap: //EXAMPLE.com/%7Esensors/temp.xml
 coap: //EXAMPLE.com: /%7esensors/temp.xml

## 6.4. Разложение URI на параметры

 Шаги по синтаксическому анализу параметров запроса из строки | url | как
 следует. Эти шаги приводят либо к нулю, либо к большему количеству Uri-Host,
 Параметры Uri-Port, Uri-Path и Uri-Query включены в
 запрос или они терпят неудачу.

 1. Если | url | строка не является абсолютным URI ([RFC3986]), тогда сбой
 этот алгоритм.

 2. Разрешите | url | строка с использованием процесса ссылки
 разрешение определяется [RFC3986]. На этом этапе URL находится в
 Кодирование ASCII [RFC0020], даже если декодированные компоненты будут
 интерпретироваться в UTF-8 [RFC3629] после шагов 5, 8 и 9.

   ПРИМЕЧАНИЕ: не имеет значения, относительно чего оно разрешено, поскольку мы
   уже знают, что на данный момент это абсолютный URL.

 3. Если | url | не имеет компонента <scheme>, значение которого, когда
 конвертируется в нижний регистр ASCII, принимает значение «coap» или «coaps», затем не выполняется
 этот алгоритм.

 4. Если | url | имеет компонент <fragment>, тогда этот алгоритм не пройдёт.

 5. Если компонент <host> в | url | не представляет собой запрос
 IP-адрес назначения как IP-литерал или IPv4-адрес, включая
 Параметр Uri-Host, и пусть значение этого параметра будет значением параметра
 <host> компонент | url |, преобразованный в нижний регистр ASCII, а затем
 преобразовать все процентные кодировки ("%", за которым следуют два шестнадцатеричных
 цифры) на соответствующие символы.

   ПРИМЕЧАНИЕ. В обычном случае, когда IP-адрес назначения запроса
   адрес получен из части хоста, это гарантирует, что Uri-
   Параметр хоста используется только для компонента <host> формы reg-
   название.

 6. Если | url | имеет компонент <port>, тогда пусть | порт | будь то
 значение компонента интерпретируется как десятичное целое число; иначе,
 пусть | порт | быть портом по умолчанию для схемы.

 7. Если | порт | не совпадает с UDP-портом назначения запроса,
 включите параметр Uri-Port, и пусть значение этого параметра будет | порт |.

 8. Если значение компонента <path> в | url | пусто или
 состоит из одного символа косой черты (U + 002F SOLIDUS "/"), затем
 перейти к следующему шагу.

   В противном случае для каждого сегмента в компоненте <path> включите
   Параметр Uri-Path и пусть значением этого параметра будет сегмент (не
   включая символы разделительной косой черты) после преобразования каждого
   процентное кодирование ("%", за которым следуют две шестнадцатеричные цифры) в
   соответствующий байт.

 9. Если | url | имеет компонент <query>, то для каждого аргумента в
 компонент <query>, включите параметр Uri-Query и позвольте этому
 значение параметра будет аргументом (не включая вопросительный знак
 и разделительные символы амперсанда) после преобразования каждого
 процентное кодирование в соответствующий байт.

 Обратите внимание, что эти правила полностью разрешают любое процентное кодирование.

## 6.5. Составление URI из опций

 Шаги по созданию URI из параметров запроса следующие.
 Эти шаги либо приводят к появлению URI, либо не работают. На этих этапах
 процентное кодирование символа означает замену каждого из его
 (В кодировке UTF-8) байты с символом "%", за которым следуют два шестнадцатеричных числа
 цифры, представляющие байт, где цифры AF в верхнем регистре
 (как определено в разделе 2.1 [RFC3986]; для уменьшения изменчивости
 шестнадцатеричное представление для процентного кодирования в URI CoAP ДОЛЖНО использовать
 заглавные буквы). Определения "без оговорок" и "разделенных границ"
 взяты из [RFC3986].

 1. Если запрос защищен с помощью DTLS, пусть | url | быть строкой
    «копы: //». В противном случае пусть | url | быть строкой «coap: //».

 2. Если запрос включает параметр Uri-Host, пусть | host | будь то
    значение параметра, где любые символы, отличные от ASCII, заменяются на
    их соответствующее процентное кодирование. Если | хост | не действительный
    reg-name, или IP-литерал, или IPv4address, алгоритм не работает. Если
    запрос не включает параметр Uri-Host, пусть | host | быть
    IP-литерал (с использованием соглашений [RFC5952]) или
    IPv4address, представляющий IP-адрес назначения запроса.

 3. Добавить | host | в | url |.

 4. Если запрос включает параметр Uri-Port, пусть | port | будь то
    стоимость опциона. В противном случае пусть | порт | быть просьбой
    порт назначения UDP.

 5. Если | порт | не является портом по умолчанию для схемы, тогда добавьте
    одиночный символ U + 003A COLON (:), за которым следует десятичная дробь
    представление | порт | на | url |.

 6. Пусть | имя ресурса | быть пустой строкой. Для каждого Uri-Path
    Вариант в запросе, добавить один символ U + 002F SOLIDUS
    (/), за которым следует значение параметра | имя ресурса |, после
    преобразование любого символа, который не находится ни в "незарезервированном"
    задайте в наборе "sub-delims" символ U + 003A COLON (:) или
    U + 0040 КОММЕРЧЕСКИЙ AT (@) в его форме, закодированной в процентах.

 7. Если | имя ресурса | - это пустая строка, установите для нее одиночный
    символ U + 002F SOLIDUS (/).

 8. Для каждого параметра Uri-Query в запросе добавьте один
    символ U + 003F ВОПРОСНЫЙ ЗНАК (?) (первый вариант) или U + 0026
    АМПЕРСАНД (&) (последующие параметры), за которым следует вариант
    значение | имя ресурса | после преобразования любого символа
    нет ни в "незарезервированном" наборе, ни в "подразграничивающем" наборе
    (кроме U + 0026 AMPERSAND (&)), U + 003A COLON (:), U + 0040
    КОММЕРЧЕСКИЙ НАД (@), U + 002F SOLIDUS (/) или U + 003F ВОПРОС
    MARK (?) В его процентную форму.

 9. Добавьте | имя ресурса | в | url |.

 10. Вернуть | url |.

 Обратите внимание, что эти шаги были разработаны, чтобы привести к URI в обычном
 форму (см. раздел 6.3).



# 7. Открытие

## 7.1. Обнаружение услуг

 В рамках обнаружения услуг, предлагаемых сервером CoAP,
 клиент должен узнать о конечной точке, используемой сервером.

 Сервер обнаруживается клиентом (знающим или) изучающим URI, который
 ссылается на ресурс в пространстве имен сервера. В качестве альтернативы,
 клиенты могут использовать многоадресный CoAP (см. Раздел 8) и «Все CoAP».
 Многоадресный адрес узлов для поиска серверов CoAP.

 Если только подкомпонент порта в URI «coap» или «coaps» не указывает
 Порт UDP, на котором расположен сервер CoAP, предполагается, что сервер
 чтобы быть доступным через порт по умолчанию.

 Номер порта по умолчанию 5683 CoAP ДОЛЖЕН поддерживаться сервером, который
 предлагает ресурсы для обнаружения ресурсов (см. раздел 7.2 ниже) и
 ДОЛЖЕН поддерживаться для обеспечения доступа к другим ресурсам. В
 номер порта по умолчанию 5684 для защищенного DTLS CoAP МОЖЕТ поддерживаться
 сервер для обнаружения ресурсов и для предоставления доступа к другим
 Ресурсы. Кроме того, другие конечные точки могут размещаться в других
 порты, например, в динамическом пространстве портов.

 Примечание по реализации: когда сервер CoAP размещен на узле 6LoWPAN,
  эффективность сжатия заголовка повышается, если он также поддерживает
  номер порта в сжатом пространстве портов UDP 61616-61631, определенном
  в [RFC4944] и [RFC6282]. (Обратите внимание, что, поскольку его порт UDP отличается
  от порта по умолчанию, это другая конечная точка, чем сервер
  на порт по умолчанию.)

## 7.2. Обнаружение ресурсов

 Обнаружение ресурсов, предлагаемых конечной точкой CoAP, чрезвычайно
 важно в приложениях "машина-машина", где нет
 люди в цикле и статические интерфейсы приводят к хрупкости. К
 максимизировать взаимодействие в среде CoRE, конечной точке CoAP
 ДОЛЖЕН поддерживать формат CoRE Link для обнаруживаемых ресурсов как
 описано в [RFC6690], за исключением случаев, когда полностью ручная настройка
 желанный. Какие ресурсы делаются, зависит от сервера.
 обнаруживаемый (если есть).

### 7.2.1. Атрибут ct

 В этом разделе определяется новый атрибут Web Linking [RFC5988] для использования
 с [RFC6690]. Атрибут "ct" кода формата содержимого обеспечивает
 намек на форматы содержимого, возвращаемые этим ресурсом. Обратите внимание, что это
 является лишь подсказкой и не отменяет опцию Content-Format для

 ответ CoAP, полученный путем фактического запроса представления
 ресурс. Значение находится в формате кода идентификатора CoAP как
 десятичное целое число ASCII и ДОЛЖНО быть в диапазоне 0-65535 (16-битное
 беззнаковое целое). Например, будет указано «приложение / xml».
 как «ct = 41». Если атрибут кода Content-Format отсутствует, тогда
 ничего нельзя предположить о типе. Код Content-Format
 атрибут МОЖЕТ включать разделенную пробелами последовательность Content-Format
 коды, указывающие на то, что доступно несколько форматов содержимого. В
 синтаксис значения атрибута резюмируется в продукте "ct-
 значение »на рисунке 12, где определены« кардинал »,« SP »и« DQUOTE ».
 как в [RFC6690].

  ct-value = кардинал
/ DQUOTE cardinal * (1 * SP cardinal) DQUOTE

 Рисунок 12.

# 8. Многоадресный CoAP

 CoAP поддерживает отправку запросов в группу многоадресной IP-рассылки. Это
 определяется серией дельт для одноадресной передачи CoAP. Более общий
 обсуждение группового общения с CoAP находится в [GROUPCOMM].

 Конечные точки CoAP, которые предлагают услуги, которые они хотят, чтобы другие конечные точки
 быть в состоянии найти, используя обнаружение многоадресной службы, присоединиться к одному или нескольким из
 соответствующие многоадресные адреса для всех узлов CoAP (раздел 12.8) и
 прослушивать порт CoAP по умолчанию. Обратите внимание, что конечная точка может получать
 многоадресные запросы на другие многоадресные адреса, включая все
 IPv6-адрес узлов (или через широковещательную рассылку по IPv4); конечная точка ДОЛЖНА
 поэтому будьте готовы к получению таких сообщений, но МОЖЕТ игнорировать их, если
 Обнаружение многоадресной службы нежелательно.

## 8.1. Уровень обмена сообщениями

 Многоадресный запрос характеризуется тем, что он транспортируется в CoAP сообщение, адресованное на многоадресный IP-адрес вместо конечной точки CoAP. Такие многоадресные запросы ДОЛЖНЫ быть неподтвержденными.

 Серверу СЛЕДУЕТ знать, что запрос пришел через многоадресную рассылку, например,
 с использованием современных API, таких как IPV6_RECVPKTINFO [RFC3542], если
 имеется в наличии.

 Чтобы избежать резкого увеличения количества ответов об ошибках, когда сервер знает, что
 запрос, полученный через многоадресную рассылку, НЕ ДОЛЖЕН возвращать сообщение сброса
 в ответ на неподтвержденное сообщение. Если он не знает, он МОЖЕТ
 вернуть сообщение сброса в ответ на неподтвержденное сообщение как
 обычный. Поскольку такое сообщение сброса будет выглядеть идентично сообщению для

 одноадресное сообщение от отправителя, отправитель ДОЛЖЕН избегать использования
 Идентификатор сообщения, который также все еще активен с этой конечной точки с любым
 конечная точка одноадресной рассылки, которая может получить многоадресное сообщение.

 На момент написания многоадресные сообщения могут передаваться только в UDP.
 не в DTLS. Это означает, что режимы безопасности, определенные для CoAP в
 этот документ не применим к многоадресной рассылке.

## 8.2. Уровень запроса / ответа

 Когда сервер знает, что запрос прибыл через многоадресную рассылку,  сервер МОЖЕТ всегда игнорировать запрос, особенно если у него нет  ничего полезного для ответа (например, если у него есть только пустой
 полезная нагрузка или ответ об ошибке). Решение об этом может зависеть от  приложения. (Например, при фильтрации запросов, как описано в
 [RFC6690], сервер не должен отвечать на многоадресный запрос, если
 фильтр не соответствует. Больше примеров можно найти в [GROUPCOMM].)

 Если сервер все же решает ответить на многоадресный запрос, он должен
 не отвечать сразу. Вместо этого следует выбрать продолжительность 
 период времени, в течение которого он намеревается ответить. Для целей
 Продолжительность этой экспозиции мы называем Досугом.
 Конкретная стоимость этого досуга может зависеть от приложения или
 МОЖЕТ быть получено, как описано ниже. Затем серверу СЛЕДУЕТ выбрать
 случайный момент времени в пределах выбранного периода досуга для отправки
 одноадресный ответ на многоадресный запрос. Если дальнейшие ответы
 должны быть отправлены на основе того же членства в многоадресном адресе, новый
 период досуга начинается не раньше предыдущего
 отделка.

 Чтобы вычислить значение Leisure, на сервере должен быть указан размер группы.
 оценка G, целевая скорость передачи данных R (которая должна быть
 выбран консервативно) и предполагаемый размер ответа S; грубый
 нижняя граница для досуга тогда может быть вычислена как

lb_Leisure = S * G / R

Например, для многоадресного запроса с локальной областью канала в сети 2,4 ГГц IEEE 802.15.4 (6LoWPAN) G может быть (относительно консервативно) установлено на 100, S на 100 байтов, а целевая скорость на 8 кбит / с. = 1 кБ / с. В результате нижняя граница для Leisure составляет 10 секунд.

Если конечная точка CoAP не имеет подходящих данных для вычисления значения Leisure, она МОЖЕТ прибегнуть к DEFAULT_LEISURE.


При сопоставлении ответа на многоадресный запрос ДОЛЖЕН совпадать только токен; исходная конечная точка ответа не обязательно должна (и не будет) совпадать с конечной точкой назначения исходного запроса.

В целях интерпретации параметров Location- * и любых ссылок, встроенных в представление, URI запроса (т. Е. Базовый URI, относительно которого интерпретируется ответ) формируется путем замены адреса многоадресной рассылки в компоненте Host исходного запроса. URI по буквальному IP-адресу конечной точки, которая действительно отвечает.

### 8.2.1. Кеширование

 Когда клиент делает многоадресный запрос, он всегда делает новый
 запрос к многоадресной группе (так как могут быть новые участники группы
 присоединившиеся тем временем или не получившие предыдущий запрос).
 Он МОЖЕТ обновлять кеш полученными ответами. Затем он использует
 как кэшированные, еще свежие, так и новые ответы в результате
 запрос.

 Ответ, полученный в ответ на запрос GET в группу многоадресной рассылки.
 МОЖЕТ использоваться для удовлетворения последующего запроса на соответствующую одноадресную рассылку.
 запросить URI. URI одноадресного запроса получается путем замены
 авторитетная часть URI запроса с источником транспортного уровня
 адрес ответного сообщения.

 Кэш МОЖЕТ подтвердить ответ, сделав запрос GET на
 связанный URI одноадресного запроса.

 Запрос GET к группе многоадресной рассылки НЕ ДОЛЖЕН содержать опцию ETag.
 Механизм подавления ответов, которые уже есть у клиента, оставлен для
 дальнейшее изучение.

### 8.2.2. Прокси

 Когда форвард-прокси получает запрос с Proxy-Uri или URI
 построенный из Proxy-Scheme, который указывает адрес многоадресной рассылки,
 прокси получает набор ответов, как описано выше, и отправляет все
 ответы (как кэшированные-все-еще-свежие, так и новые) обратно на исходные
 клиент.

 Эта спецификация не предоставляет способа указать одноадресный
 измененный URI запроса (базовый URI) в перенаправленных ответах.
 Более подробно проксирование многоадресных запросов обсуждается в
 [GROUPCOMM]; можно найти одно предложение по решению проблемы с базовым URI
 в Разделе 3 [CoAP-MISC].

# 9. Обеспечение CoAP

 В этом разделе определяется привязка DTLS для CoAP.

 На этапе инициализации устройству CoAP предоставляется
 информация о безопасности, которая ему нужна, включая материалы для ключей и
 списки контроля доступа. Эта спецификация определяет обеспечение для
 режим RawPublicKey в Разделе 9.1.3.2.1. В конце
 на этапе подготовки, устройство будет в одном из четырех режимов безопасности.
 со следующей информацией для данного режима. NoSec и
 Режимы RawPublicKey являются обязательными для реализации для этой спецификации.

 **NoSec**: безопасность на уровне протокола отсутствует (DTLS отключен).
  СЛЕДУЕТ использовать альтернативные методы обеспечения безопасности нижнего уровня.
  используется при необходимости. Использование IPsec обсуждается в
  [IPsec-CoAP]. Определенные уровни ссылок, используемые с ограниченными узлами
  также обеспечивают безопасность на канальном уровне, что может быть уместно с
  правильное управление ключами.

 **PreSharedKey**: DTLS включен, есть список pre-shared ключей
  [RFC4279], и каждый ключ включает список узлов, которые могут быть
  используется для связи, как описано в Разделе 9.1.3.1. На
  крайний, может быть один ключ для каждого узла, который нужен этому узлу CoAP
  для связи (соотношение узел / ключ 1: 1). И наоборот, если больше
  чем два объекта совместно используют определенный предварительный общий ключ, только этот ключ
  позволяет объектам аутентифицироваться как член этой группы и
  не как конкретный партнер.

 **RawPublicKey**: DTLS включен, и устройство имеет асимметричный ключ.
  пара без сертификата (необработанный открытый ключ), который проверен
  с использованием внеполосного механизма [RFC7250], как описано в
  Раздел 9.1.3.2. Устройство также имеет идентификатор, рассчитанный из
  открытый ключ и список идентификаторов узлов, которые он может
  общаться с.

 **Certificate**: DTLS включен и устройство имеет асимметричный ключ
  пара с сертификатом X.509 [RFC5280], который связывает его с его
  субъект и подписан некоторым общим доверительным корнем, как описано в
  Раздел 9.1.3.3. В устройстве также есть список корневых якорей доверия.
  который можно использовать для проверки сертификата.

 В режиме "NoSec" система просто отправляет пакеты через нормальный
 UDP через IP и указывается схемой «coap» и CoAP
 порт по умолчанию. Система защищена только путем удержания злоумышленников от
 возможность отправлять или получать пакеты из сети с помощью CoAP
 узлы; см. Раздел 11.5 для дополнительной информации об этом
 подход.

 Остальные три режима безопасности достигаются с помощью DTLS и являются
 обозначается схемой «coaps» и защищенным DTLS портом CoAP по умолчанию.
 Результатом является ассоциация безопасности, которую можно использовать для аутентификации.
 (в рамках модели безопасности) и, исходя из этого
 аутентификации, авторизуйте коммуникационного партнера. Сам CoAP
 не предоставляет примитивов протокола для аутентификации или
 авторизация; там, где это требуется, он может быть предоставлен
 безопасность связи (например, IPsec или DTLS) или безопасность объекта
 (в пределах полезной нагрузки). Устройства, требующие авторизации наверняка
 ожидается, что для операций потребуется одна из этих двух форм
 безопасность. Обязательно, если задействован посредник,
 безопасность связи работает только тогда, когда этот посредник является частью
 доверительные отношения. CoAP не дает возможности продвигать
 различные уровни авторизации, которые клиенты могут иметь с
 посредник для дальнейших посредников или исходных серверов - это
 поэтому может потребоваться выполнить всю авторизацию при первом
 посредник.

## 9.1. CoAP с защитой DTLS

 Так же, как HTTP защищен с помощью Transport Layer Security (TLS) поверх
 TCP, CoAP защищен с помощью дейтаграммы TLS (DTLS) [RFC6347] через UDP.
 (см. рисунок 13). В этом разделе определяется привязка CoAP к DTLS,
 наряду с минимальными обязательными для реализации конфигурациями
 подходит для стесненных условий. Привязка определяется
 серия дельт для одноадресной передачи CoAP. На практике DTLS - это TLS с
 добавлены функции для борьбы с ненадежной природой UDP
 транспорт.

| Приложение |
| ------------------ |

| Запросы / ответы |
| ---------------------- | CoAP
| Сообщения |
| ---------------------- |

| DTLS |
| ---------------------- |

| UDP |
| ---------------------- |

Рисунок 13: Абстрактное многоуровневое распределение CoAP, защищенного DTLS

 В некоторых узлах с ограничениями (ограниченная флэш-память и / или ОЗУ) и сетях
 (ограниченная пропускная способность или высокие требования к масштабируемости) и в зависимости от
 на конкретных используемых наборах шифров все режимы DTLS не могут быть
 применимый. Некоторые комплекты шифров DTLS могут значительно добавить
 сложность реализации, а также некоторые начальные накладные расходы на рукопожатие
 необходимо при настройке сопоставления безопасности. После первоначального
 рукопожатие завершено, DTLS добавляет ограниченные накладные расходы на дейтаграмму в размере
 примерно 13 байт, не считая векторов инициализации /
 одноразовые номера (например, 8 байтов с TLS_PSK_WITH_AES_128_CCM_8 [RFC6655]),
 значения проверки целостности (например, 8 байтов с TLS_PSK_WITH_AES_128_CCM_8
 [RFC6655]) и заполнение, требуемое набором шифров. Будь то
 использование данного режима DTLS применимо для CoAP на основе
 приложение следует тщательно взвесить с учетом специфики
 комплекты шифров, которые могут быть применимы, независимо от того, поддерживает ли сеанс
 делает его совместимым с потоками приложений, и достаточно ли
 ресурсы доступны на ограниченных узлах и для добавленных
 накладные расходы сети. (Для некоторых режимов использования DTLS эта спецификация
 определяет обязательный для реализации набор шифров. Это
 требование реализации для максимальной совместимости в тех
 случаи, когда эти наборы шифров действительно подходят. Конкретные
 политики безопасности приложения могут определять фактический набор
 наборы шифров, которые можно использовать.) DTLS не применяется к группе
 keying (многоадресная связь); однако это может быть компонент в
 будущий протокол управления ключами группы.

### 9.1.1. Уровень обмена сообщениями

 Конечная точка, действующая как клиент CoAP, также должна действовать как DTLS.
 клиент. Он должен инициировать сеанс с сервером на
 соответствующий порт. Когда рукопожатие DTLS завершено, клиент
 может инициировать первый запрос CoAP. Все сообщения CoAP ДОЛЖНЫ быть отправлены
 как "данные приложения" DTLS.

 Следующие правила добавлены для сопоставления сообщения подтверждения.
 или Сбросить сообщение на Подтверждаемое сообщение, или Сбросить сообщение на
 Неподтверждаемое сообщение: сеанс DTLS ДОЛЖЕН быть таким же, и
 эпоха ДОЛЖНА быть такой же.

 Сообщение такое же, когда оно отправляется в рамках одного сеанса DTLS.
 и той же эпохи и имеет тот же идентификатор сообщения.

 Примечание. При повторной передаче подтверждаемого сообщения новый DTLS
 sequence_number используется для каждой попытки, даже если CoAP
 Идентификатор сообщения остается прежним. Таким образом, получатель все еще должен выполнить
 дедупликация, как описано в разделе 4.5. Повторная передача НЕ ДОЛЖНА
 исполняться через эпохи.

 Установлены DTLS-соединения в режимах RawPublicKey и Certificate.
 используя взаимную аутентификацию, чтобы они могли оставаться включенными и повторно использоваться для
 будущий обмен сообщениями в любом направлении. Устройства могут закрыть
 Соединение DTLS, когда им нужно восстановить ресурсы, но в целом
 они должны поддерживать связь как можно дольше. Закрытие
 соединение DTLS после каждого обмена сообщениями CoAP очень
 неэффективно.

### 9.1.2. Уровень запроса / ответа

 Для сопоставления ответа на запрос добавлены следующие правила:
 Сеанс DTLS ДОЛЖЕН быть таким же, и эпоха ДОЛЖНА быть такой же.

 Это означает, что ответ на защищенный запрос DTLS всегда ДОЛЖЕН быть DTLS.
 защищены с помощью одного сеанса безопасности и эпохи. Любая попытка
 предоставить ответ NoSec на запрос DTLS просто не соответствует
 запрос и поэтому ДОЛЖЕН быть отклонен (если он не соответствует
 несвязанный запрос NoSec).

### 9.1.3. Идентификация конечной точки

 Устройства ДОЛЖНЫ поддерживать указание имени сервера (SNI) для указания
 их полномочия в поле SNI HostName, как определено в Разделе 3
 [RFC6066]. Это необходимо для того, чтобы, когда хост, действующий как виртуальный
 сервер для нескольких Властей получает новое соединение DTLS, он
 знает, какие ключи использовать для сеанса DTLS.

#### 9.1.3.1. Предварительно общие ключи

 При формировании подключения к новому узлу система выбирает
 соответствующий ключ в зависимости от того, какие узлы он пытается достичь, а затем
 формирует сеанс DTLS с использованием режима PSK (Pre-Shared Key) DTLS.
 Реализации в этих режимах ДОЛЖНЫ поддерживать обязательный
 реализовать набор шифров TLS_PSK_WITH_AES_128_CCM_8, как указано в
 [RFC6655].

 В зависимости от модели ввода в эксплуатацию приложениям может потребоваться определение
 профиль приложения для подсказок личности (по мере необходимости и подробно
 в разделе 5.2 [RFC4279]), чтобы разрешить использование подсказок идентичности PSK.

 Применяются соображения безопасности раздела 7 [RFC4279]. В
 в частности, приложения должны тщательно взвешивать, действительно ли они
 требуется Perfect Forward Secrecy (PFS) и выберите подходящий шифр
 Suite (раздел 7.1 [RFC4279]). Энтропия PSK должна быть
 достаточно для защиты от перебора и (где PSK не
 выбранных случайно, но человеком) атаки по словарю (раздел 7.2
 [RFC4279]). Передача данных о клиентах в открытом виде может
 утечка данных или нарушение конфиденциальности ( раздел 7.3 [RFC4279]).

#### 9.1.3.2. Сертификаты необработанных открытых ключей

 В этом режиме устройство имеет асимметричную пару ключей, но без
 Сертификат X.509 (называемый необработанным открытым ключом); например,
 асимметричная пара ключей генерируется производителем и устанавливается на
 устройство (см. также Раздел 11.6). Устройство МОЖЕТ быть настроено с
 несколько необработанных открытых ключей. Тип и длина необработанного открытого ключа.
 зависит от используемого набора шифров. Реализации в RawPublicKey
 режим ДОЛЖЕН поддерживать обязательный для реализации набор шифров
 TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8, как указано в [RFC7251],
 [RFC5246] и [RFC4492]. Используемый ключ ДОЛЖЕН быть совместим с ECDSA. В
 Кривая secp256r1 ДОЛЖНА поддерживаться [RFC4492]; эта кривая эквивалентна
 кривой NIST P-256. Алгоритм хеширования - SHA-256.
 Реализации ДОЛЖНЫ использовать поддерживаемые эллиптические кривые и поддерживаемые
 Расширения форматов точек [RFC4492]; несжатый формат точки
 ДОЛЖЕН поддерживаться; [RFC6090] может использоваться как метод реализации.
 Некоторые рекомендации, относящиеся к реализации этого набора шифров, могут
 можно найти в [W3CXMLSEC]. Механизм использования сырых открытых ключей
 с TLS указан в [RFC7250].

 Примечание по реализации: в частности, это означает, что перечисленные расширения
  на рисунке 14, по крайней мере, перечисленные значения будут присутствовать в
  рукопожатие DTLS.

 Расширение: elliptic_curves
  Тип: elliptic_curves (0x000a)
  Длина: 4
  Длина эллиптических кривых: 2
  Эллиптические кривые (1 кривая)
  Эллиптическая кривая: secp256r1 (0x0017)

 Расширение: ec_point_formats
  Тип: ec_point_formats (0x000b)
  Длина: 2
  Форматы точек EC Длина: 1
  Форматы точек эллиптических кривых (1)
  Формат точки EC: несжатый (0)

 Расширение: signature_algorithms
  Тип: signature_algorithms (0x000d)
  Длина: 4
  Данные (4 байта): 00 02 04 03
  Хеш-алгоритм: sha256 (4)
  ПодписьАлгоритм: ecdsa (3)

 Рисунок 14: Расширения DTLS, представленные для
   TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8



##### 9.1.3.2.1. Подготовка

 Режим RawPublicKey был разработан таким образом, чтобы его можно было легко настроить в M2M.
 развертывания. Предполагается, что каждое устройство имеет соответствующий
 установлена асимметричная пара открытых ключей. Идентификатор рассчитывается
 конечная точка из открытого ключа, как описано в Разделе 2
 [RFC6920]. Все реализации, поддерживающие проверку RawPublicKey
 идентификаторы ДОЛЖНЫ поддерживать как минимум режим sha-256-120 (SHA-256
 усечено до 120 бит). Реализации также ДОЛЖНЫ поддерживать более длительную
 идентификаторы длины и МОГУТ поддерживать более короткие длины. Обратите внимание, что
 меньшая длина обеспечивает меньшую защиту от атак, и их использование
 НЕ РЕКОМЕНДУЕТСЯ.

 В зависимости от того, как идентификаторы присваиваются системе, проверяющей
 их, поддержка URI, двоичного и / или человеческого формата
 [RFC6920] должен быть реализован. Все реализации ДОЛЖНЫ
 поддерживают двоичный режим и реализации, в которых есть пользователь
 interface ДОЛЖЕН также поддерживать формат, понятный человеку.

 Во время подготовки идентификатор каждого узла собирается для
 например, считывая штрих-код на внешней стороне устройства или
 получение заранее составленного списка идентификаторов. Эти идентификаторы
 затем устанавливаются в соответствующей конечной точке, например, M2M
 сервер сбора данных. Идентификатор используется для двух целей:
 связать конечную точку с дополнительной информацией об устройстве и выполнить
 контроль доступа. Во время (начальной и текущей) подготовки доступ
 контрольный список идентификаторов, с которыми устройство может запускать DTLS
 СЛЕДУЕТ также устанавливать и поддерживать сеансы.

#### 9.1.3.3. Сертификаты X.509

 Реализации в режиме сертификата ДОЛЖНЫ поддерживать обязательную
 реализовать набор шифров TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 как
 указаны в [RFC7251], [RFC5246] и [RFC4492]. А именно
 сертификат включает SubjectPublicKeyInfo, который указывает
 алгоритм id-ecPublicKey с namedCurves secp256r1 [RFC5480]; в
 формат открытого ключа не сжат [RFC5480]; алгоритм хеширования
 SHA-256; если включено, расширение использования ключа указывает
 цифровая подпись. Сертификаты ДОЛЖНЫ быть подписаны ECDSA с использованием
 secp256r1, и подпись ДОЛЖНА использовать SHA-256. Используемый ключ ДОЛЖЕН быть
 ECDSA поддерживает. Кривая secp256r1 ДОЛЖНА поддерживаться [RFC4492]; это
 Кривая эквивалентна кривой NIST P-256. Алгоритм хеширования
 SHA-256. Реализации ДОЛЖНЫ использовать поддерживаемые эллиптические кривые и
 Поддерживаемые расширения форматов точек [RFC4492]; несжатая точка
 формат ДОЛЖЕН поддерживаться; [RFC6090] можно использовать как реализацию
 метод.

 Предмет в сертификате будет построен на долгосрочном
 уникальный идентификатор устройства, например EUI-64 [EUI64]. В
 субъект также может быть основан на полном доменном имени (FQDN)
 который использовался как часть Host URI CoAP. Тем не менее
 IP-адрес устройства обычно не должен использоваться в качестве темы, поскольку
 со временем это изменится. Процесс обнаружения, используемый в системе
 построит сопоставление между IP-адресами данных устройств
 и тема для каждого устройства. На некоторых устройствах может быть больше
 один предмет и потребуется более одного сертификата.

 При формировании нового подключения сертификат с удаленного
 устройство требует верификации. Если узел CoAP имеет источник
 абсолютное время, тогда узел ДОЛЖЕН проверить, что даты действия
 сертификат находятся в пределах допустимого диапазона. Сертификат ДОЛЖЕН быть подтвержден.
 в соответствии с требованиями безопасности, используя функциональность
 эквивалентен алгоритму, указанному в разделе 6 [RFC5280]. Если
 сертификат содержит SubjectAltName, затем полномочия
 URI запроса ДОЛЖЕН соответствовать хотя бы одному из полномочий любого CoAP
 URI найден в поле типа URI в наборе SubjectAltName. Если здесь
 не указано в сертификате SubjectAltName, то авторитет
 URI запроса ДОЛЖЕН совпадать с общим именем (CN), найденным в сертификате.
 используя правила сопоставления, определенные в [RFC3280], за исключением того, что
 сертификаты с подстановочными знаками не допускаются.

 Поддержка CoRE для проверки статуса сертификата требует дальнейшего изучения.
 Как отображение протокола статуса онлайн-сертификата (OCSP)
 [RFC6960] на CoAP в настоящее время не определен, и OCSP также не может быть
 легко применим во всех средах, альтернативный подход может быть
 с помощью расширения запроса статуса сертификата TLS (раздел 8
 [RFC6066]; также известный как «сшивание OCSP») или, предпочтительно, множественное
 Расширение статуса сертификата ([RFC6961]), если доступно.

 Если в системе есть общий ключ в дополнение к сертификату, то
 набор шифров, который включает общий ключ, такой как
 СЛЕДУЕТ использовать TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA [RFC5489].

10. # Межпротокольное проксирование между CoAP и HTTP

 CoAP поддерживает ограниченный набор функций HTTP и, следовательно, перекрестно
 проксирование протокола на HTTP очень просто. Может быть несколько
 причины для проксирования между CoAP и HTTP, например, когда
 разработка веб-интерфейса для использования по протоколу или когда
 реализация прокси CoAP-HTTP. Точно так же CoAP может быть прокси-сервером.
 с другими протоколами, такими как XMPP [RFC6120] или SIP [RFC3264]; в
 определение этих механизмов выходит за рамки данного
 Технические характеристики.



 Есть два возможных направления доступа к ресурсу через переадресацию.
 прокси:

 CoAP-HTTP Proxying: позволяет клиентам CoAP получать доступ к ресурсам по HTTP.
  серверы через посредника. Это инициируется включением
  Proxy-Uri или Proxy-Scheme Option с URI http или https
  в запросе CoAP к прокси-серверу CoAP-HTTP.

 HTTP-CoAP Proxying: позволяет HTTP-клиентам получать доступ к ресурсам на CoAP.
  серверы через посредника. Это инициируется указанием
  URI "coap" или "coaps" в строке запроса HTTP-запроса к
  прокси HTTP-CoAP.

 В любом случае, только модель запрос / ответ CoAP отображается на
 HTTP. Базовая модель Подтверждаемого или неподтвержденного
 сообщения и т. д., невидимы и НЕ ДОЛЖНЫ влиять на прокси
 функция. В следующих разделах описывается обработка запросов.
 к форвард-прокси. Обратные прокси не указаны, так как прокси
 функция прозрачна для клиента, а прокси-сервер действует так, как будто он
 были исходным сервером. Однако аналогичные соображения применимы к
 обратные прокси в отношении прямых прокси, и, как правило, будет
 ожидание того, что обратные прокси-серверы работают аналогичным образом в прямом направлении -
 прокси бы. В качестве примечания к реализации клиентские библиотеки HTTP могут
 затруднить работу прокси-сервера HTTP-CoAP, не предоставляя
 способ поместить CoAP URI в строку HTTP-запроса; обратное проксирование может
 следовательно, это приведет к более широкому применению прокси. Отдельный
 спецификация может определять соглашение для URI, управляющих таким
 Обратный прокси HTTP-CoAP [MAPPING].

## 10.1. CoAP-HTTP прокси

 Если запрос содержит Proxy-Uri или Proxy-Scheme Option с
 URI "http" или "https" [RFC2616], затем конечная точка получения CoAP
 (далее называемый "прокси") запрашивается для выполнения операции
 указывается методом запроса на указанном HTTP-ресурсе и
 вернуть результат клиенту. (См. Также Раздел 5.7, чтобы узнать, как
 запрос к прокси сформулирован, включая требования безопасности.)

 Этот раздел определяет для любого запроса CoAP ответ CoAP, который
 прокси должен вернуться к клиенту. Как на самом деле прокси
 удовлетворяет запрос, является деталью реализации, хотя
 типичный случай, когда прокси переводит и пересылает
 запрос к исходному серверу HTTP.



 Поскольку HTTP и CoAP используют общий набор методов запроса,
 выполнение запроса CoAP на HTTP-ресурсе не так уж и отличается
 от выполнения этого на ресурсе CoAP. Значения
 отдельные методы CoAP при выполнении на ресурсах HTTP
 объяснено в подразделах этого раздела.

 Если прокси не может или не хочет обслуживать запрос с помощью HTTP
 URI, ответ 5.05 (проксирование не поддерживается) возвращается на
 клиент. Если прокси обслуживает запрос, взаимодействуя с
 третья сторона (например, исходный сервер HTTP) и не может получить
 результат в разумные сроки, 5,04 (таймаут шлюза)
 ответ возвращается; если результат может быть получен, но не
 понял, возвращается ответ 5.02 (плохой шлюз).

### 10.1.1. ПОЛУЧАТЬ

 Метод GET запрашивает у прокси-сервера представление
 Ресурс HTTP, идентифицированный URI запроса.

 В случае успеха ДОЛЖЕН быть возвращен код ответа 2.05 (контент). В
 полезная нагрузка ответа ДОЛЖНА быть представлением целевого HTTP
 ресурс, и параметр Content-Format ДОЛЖЕН быть установлен соответственно. В
 ответ ДОЛЖЕН указывать значение Max-Age, которое не превышает
 В оставшееся время представление можно считать свежим. Если
 У объекта HTTP есть тег объекта, прокси ДОЛЖЕН включать тег ETag.
 Вариант ответа и вариант обработки ETag в запросах как
 описано ниже.

 Клиент может повлиять на обработку запроса GET, включив
 следующий вариант:

 Принять: запрос МОЖЕТ включать параметр принятия, определяющий
  предпочтительный формат содержимого ответа.

 ETag: запрос МОЖЕТ включать один или несколько параметров ETag, определяющих
  ответы, которые клиент сохранил. Это запрашивает прокси для
  отправлять 2,03 (действительный) ответ всякий раз, когда он отправляет 2,05
  (Content) ответ с тегом объекта в запрошенном наборе
  иначе. Обратите внимание, что теги CoAP всегда являются сильными тегами ET в
  HTTP смысл; CoAP не имеет эквивалента слабых ETags HTTP,
  и нет хорошего способа использовать их в кросс-прокси.



### 10.1.2. СТАВИТЬ

 Метод PUT запрашивает у прокси-сервера обновление или создание HTTP
 ресурс, идентифицированный URI запроса с вложенным
 представление.

 Если новый ресурс создается по URI запроса, 2.01 (Создано)
 ответ ДОЛЖЕН быть возвращен клиенту. Если существующий ресурс
 изменен, ответ 2.04 (Изменено) ДОЛЖЕН быть возвращен, чтобы указать
 успешное выполнение запроса.

### 10.1.3. УДАЛИТЬ

 Метод DELETE запрашивает у прокси-сервера удаление ресурса HTTP.
 идентифицируется URI запроса на исходном сервере HTTP.

 Ответ 2.02 (удален) ДОЛЖЕН быть возвращен клиенту в случае успеха.
 или если ресурс не существует на момент запроса.

### 10.1.4. ПОЧТА

 Метод POST запрашивает у прокси представление
 заключенный в запрос, будет обработан исходным сервером HTTP. В
 фактическая функция, выполняемая методом POST, определяется
 исходный сервер и зависит от ресурса, указанного в запросе
 URI.

 Если действие, выполняемое методом POST, не приводит к
 ресурс, который можно идентифицировать по URI, ответ 2.04 (изменен)
 ДОЛЖЕН быть возвращен клиенту. Если ресурс был создан на
 исходному серверу ДОЛЖЕН быть возвращен ответ 2.01 (Создано).

# 10.2. HTTP-CoAP прокси

 Если HTTP-запрос содержит Request-URI с «coap» или «coaps»
 URI, затем принимающая конечная точка HTTP (далее именуемая прокси)
 запрашивается для выполнения операции, указанной в методе запроса
 на указанном ресурсе CoAP и вернуть результат клиенту.

 В этом разделе для любого HTTP-запроса указывается HTTP-ответ, который
 прокси должен вернуться к клиенту. Если не указано иное,
 все сделанные заявления являются РЕКОМЕНДУЕМЫМ поведением; некоторые очень
 в ограниченных реализациях может потребоваться использование ярлыков. Как
 прокси действительно удовлетворяет запрос - это деталь реализации,
 хотя обычно ожидается, что прокси переводит
 и пересылает запрос на исходный сервер CoAP. Значения
 отдельные методы HTTP при выполнении на ресурсах CoAP
 объяснено в подразделах этого раздела.



Если прокси-сервер не может или не желает обслуживать запрос с помощью CoAP
 URI, клиенту возвращается ответ 501 (не реализовано). Если
 прокси обслуживает запрос, взаимодействуя с третьей стороной
 (например, исходный сервер CoAP) и не может получить результат
 в течение разумного периода времени будет получен ответ 504 (тайм-аут шлюза).
 вернулся; если результат может быть получен, но не понят, 502
 (Плохой шлюз) возвращается ответ.

### 10.2.1. OPTIONS и TRACE

 Поскольку методы OPTIONS и TRACE не поддерживаются в CoAP, 501
 (Не реализовано) ошибка ДОЛЖНА быть возвращена клиенту.

### 10.2.2. GET

 Метод GET запрашивает у прокси-сервера представление
 Ресурс CoAP, идентифицированный Request-URI.

 В случае успеха возвращается ответ 200 (ОК). Полезная нагрузка
 ответ ДОЛЖЕН быть представлением целевого ресурса CoAP, и
 поля заголовка Content-Type и Content-Encoding ДОЛЖНЫ быть установлены
 соответственно. Ответ ДОЛЖЕН указывать директиву max-age, которая
 указывает значение не больше, чем оставшееся время
 Представление можно считать свежим. Если в ответе CoAP есть
 Вариант ETag, прокси должен включать поле заголовка ETag в
 отклик.

 Клиент может повлиять на обработку запроса GET, включив
 следующие варианты:

 Принять: наиболее предпочтительный тип носителя для заголовка HTTP Accept.
  поле в запросе сопоставляется с опцией принятия CoAP. Принятие HTTP
  диапазоны типов мультимедиа, параметры и расширения не поддерживаются
  вариант принятия CoAP. Если прокси не может отправить ответ,
  приемлемо в соответствии с объединенным значением поля Принять, тогда
  прокси отправляет ответ 406 (неприемлемо). Прокси МОЖЕТ
  затем повторите запрос с другими типами мультимедиа из HTTP
  Принять поле заголовка.

 Условные GET: условные HTTP-запросы GET, которые включают "If-
  Поле заголовка запроса Match "или" If-None-Match "может быть сопоставлено с
  соответствующий запрос CoAP. «Если-изменено-с» и «Если-
  Поля заголовка запроса "Неизменяемые" не поддерживаются напрямую.
  по CoAP, но реализуются локально с помощью кэширующего прокси.

### 10.2.3. HEAD

 Метод HEAD идентичен GET, за исключением того, что сервер НЕ ДОЛЖЕН
 вернуть тело сообщения в ответ.

 Хотя в CoAP нет прямого эквивалента HTTP-метода HEAD,
 прокси HTTP-CoAP отвечает на запросы HEAD для ресурсов CoAP, и
 заголовки HTTP возвращаются без тела сообщения.

 Примечание по реализации: прокси-сервер HTTP-CoAP может захотеть попробовать использовать
  вариант поблочной передачи [БЛОК] для минимизации объема данных
  фактически передан, но его нужно подготовить к делу
  что исходный сервер не поддерживает блочные передачи.

### 10.2.4. POST

 Метод POST запрашивает у прокси представление
 включенные в запрос, будут обработаны исходным сервером CoAP. В
 фактическая функция, выполняемая методом POST, определяется
 исходный сервер и зависит от ресурса, указанного в запросе
 URI.

 Если действие, выполняемое методом POST, не приводит к
 ресурс, который может быть идентифицирован URI, 200 (ОК) или 204 (Нет
 Content) ответ ДОЛЖЕН быть возвращен клиенту. Если у ресурса есть
 был создан на исходном сервере, ответ 201 (Создано) ДОЛЖЕН быть
 вернулся.

 Если в ответе CoAP присутствует какой-либо из вариантов Location- *,
 Поле заголовка местоположения, составленное из значений этих параметров, имеет вид
 вернулся.

### 10.2.5. PUT

 Метод PUT запрашивает у прокси-сервера обновление или создание CoAP.
 ресурс, идентифицированный Request-URI с вложенным
 представление.

 Если новый ресурс создается в Request-URI, 201 (Created)
 ответ возвращается клиенту. Если существующий ресурс
 изменен код ответа 200 (ОК) или 204 (Нет содержимого).
 отправлено, чтобы указать на успешное выполнение запроса.

### 10.2.6. DELETE

 Метод DELETE запрашивает у прокси-сервера удаление ресурса CoAP.
 идентифицированный Request-URI на исходном сервере CoAP.

 Успешный ответ - 200 (ОК), если ответ включает объект
 с описанием статуса или 204 (Нет содержимого), если действие было
 введено в действие, но ответ не включает сущность.

### 10.2.7. CONNECT

 Этот метод в настоящее время не может быть удовлетворен прокси-сервером HTTP-CoAP.
 функция, поскольку туннелирование TLS в DTLS еще не указано. Для
 теперь клиенту возвращается ошибка 501 (не реализована).

# 11. Соображения безопасности

 В этом разделе анализируются возможные угрозы протоколу. это
 предназначен для информирования разработчиков протоколов и приложений о
 ограничения безопасности CoAP, как описано в этом документе. Как CoAP
 реализует подмножество функций HTTP / 1.1, безопасность
 Соображения в Разделе 15 [RFC2616] также имеют отношение к CoAP.
 В этом разделе основное внимание уделяется описанию ограничений, характерных для CoAP.

## 11.1. Разбор протокола и обработка URI

 Сетевое приложение может обнаруживать уязвимости в своих
 логика обработки входящих пакетов. Сложные парсеры хорошо
 известен как вероятный источник таких уязвимостей, таких как способность
 для удаленного сбоя узла или даже удаленного выполнения произвольного кода на
 Это. CoAP пытается сузить возможности для внедрения таких
 уязвимостей за счет уменьшения сложности парсера, предоставляя весь
 диапазон кодируемых значений значение, где это возможно, и
 агрессивно снижая сложность, часто вызываемую ненужными
 выбор между несколькими представлениями, которые означают одно и то же.
 Большая часть обработки URI была перенесена на клиентов, в дальнейшем
 снижение возможностей для внесения уязвимостей в
 серверы. Даже в этом случае код обработки URI в реализациях CoAP
 вероятно, будет большим источником остающихся уязвимостей и должен
 выполняться с особой тщательностью. Контроль доступа CoAP
 реализации должны гарантировать, что они не привносят уязвимости
 из-за несоответствий между кодом получения контроля доступа
 решения из URI и кода, наконец, обслуживающего ресурс
 адресованный URI. Самым сложным из оставшихся парсеров может быть
 один для формата ссылки CoRE, хотя он также был разработан
 с целью снижения сложности реализации [RFC6690]. (Видеть
 также раздел 15.2 [RFC2616].)

## 11.2. Проксирование и кеширование

 Как упоминалось в разделе 15.7 [RFC2616], прокси-серверы сами по себе
 природа посредников, взламывая любую защиту IPsec или DTLS, которая
 прямой обмен сообщениями CoAP может иметь. Поэтому они
 интересные цели для нарушения конфиденциальности или целостности CoAP
 обмен сообщениями. Как отмечено в [RFC2616], они также интересны
 цели по нарушению доступности.

 Угроза конфиденциальности и целостности данных запроса / ответа
 усиливается где прокси еще и кешируют. Обратите внимание, что CoAP не
 определить любую из опций Cache-Control, подавляющих кеш, которые
 HTTP / 1.1 обеспечивает лучшую защиту конфиденциальных данных.

 Для реализации кэширования любые соображения контроля доступа, которые
 будет применяться к выполнению запроса, который также сгенерировал запись кеша
 необходимо применить к значению в кеше. Это актуально для
 клиенты, которые реализуют несколько доменов безопасности, а также для
 прокси, которые могут обслуживать несколько клиентов. Кроме того, кеширующий прокси ДОЛЖЕН
 НЕ делайте кешированные значения доступными для запросов с меньшим
 свойства транспортной безопасности, чем те, которые требуются прокси-серверу
 в первую очередь выполнять пересылку запросов.

 В отличие от схемы «копы», ответы на «копы» идентифицировали запросы
 никогда не являются общедоступными и поэтому НЕ ДОЛЖНЫ повторно использоваться для общего кеширования,
 если кеш не может принимать эквивалентные решения по управлению доступом
 к тем, которые привели к кэшированной записи. Однако они могут быть
 повторно используется в частном кеше, если сообщение по умолчанию кэшируется в
 CoAP.

 Наконец, прокси, который разносит отдельные ответы (в отличие от
 совмещенные ответы) нескольким первоначальным запросчикам могут предоставить
 дополнительное усиление (см. раздел 11.3).

## 11.3. Риск усиления

 Серверы CoAP обычно отвечают на пакет запроса ответом.
 пакет. Этот ответный пакет может быть значительно больше, чем
 пакет запроса. Злоумышленник может использовать узлы CoAP, чтобы
 пакет атаки в более крупный пакет атаки, подход, известный как
 усиление. Следовательно, существует опасность, что узлы CoAP могут
 стать замешанным в атаках типа "отказ в обслуживании" (DoS), используя
 усиливающие свойства протокола: злоумышленник, который пытается
 чтобы перегрузить жертву, но ограничен по объему трафика, который она может
 generate может использовать амплификацию для генерации большего количества
 движение.

 Это особенно проблема в узлах, которые разрешают доступ NoSec,
 доступны для злоумышленника и могут получить доступ к потенциальным жертвам (например,
 в обычном Интернете), поскольку протокол UDP не позволяет
 проверьте адрес источника, указанный в пакете запроса. Злоумышленник
 нужно только поместить IP-адрес жертвы в исходный адрес
 подходящий пакет запроса для генерации большего пакета, направленного на
 жертва.

 В качестве смягчающего фактора многие ограниченные сети смогут только
 для генерации небольшого объема трафика, что может уменьшить количество узлов CoAP.
 привлекателен для этой атаки. Однако ограниченная емкость
 ограниченная сеть делает саму сеть вероятной жертвой
 усиление атаки.

 Следовательно, НЕ СЛЕДУЕТ предоставлять большие коэффициенты усиления в
 ответ, если запрос не аутентифицирован. Сервер CoAP может
 уменьшить количество усиления, которое он предоставляет злоумышленнику,
 используя режимы нарезки / блокировки CoAP [BLOCK] и предлагая большие
 представления ресурсов только в относительно небольших срезах. Для
 Например, для 1000-байтового ресурса 10-байтовый запрос может привести к
 80-байтовый ответ (с 64-байтовым блоком) вместо 1016-байтового
 ответ, значительно снижающий усиление.

 CoAP также поддерживает использование многоадресных IP-адресов в запросах,
 важное требование к M2M. Многоадресные запросы CoAP могут быть
 источник случайных или преднамеренных DoS-атак, особенно над
 ограниченные сети. Эта спецификация пытается уменьшить
 эффекты усиления многоадресных запросов за счет ограничения, когда
 ответ возвращается. Чтобы ограничить возможность злонамеренного использования,
 Серверы CoAP НЕ ДОЛЖНЫ принимать многоадресные запросы, которые не могут быть
 аутентифицирован каким-либо образом, криптографически или с помощью некоторой многоадресной передачи
 граница, ограничивающая потенциальные источники. Если возможно, сервер CoAP
 СЛЕДУЕТ ограничить поддержку многоадресных запросов конкретными
 ресурсы, где требуется функция.

 В некоторых операционных системах общего назначения, предоставляющих API в стиле POSIX.
 [IEEE1003.1], непросто определить,
 полученный был адресован на многоадресный адрес. Хотя многие
 реализации будут знать, присоединились ли они к группе многоадресной рассылки,
 это создает проблему для пакетов, адресованных на многоадресные адреса.
 формы FF0x :: 1, которые принимаются каждым узлом IPv6.
 Реализации ДОЛЖНЫ использовать современные API, такие как
 IPV6_RECVPKTINFO [RFC3542], если доступен, чтобы сделать это определение.

## 11.4. Атаки с подменой IP-адреса

 Из-за отсутствия квитирования в UDP мошенническая конечная точка является бесплатной
 для чтения и записи сообщений, передаваемых ограниченной сетью (т. е.
 Развертывания NoSec или PreSharedKey с соотношением узлов / ключей> 1: 1), может
 легко атаковать одну конечную точку, группу конечных точек, а также
 вся сеть, например:

 1. подделка сообщения сброса в ответ на подтверждаемое сообщение или
 Неподтвержденное сообщение, что делает конечную точку «глухой»; или же

 2. подмена ACK в ответ на сообщение CON, что потенциально может
 предотвращение повторной передачи отправителя сообщения CON, и
 заглушение фактического ответа; или же

 3. подделка всего ответа поддельной полезной нагрузкой / опциями (это
 имеет разные уровни воздействия: от разрушения при однократном реагировании,
 к более смелым атакам на поддерживающую инфраструктуру, например,
 отравление кешей прокси или обман интерфейсов проверки / поиска
 в каталогах ресурсов и, в более общем смысле, в любом компоненте, который
 хранит состояние глобальной сети и использует CoAP в качестве обмена сообщениями
 средство для обработки настроек или обновления состояния является потенциальным
 цель.); или же

 4. подмена многоадресного запроса для целевого узла; это может привести
 при перегрузке / коллапсе сети, DoS-атаке на жертву или
 принудительное пробуждение от сна; или же

 5. сообщения наблюдения за спуфингом и т. Д.

 Подмена ответа со стороны сторонних атак может быть обнаружена и смягчена.
 даже без защиты транспортного уровня, выбрав нетривиальный,
 рандомизированный токен в запросе (раздел 5.3.1). [RFC4086] обсуждает
 требования случайности для безопасности.

 В принципе, другие виды спуфинга могут быть обнаружены CoAP только в
 case Используется подтверждаемая семантика сообщения из-за неожиданного
 Сообщения подтверждения или сброса, поступающие от обманутой конечной точки.
 Но это требует отслеживания используемых идентификаторов сообщений, которые не
 всегда возможно, и, кроме того, обнаружение становится доступным обычно
 после того, как ущерб уже нанесен. Такая атака может быть
 запрещено использовать режимы безопасности, отличные от NoSec.

 С подменой адреса источника или без него клиент может попытаться
 перегружать сервер, отправляя запросы, желательно сложные, на
 сервер; подмена адреса делает отслеживание и блокировку этого
 атаковать сильнее. Учитывая, что стоимость запроса CON невелика, это
 атака может быть легко выполнена. Под этой атакой ограниченный узел при ограниченной доступной общей энергии может исчерпать эту энергию намного больше
 быстрее, чем планировалось (атака разрядки аккумулятора). Также, если клиент
 использует подтверждаемое сообщение, и сервер отвечает подтверждающим
 отдельный ответ на (возможно, поддельный) адрес, который не
 ответить, сервер должен будет выделить буфер и повторную передачу
 логика для каждого ответа до исчерпания MAX_TRANSMIT_SPAN,
 повышая вероятность того, что у него закончились ресурсы для обработки
 законный трафик. Последнюю проблему можно несколько смягчить, если
 ограничение количества ответов, как описано в Разделе 4.7. An
 злоумышленник также может подделать адрес легитимного клиента; это
 может заставить сервер, если он использует отдельные ответы, заблокировать
 законные ответы этому клиенту из-за NSTART = 1. Все эти
 атаки можно предотвратить с помощью режима безопасности, отличного от NoSec, таким образом
 оставляя только атаки на протокол безопасности.

## 11.5. Межпротокольные атаки

 Возможность побудить конечную точку CoAP отправлять пакеты поддельному
 адрес источника можно использовать не только для усиления, но и для
 межпротокольные атаки на жертву, слушающую UDP-пакеты на
 данный адрес (IP-адрес и порт). Это могло бы произойти следующим образом:

* Злоумышленник отправляет сообщение конечной точке CoAP с указанным
  адрес как поддельный исходный адрес.

* Конечная точка CoAP отвечает сообщением указанному источнику
  адрес.

* Жертва по данному адресу получает UDP-пакет, который она
  интерпретирует в соответствии с правилами другого протокола.

 Это может быть использовано для обхода правил брандмауэра, препятствующих прямому
 общение злоумышленника с жертвой, но позволяет
 связь от конечной точки CoAP (которая также может содержать действительный
 роль в другом протоколе) жертве.

 Кроме того, конечные точки CoAP могут стать жертвой межпротокольной атаки.
 генерируется через конечную точку другого протокола на основе UDP, такого как
 DNS. В обоих случаях атаки возможны, если свойства безопасности
 конечных точек полагаются на проверку IP-адресов (и отключение брандмауэра).
 прямые атаки, отправленные извне с использованием поддельных IP-адресов). В
 как правило, протоколы на основе UDP из-за отсутствия контекста
 относительно простые цели для межпротокольных атак.

 Наконец, URI CoAP, переданные другими способами, могут быть использованы для подстрекательства
 клиенты для отправки сообщений конечным точкам других протоколов.

 Одним из способов предотвращения межпротокольных атак является строгая проверка
 синтаксис полученных пакетов в сочетании с достаточной разницей
 в синтаксисе. Например, это могло бы помочь, если бы было сложно
 побудить DNS-сервер отправить DNS-ответ, который прошел бы проверки
 конечной точки CoAP. К сожалению, первые два байта DNS
 ответ - это идентификатор, который может быть выбран злоумышленником и который отображается в
 интересная часть заголовка CoAP, а следующие два байта
 затем интерпретируется как идентификатор сообщения CoAP (т. е. любое значение
 приемлемо). Слова счетчика DNS могут интерпретироваться как несколько
 экземпляры варианта 0 CoAP (несуществующего, но факультативного) или, возможно,
 как жетон. Отраженный запрос, наконец, может быть произведен
 злоумышленник для достижения желаемого эффекта на конечной точке CoAP; в
 ответ, добавленный сервером (если есть), может быть просто интерпретирован
 как добавленная полезная нагрузка.

                                       1  1  1  1  1  1
         0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
       |                      ID                       | T, TKL, code
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
       |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   | Message ID
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
       |                    QDCOUNT                    | (options 0)
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
       |                    ANCOUNT                    | (options 0)
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
       |                    NSCOUNT                    | (options 0)
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
       |                    ARCOUNT                    | (options 0)
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    
       Рисунок 15: Заголовок DNS ([RFC1035], раздел 4.1.1) и сообщение CoAP

 В общем, для любой пары протоколов один из протоколов может очень
 хорошо спроектированы таким образом, чтобы злоумышленник мог вызвать
 генерация ответов, похожих на сообщения другого
 протокол. Гарантировать или доказать отсутствие
 жизнеспособные атаки, чем создание примеров, которые еще не полностью
 разрешить атаку, но может быть доработана более творческими
 умы. Таким образом, межпротокольные атаки могут быть полностью устранены.
 смягчается, если конечные точки не разрешают действия, желаемые злоумышленником
 просто на основе доверия к исходному IP-адресу пакета.
 И наоборот, среда NoSec, полностью полагающаяся на брандмауэр.
 для безопасности CoAP требуется не только брандмауэр с конечных точек CoAP
 но также и все другие конечные точки, которые могут быть спровоцированы на отправку UDP
 сообщения конечным точкам CoAP с использованием другого протокола на основе UDP.

 В дополнение к приведенным выше соображениям, соображения безопасности
 для DTLS применительно к межпротокольным атакам. Например,
 если та же самая ассоциация безопасности DTLS («соединение») используется для переноса
 данные нескольких протоколов, DTLS больше не обеспечивает защиту
 против межпротокольных атак между этими протоколами.

## 11.6. Соображения относительно ограниченного узла

 Разработчики на узлах с ограничениями часто оказываются без
 хороший источник энтропии [RFC4086]. В этом случае узел ДОЛЖЕН
 НЕ использоваться для процессов, требующих хорошей энтропии, таких как ключ
 поколение. Вместо этого ключи должны быть сгенерированы извне и добавлены
 к устройству при изготовлении или вводе в эксплуатацию.

 Из-за их низкой вычислительной мощности узлы с ограничениями особенно
 восприимчивы к временным атакам. Особую осторожность необходимо соблюдать
 реализация криптографических примитивов.

 Большое количество ограниченных узлов будет установлено в открытых
 окружающей среде и будет иметь небольшое сопротивление вмешательству, в том числе
 восстановление ключевых материалов. Это необходимо учитывать, когда
 определение объема назначенных им учетных данных. В частности,
 назначение общего ключа группе узлов может сделать любой отдельный
 ограниченный узел цель для ниспровержения всей группы.

# 12. Вопросы IANA

## 12.1. Реестры кодов CoAP

 В этом документе определены два подрегистра ценностей Кодекса.
 в заголовке CoAP в разделе «Ограниченные среды RESTful
 (CoRE) Parameters », далее именуемый« CoRE
 Параметры "реестр.

 Значения в двух подрегистрах представляют собой восьмибитные значения, обозначенные как
 три десятичных цифры c.dd, разделенные точкой между первой и
 вторая цифра; первая цифра c находится между 0 и 7 и обозначает
 кодовый класс; вторая и третья цифры dd обозначают десятичную дробь
 номер от 00 до 31 для детали.

 Все значения кодов присваиваются субрегистрами в соответствии с
 следующие диапазоны:

 0.00 Указывает на пустое сообщение (см. Раздел 4.1).

 0,01-0,31 Обозначает запрос. Значения в этом диапазоне присваиваются
подрегистр «Коды методов CoAP» (см. Раздел 12.1.1).

 1.00-1.31 Зарезервировано

 2.00-5.31 Обозначает ответ. Значения в этом диапазоне присваиваются
подрегистр «Коды ответа CoAP» (см.
Раздел 12.1.2).

 6.00-7.31 Зарезервировано

### 12.1.1. Коды методов

 Имя подрегистра - «Коды методов CoAP».

 Каждая запись в суб-реестре должна включать Код метода в
 диапазон 0,01–0,31, имя метода и ссылка на
 документация метода.

 Первоначальные записи в этом подрегистре следующие:



| Код | Имя | Справка |
| ------| --------| ----------- |
| 0,01 | ПОЛУЧИТЬ | [RFC7252] |
| 0,02 | ПОЧТА | [RFC7252] |
| 0,03 | PUT | [RFC7252] |
| 0,04 | УДАЛИТЬ | [RFC7252] |

   Таблица 5: Коды методов CoAP

 Все остальные коды методов не назначены.

 Политика IANA в отношении будущих дополнений к этому субреестру: «IETF
 Проверка или одобрение IESG », как описано в [RFC5226].

 Документация кода метода должна указывать семантику
 запрос с этим кодом, включая следующие свойства:

* Ответные коды, возвращаемые методом в случае успеха.

* Идемпотентен ли метод, безопасен или и то, и другое.



[стр. 87]




### 12.1.2. Коды ответов

 Имя подрегистра - «Коды ответа CoAP».

 Каждая запись в суб-реестре должна включать код ответа в
 диапазон 2,00–5,31, описание кода ответа и ссылка
 к документации по коду ответа.

 Первоначальные записи в этом подрегистре следующие:

| Код  | Описание | Справка |
| ---- | -------- | ------- |
| 2.01 | Создано | [RFC7252] |
| 2.02 | Удалено | [RFC7252] |
| 2.03 | Действительный | [RFC7252] |
| 2.04 | Изменено | [RFC7252] |
| 2.05 | Содержание | [RFC7252] |
| 4.00 | Плохой запрос | [RFC7252] |
| 4.01 | Несанкционированный | [RFC7252] |
| 4.02 | Плохой вариант | [RFC7252] |
| 4.03 | Запрещено | [RFC7252] |
| 4.04 | Не найдено | [RFC7252] |
| 4.05 | Метод запрещен | [RFC7252] |
| 4.06 | Неприемлемо | [RFC7252] |
| 4.12 | Предварительное условие не выполнено | [RFC7252] |
| 4.13 | Слишком большой объект запроса | [RFC7252] |
| 4.15 | Неподдерживаемый формат содержимого | [RFC7252] |
| 5.00 | Внутренняя ошибка сервера | [RFC7252] |
| 5.01 | Не реализовано | [RFC7252] |
| 5.02 | Плохой шлюз | [RFC7252] |
| 5.03 | Служба недоступна | [RFC7252] |
| 5.04 | Тайм-аут шлюза | [RFC7252] |
| 5.05 | Проксирование не поддерживается | [RFC7252] |

Таблица 6: Коды ответа CoAP

 Коды ответа 3.00–3.31 зарезервированы для использования в будущем. Все остальные
 Коды ответа не назначены.

 Политика IANA в отношении будущих дополнений к этому субреестру: «IETF
 Проверка или одобрение IESG », как описано в [RFC5226].

 Документация кода ответа должна указывать семантику
 ответ с этим кодом, включая следующие свойства:

* Методы, к которым применяется Код ответа.

* Является ли полезная нагрузка обязательной, необязательной или запрещенной.

* Семантика полезной нагрузки. Например, полезная нагрузка 2.05
  (Контент) ответ - это представление целевого ресурса; в
  полезная нагрузка в ответе на ошибку - это понятная человеку диагностика
  полезная нагрузка.

* Формат полезной нагрузки. Например, формат в 2.05
  (Content) ответ указывается опцией Content-Format; в
  формат полезной нагрузки в ответе об ошибке всегда Net-Unicode
  текст.

* Кэшируется ли ответ в соответствии с его свежестью
  модель.

* Является ли ответ валидным в соответствии с валидацией.
  модель.

* Приводит ли ответ кеширование отметки ответов, сохраненных для
  URI запроса как несвежий.

## 12.2. Реестр номеров опций CoAP

 В этом документе определяется подрегистр для номеров опций, используемых в
 Параметры CoAP в реестре «Параметры CoRE». Имя
 суб-реестр - «Номера вариантов CoAP».

 Каждая запись в суб-реестре должна включать номер опции,
 название опции и ссылку на ее документацию.

 Первоначальные записи в этом подрегистре следующие:

| Номер | Имя | Справка |
| --------| ------------------| ----------- |
| 0 | (Зарезервировано) | [RFC7252] |
| 1 | If-Match | [RFC7252] |
| 3 | Uri-Host | [RFC7252] |
| 4 | ETag | [RFC7252] |
| 5 | If-None-Match | [RFC7252] |
| 7 | Uri-Port | [RFC7252] |
| 8 | Location-Path | [RFC7252] |
| 11 | Uri-Path | [RFC7252] |
| 12 | Content-Format | [RFC7252] |
| 14 | Max-Age | [RFC7252] |
| 15 | Uri-Query | [RFC7252] |
| 17 | Accept | [RFC7252] |
| 20 | Location-Query | [RFC7252] |
| 35 | Proxy-Uri | [RFC7252] |
| 39 | Proxy-Scheme | [RFC7252] |
| 60 | Size1 | [RFC7252] |
| 128 | (Зарезервировано) | [RFC7252] |
| 132 | (Зарезервировано) | [RFC7252] |
| 136 | (Зарезервировано) | [RFC7252] |
| 140 | (Зарезервировано) | [RFC7252] |
| --------| ------------------| ----------- |

###### Таблица 7: Номера опций CoAP

 Политика IANA в отношении будущих дополнений к этому субреестру разделена
 на три уровня следующим образом. Диапазон 0..255 зарезервирован для
 варианты, определенные IETF (Обзор IETF или Утверждение IESG). В
 диапазон 256..2047 зарезервирован для часто используемых опций с общедоступными
 спецификации (требуется спецификация). Диапазон 2048..64999 - это
 для всех других опций, включая частные или зависящие от поставщика,
 которые проходят проверку назначенным экспертом, чтобы гарантировать, что
 семантика опций определена правильно. Номера вариантов между
 65000 и 65535 включительно зарезервированы для экспериментов. Они не
 предназначены для использования в зависимости от производителя и НЕ ДОЛЖНЫ использоваться в
 оперативное развертывание.



| Диапазон | Регистрационные процедуры |
| -------- | ------------------------- |
| 0-255 | Обзор IETF или одобрение IESG |
| 256-2047 | Требуется спецификация |
| 2048-64999 | Обзор экспертов |
| 65000-65535 | Экспериментальное использование (не эксплуатационное использование) |

###### Таблица 8: Номера вариантов CoAP: процедуры регистрации

 Документация по номеру опции должна указывать семантику
 вариант с этим номером, включая следующие свойства:

* Значение опции в запросе.

* Значение опции в ответе.

* является ли вариант критическим или факультативным, как определено
  Номер варианта.

* Является ли опция Safe-to-Forward, и, если да, то
  часть ключа кэша, как определено номером опции (см.
  Раздел 5.4.2).

* Формат и длина значения опции.

* Должен ли вариант произойти не более одного раза или он может произойти
  много раз.

* Значение по умолчанию, если есть. Для критического варианта со значением по умолчанию
  значение, обсуждение того, как значение по умолчанию позволяет обрабатывать
  реализации, которые не поддерживают критическую опцию
  (Раздел 5.4.4).

## 12.3. Реестр форматов содержимого CoAP

 Типы интернет-медиа идентифицируются строкой, например  "application / xml" [RFC2046]. Чтобы свести к минимуму накладные расходы  используя эти типы мультимедиа для указания формата полезной нагрузки, это  документ определяет подреестр для подмножества типов Интернет-носителей.  для использования в CoAP и присваивает каждому в сочетании с  кодировка, числовой идентификатор. Название суб-реестра - «CoAP  Content-Formats »в реестре« Параметры CoRE ».

 Каждая запись в суб-реестре должна включать зарегистрированный тип носителя  с IANA числовой идентификатор в диапазоне 0-65535, который будет использоваться для  этот тип мультимедиа в CoAP, кодирование содержимого, связанное с этим  идентификатор и ссылка на документ, описывающий, что такое полезная нагрузка  с этим типом носителя означает семантически.

 CoAP не включает отдельный способ передачи кодирования контента  
 информацию с запросом или ответом, и по этой причине Content-encoding также указывается для каждого идентификатора (если есть). Если  несколько кодировок содержимого будут использоваться с типом мультимедиа, затем  для каждого должен быть зарегистрирован отдельный идентификатор Content-Format.
 Аналогичным образом другие параметры, относящиеся к типу Интернет-носителя,  например  как уровень, может быть определен для записи CoAP Content-Format.

Первоначальные записи в этом подрегистре следующие:


|  Тип СМИ                  | Кодирование | ID | Справка                  |
| --------------------------| ----------- | -- | ------------------------ |
| text/plain;charset=utf-8  | - | 0 | [RFC2046] [RFC3676] [RFC5147]|
| application/link-format   | - | 40 | [RFC6690] |
| application / xml         | - | 41 | [RFC3023] |
| application/octet-stream  | - | 42 | [RFC2045] [RFC2046] |
| application/exi           | - | 47 | [REC-exi-20140211] |
| application/json          | - | 50 | [RFC7159] |



###### Таблица 9: Форматы содержимого CoAP

 Идентификаторы от 65000 до 65535 включительно зарезервированы для
 эксперименты. Они не предназначены для использования каким-либо конкретным поставщиком.
 и НЕ ДОЛЖНЫ использоваться в оперативных развертываниях. Идентификаторы
 от 256 до 9999 зарезервированы для будущего использования в IETF
 спецификации (обзор IETF или утверждение IESG). Все остальные идентификаторы
 не назначены.

 Поскольку пространство имен однобайтовых идентификаторов настолько мало,
 Политика IANA в отношении будущих добавлений в диапазоне 0–255 включительно
 суб-реестр - это «Экспертная оценка», как описано в [RFC5226]. IANA
 политика для добавлений в диапазоне 10000–64999 включительно: «Первый
 Come First Served », как описано в [RFC5226]. Это кратко изложено в
 следующая таблица.

| Диапазон | Регистрационные процедуры |
| -------------| ----------------------------------- ---- |
| 0-255 | Обзор экспертов |
| 256-9999 | Обзор IETF или одобрение IESG |
| 10000-64999 | Первым пришел - первым обслужен |
| 65000-65535 | Экспериментальное использование (не эксплуатационное использование) |

###### Таблица 10: Контент-форматы CoAP: процедуры регистрации

 В межмашинных приложениях не ожидается, что общие
 Типы Интернет-медиа, такие как text / plain, application / xml или
 application / octet-stream полезны для реальных приложений в течение длительного времени.
 срок. Рекомендуется, чтобы приложения M2M, использующие CoAP
 запросить новые типы Интернет-носителей у IANA с указанием семантических
 информация о том, как создать или проанализировать полезную нагрузку. Например,
 Полезная нагрузка приложения Smart Energy, передаваемая в виде XML, может потребовать дополнительных
 конкретный тип, например application / se + xml или application / se-exi.

## 12.4. Регистрация схемы URI

 В этом документе содержится запрос на регистрацию
 Схема универсального идентификатора ресурса (URI) "coap". Регистрация
 запрос соответствует [RFC4395].

 Имя схемы URI.
  копейка

 Статус.
  Постоянный.

 Синтаксис схемы URI.
  Определено в разделе 6.1 [RFC7252].

 Семантика схемы URI.
  Схема URI "coap" позволяет идентифицировать ресурсы, которые
  потенциально доступны через ограниченное приложение
  Протокол (CoAP). Ресурсы можно найти, связавшись с
  управляющий сервером CoAP и работающий путем отправки запросов CoAP на
  сервер. Таким образом, эту схему можно сравнить с URI "http".
  схема [RFC2616]. См. Раздел 6 [RFC7252] для получения подробной информации о
  операция.

 Рекомендации по кодированию.
  Кодирование схемы соответствует правилам кодирования, установленным для
  URI в [RFC3986], т. Е. Интернационализированные и зарезервированные символы
  выражаются с использованием процентного кодирования на основе UTF-8.

 Приложения / протоколы, использующие это имя схемы URI.
  Схема используется конечными точками CoAP для доступа к ресурсам CoAP.

 Соображения по совместимости.
  Никто.

 Соображения безопасности.
  См. Раздел 11.1 [RFC7252].

 Контакт.
  Председатель IETF <Chair@ietf.org>

 Автор / Сменить контролера.
  IESG <iesg@ietf.org>

 Рекомендации.
  [RFC7252]

## 12.5. Безопасная регистрация схемы URI

 В этом документе содержится запрос на регистрацию
 Схема универсального идентификатора ресурса (URI) "копируется". Регистрация
 запрос соответствует [RFC4395].

 Имя схемы URI.
  копейки

 Статус.
  Постоянный.

 Синтаксис схемы URI.
  Определено в разделе 6.2 [RFC7252].

 Семантика схемы URI.
  Схема URI "coaps" позволяет идентифицировать ресурсы, которые
  потенциально доступны через ограниченное приложение
  Протокол (CoAP) с использованием защиты на транспортном уровне дейтаграмм (DTLS) для
  транспортная безопасность. Ресурсы можно найти, связавшись с
  управляющий сервер CoAP и работает, отправляя запросы CoAP
  к серверу. Таким образом, эту схему можно сравнить с https
  Схема URI [RFC2616]. См. Подробности в разделе 6 [RFC7252].
  операции.

 Рекомендации по кодированию.
  Кодирование схемы соответствует правилам кодирования, установленным для
  URI в [RFC3986], т. Е. Интернационализированные и зарезервированные символы
  выражаются с использованием процентного кодирования на основе UTF-8.



 Приложения / протоколы, использующие это имя схемы URI.
  Схема используется конечными точками CoAP для доступа к ресурсам CoAP.
  используя DTLS.

 Соображения по совместимости.
  Никто.

 Соображения безопасности.
  См. Раздел 11.1 [RFC7252].

 Контакт.
  Председатель IETF <Chair@ietf.org>

 Автор / Сменить контролера.
  IESG <iesg@ietf.org>

 Рекомендации.
  [RFC7252]

## 12.6. Регистрация имени службы и номера порта

 Одна из функций CoAP - обнаружение ресурсов: клиент CoAP может
 спросите сервер CoAP о предлагаемых им ресурсах (см. Раздел 7).
 Чтобы включить обнаружение ресурсов только на основе знания IP
 адрес, порт CoAP для обнаружения ресурсов должен быть
 стандартизированный.

 IANA присвоила номер порта 5683 и имя службы "coap",
 в соответствии с [RFC6335].

 Помимо одноадресной рассылки, CoAP может использоваться как с многоадресной, так и с произвольной рассылкой.

 Наименование услуги.
  копейка

 Транспортный протокол.
  udp

 Правопреемник.
  IESG <iesg@ietf.org>

 Контакт.
  Председатель IETF <Chair@ietf.org>

 Описание.
  Протокол ограниченного приложения (CoAP)

 Справка.
  [RFC7252]

 Номер порта.
  5683

## 12.7. Безопасная регистрация имени службы и номера порта

 Обнаружение ресурсов CoAP также может быть обеспечено с использованием защищенного DTLS
 Схема «копы» CoAP. Таким образом, порт CoAP для безопасного ресурса
 открытие необходимо стандартизировать.

 IANA присвоила номер порта 5684 и имя службы "coaps",
 в соответствии с [RFC6335].

 Помимо одноадресной передачи, CoAP с защитой от DTLS может использоваться с любой передачей.

 Наименование услуги.
  копейки

 Транспортный протокол.
  udp

 Правопреемник.
  IESG <iesg@ietf.org>

 Контакт.
  Председатель IETF <Chair@ietf.org>

 Описание.
  CoAP с защитой от DTLS

 Справка.
  [RFC7252]

 Номер порта.
  5684



## 12.8. Регистрация многоадресного адреса

 Раздел 8 «Multicast CoAP» определяет использование многоадресной рассылки. IANA имеет
 назначил следующие групповые адреса для использования узлами CoAP:

 IPv4 - "Все узлы CoAP" адрес 224.0.1.187, из "IPv4"
  Реестр многоадресного адресного пространства ". Поскольку адрес используется для
  открытие, которое может выходить за пределы одной сети, оно пришло из
  блок межсетевого управления (224.0.1.x, RFC 5771).

 IPv6 - адрес "Все узлы CoAP" FF0X :: FD, из "IPv6 Multicast"
  Реестр адресного пространства »в разделе« Многоадресная рассылка с переменной областью действия.
  Адреса "пробел (RFC 3307). Обратите внимание, что есть отдельный
  адрес многоадресной рассылки для каждой области, в которой заинтересованные узлы CoAP должны
  слушать; CoAP нужны только области Link-Local и Site-Local.

# 13. Благодарности

 Брайан Франк был соавтором и соавтором ранних версий
 эта спецификация.

 Особая благодарность Питеру Биготу, Эско Дейку и Каллену Дженнингсу за
 существенный вклад в идеи и текст в документе,
 наряду с бесчисленными подробными обзорами и обсуждениями.

 Спасибо Флорису Ван ден Абилу, Энтони Бэру, Эду Беросету, Берте.
 Карбаллидо, Анджело П. Кастеллани, Гилберт Кларк, Роберт Крэги,
 Пьер Давид, Эско Дейк, Лиза Дюссо, Мехмет Эрсу, Томас
 Фоссати, Тобиас Гондром, Берт Гривенбош, Том Хербст, Йерун
 Хобеке, Ричард Келси, Си Лунг Кео, Ари Керанен, Матиас
 Ковач, Ави Лиор, Стефан Лозе, Сальваторе Лорето, Керри Линн,
 Эндрю МакГрегор, Алексей Мельников, Гвидо Мориц, Петри Мутка, Колин
 О'Флинн, Чарльз Палмер, Адриано Пеццуто, Томас Поэтч, Роберт
 Кваттлбаум, Акбар Рахман, Эрик Рескорла, Дэн Ромаскану, Дэвид Райан,
 Питер Сен-Андре, Шимон Сасин, Майкл Шарф, Дейл Сид, Робби
 Симпсон, Питер ван дер Сток, Майкл Стубер, Линьи Тиан, Гилман
 Толле, Матье Виал, Мацей Василак, Фан Сянью и Альпер Егин
 за полезные комментарии и обсуждения, которые сформировали документ.
 Особая благодарность также ответственному директору IETF в то время.
 завершения, Барри Лейба и обозреватели IESG Адриан Фаррел,
 Мартин Штимерлинг, Пит Резник, Ричард Барнс, Шон Тернер,
 Спенсер Докинз, Стивен Фаррелл и Тед Лемон, которые внесли свой вклад в
 подробные обзоры.

 Часть текста заимствована из рабочих документов
 Рабочая группа IETF HTTPBIS.





[стр. 97]




# 14. Ссылки

## 14.1. Нормативные ссылки

 [RFC0768] Постел, Дж., «Протокол дейтаграмм пользователя», STD 6, RFC 768,
 Август 1980 г.

 [RFC2045] Фрид, Н. и Н. Боренштейны, "Многоцелевая интернет-почта.
 Расширения (MIME), часть первая: формат интернет-сообщения
 Тела », RFC 2045, ноябрь 1996 г.

 [RFC2046] Фрид, Н. и Н. Боренштейны, "Многоцелевая интернет-почта.
 Расширения (MIME), часть вторая: типы носителей », RFC 2046,
 Ноябрь 1996 г.

 [RFC2119] Брэднер, С., «Ключевые слова для использования в RFC для обозначения
 Уровни требований », BCP 14, RFC 2119, март 1997 г.

 [RFC2616] Филдинг, Р., Геттис, Дж., Могул, Дж., Фристик, Х.,
 Масинтер, Л., Лич, П., и Т. Бернерс-Ли, "Гипертекст
 Протокол передачи - HTTP / 1.1 », RFC 2616, июнь 1999 г.

 [RFC3023] Мурата, М., Сен-Лоран, С., и Д. Кон, "XML Media
 Типы », RFC 3023, январь 2001 г.

 [RFC3629] Йерго, Ф., «UTF-8, формат преобразования ISO.
 10646 ", STD 63, RFC 3629, ноябрь 2003 г.

 [RFC3676] Гелленс, Р., «Текстовый / простой формат и параметры DelSp»,
 RFC 3676, февраль 2004 г.

 [RFC3986] Бернерс-Ли, Т., Филдинг, Р., и Л. Масинтер, "Униформа
 Идентификатор ресурса (URI): Общий синтаксис ", STD 66, RFC
 3986, январь 2005 г.

 [RFC4279] Эронен, П. и Х. Чофениг, "Наборы шифрования с предварительным общим ключом
 для безопасности транспортного уровня (TLS) », RFC 4279, декабрь
 2005 г.

 [RFC4395] Хансен, Т., Харди, Т., и Л. Масинтер, "Рекомендации и
 Процедуры регистрации для новых схем URI », BCP 35, RFC
 4395, февраль 2006 г.

 [RFC5147] Wilde, E. and M. Duerst, "Идентификаторы фрагментов URI для
 text / plain Media Type », RFC 5147, апрель 2008 г.

 [RFC5198] Кленсин, Дж. И М. Падлипски, "Формат Unicode для сети
 Обмен », RFC 5198, март 2008 г.

 [RFC5226] Нартен, Т. и Х. Альвестранд, "Рекомендации по написанию
 Раздел соображений IANA в RFC », BCP 26, RFC 5226,
 Май 2008 г.

 [RFC5234] Крокер Д. и П. Оверелл, "Расширенный BNF для синтаксиса
 Спецификации: ABNF », STD 68, RFC 5234, январь 2008 г.

 [RFC5246] Диркс, Т. и Э. Рескорла, «Безопасность транспортного уровня.
 (TLS) Protocol Version 1.2 », RFC 5246, август 2008 г.

 [RFC5280] Купер, Д., Сантессон, С., Фаррелл, С., Бойен, С.,
 Р. Хаусли и У. Полк, "Открытый ключ Internet X.509"
 Сертификат инфраструктуры и список отозванных сертификатов
 (CRL) Profile », RFC 5280, май 2008 г.

 [RFC5480] Тернер, С., Браун, Д., Ю, К., Хаусли, Р., и Т. Полк,
 "Открытый ключ объекта криптографии с эллиптической кривой
 Информация », RFC 5480, март 2009 г.

 [RFC5785] Ноттингем, М. и Э. Хаммер-Лахав, "Определение хорошо известного
 Uniform Resource Identifiers (URIs) ", RFC 5785, апрель.
 2010 г.

 [RFC5952] Кавамура, С. и М. Кавасима, "Рекомендация по IPv6.
 Текстовое представление адреса », RFC 5952, август 2010 г.

 [RFC5988] Nottingham, M., «Web Linking», RFC 5988, октябрь 2010 г.

 [RFC6066] Истлейк Д., «Расширения безопасности транспортного уровня (TLS):
 Extension Definitions », RFC 6066, январь 2011 г.

 [RFC6347] Рескорла, Э. и Н. Модадугу, «Транспортный уровень дейтаграмм.
 Версия безопасности 1.2 », RFC 6347, январь 2012 г.

 [RFC6690] Шелби, З., Ссылка на ограниченные среды RESTful (CoRE)
 Формат », RFC 6690, август 2012 г.

 [RFC6920] Фаррелл, С., Кучер, Д., Данневиц, К., Олман, Б.,
 Керанен, А. и П. Халлам-Бейкер, "Присвоение имен вещам
 Хеши », RFC 6920, апрель 2013 г.

 [RFC7250] Воутерс П., Чофениг Х., Гилмор Дж., Вейлер С. и
 Т. Кивинен, "Использование сырых открытых ключей на транспортном уровне"
 Безопасность (TLS) и безопасность на транспортном уровне дейтаграмм
 (DTLS) », RFC 7250, июнь 2014 г.

 [RFC7251] МакГрю, Д., Бейли, Д., Кампанья, М., и Р. Дугал, "AES-
 Наборы шифров CCM Elliptic Curve Cryptography (ECC) для
 Безопасность транспортного уровня (TLS) », RFC 7251, июнь 2014 г.

## 14.2. Информативные ссылки

 [BLOCK] Борман, К. и З. Шелби, «Блочные переводы в CoAP»,
 Работа в процессе, октябрь 2013 г.

 [CoAP-MISC]
 Борман, К. и К. Хартке, "Разные дополнения к
 CoAP », Работа в процессе, декабрь 2013 г.

 [EUI64] IEEE Standards Association, "Рекомендации для 64-битных глобальных
 Идентификатор (EUI-64 (TM)) », Орган регистрации
 Учебники, апрель 2010 г., <http://standards.ieee.org/regauth/
 oui / tutorials / EUI64.html>.

 [GROUPCOMM]
 Рахман, А. и Э. Дейк, «Групповая коммуникация для CoAP»,
 Работа в процессе, декабрь 2013 г.

 [HHGTTG] Адамс, Д., «Автостопом по Галактике», Пан
 Книги ISBN 3320258648, 1979.

 [IEEE1003.1]
 IEEE и The Open Group, "Портативная операционная система"
 Интерфейс (POSIX) », Базовые спецификации Open Group
 Выпуск 7, IEEE 1003.1, издание 2013 г.,
 <http://pubs.opengroup.org/onlinepubs/9699919799/>.

 [IPsec-CoAP]
 Борман, К., «Использование CoAP с IPsec», Работа в процессе,
 Декабрь 2012 г.

 [КАРТА] Кастеллани, А., Лорето, С., Рахман, А., Фоссати, Т., и
 Э. Дейк, "Рекомендации по отображению HTTP-CoAP
 Внедрения », Работа в процессе, февраль 2014 г.

 [НАБЛЮДЕНИЕ] Хартке, К., «Наблюдение за ресурсами в CoAP», Работа в
 Прогресс, апрель 2014 г.

 [REC-exi-20140211]
 Шнайдер, Дж., Камия, Т., Пайнтнер, Д., и Р. Кюсаков,
 "Эффективный формат обмена XML (EXI) 1.0 (второй
 Edition) », Рекомендация W3C REC-exi-20140211, февраль
 2014 г., <http://www.w3.org/TR/2014/REC-exi-20140211/>.

 [ОТДЫХ] Филдинг Р., "Архитектурные стили и дизайн
 Сетевые архитектуры программного обеспечения », кандидатская диссертация,
 Калифорнийский университет, Ирвин, 2000 г.,
 <http://www.ics.uci.edu/~fielding/pubs/dishesis/
 fielding_disssment.pdf>.

 [RFC0020] Серф В., "Формат ASCII для сетевого обмена", RFC 20,
 Октябрь 1969 г.

 [RFC0791] Postel, J., "Internet Protocol", STD 5, RFC 791, сентябрь
 1981 г.

 [RFC0792] Постел, Дж., "Протокол управляющих сообщений Интернета", STD 5,
 RFC 792, сентябрь 1981 г.

 [RFC0793] Постел, Дж., «Протокол управления передачей», STD 7, RFC
 793, сентябрь 1981 г.

 [RFC1035] Mockapetris, P., "Доменные имена - реализация и
 спецификация », STD 13, RFC 1035, ноябрь 1987 г.

 [RFC3264] Розенберг, Дж. И Х. Шульцринн, "Модель предложения / ответа
 с протоколом описания сеанса (SDP) », RFC 3264, июнь
 2002 г.

 [RFC3280] Housley, R., Polk, W., Ford, W., and D. Solo, Internet
 Сертификат инфраструктуры открытого ключа X.509 и
 Профиль отзыва сертификатов (CRL) », RFC 3280,
 Апрель 2002 г.

 [RFC3542] Стивенс, В., Томас, М., Нордмарк, Э. и Т. Джинмей,
 "Расширенный прикладной программный интерфейс сокетов (API) для
 IPv6 ", RFC 3542, май 2003 г.

 [RFC3828] Ларзон, Луизиана, Дегермарк, М., Пинк, С., Йонссон, Л.Е., и
 Г. Фэрхерст, "Облегченный протокол дейтаграмм пользователя"
 (UDP-Lite) », RFC 3828, июль 2004 г.

 [RFC4086] Истлейк Д., Шиллер Дж. И С. Крокер, "Случайность
 Требования к безопасности », BCP 106, RFC 4086, июнь 2005 г.

 [RFC4443] Conta, A., Deering, S., and M. Gupta, "Internet Control
 Протокол сообщений (ICMPv6) для Интернет-протокола
 Версия 6 (IPv6) Specification », RFC 4443, март 2006 г.

 [RFC4492] Блейк-Уилсон, С., Болиард, Н., Гупта, В., Хок, С., и Б.
 Меллер, "Наборы шифров для криптографии с эллиптическими кривыми (ECC)"
 для безопасности транспортного уровня (TLS) », RFC 4492, май 2006 г.

 [RFC4821] Mathis, M. и J. Heffner, "MTU пути уровня пакетирования
 Discovery », RFC 4821, март 2007 г.

 [RFC4944] Черногория, Г., Кушалнагар, Н., Хуэй, Дж., И Д. Каллер,
 «Передача пакетов IPv6 по IEEE 802.15.4.
 Сети », RFC 4944, сентябрь 2007 г.

 [RFC5405] Эггерт, Л. и Г. Фэрхерст, "Рекомендации по использованию одноадресной передачи UDP.
 для разработчиков приложений », BCP 145, RFC 5405, ноябрь
 2008 г.

 [RFC5489] Бадра, М. и И. Хаджех, "Наборы шифров ECDHE_PSK для
 Безопасность транспортного уровня (TLS) », RFC 5489, март 2009 г.

 [RFC6090] МакГрю, Д., Иго, К., и М. Солтер, «Фундаментальный эллиптический
 Кривые алгоритмы криптографии », RFC 6090, февраль 2011 г.

 [RFC6120] Сен-Андре, П., "Расширяемый обмен сообщениями и присутствие
 Протокол (XMPP): Core », RFC 6120, март 2011 г.

 [RFC6282] Хуэй, Дж. И П. Туберт, «Формат сжатия для IPv6.
 Датаграммы по сетям на основе IEEE 802.15.4 », RFC 6282,
 Сентябрь 2011 г.

 [RFC6335] Коттон, М., Эггерт, Л., Тач, Дж., Вестерлунд, М., и С.
 Чешир, "Управление по распределению номеров в Интернете (IANA)"
 Процедуры управления названием службы и
 Реестр номеров портов транспортного протокола », BCP 165, RFC
 6335, август 2011 г.

 [RFC6655] МакГрю, Д. и Д. Бейли, "Наборы шифров AES-CCM для
 Безопасность транспортного уровня (TLS) », RFC 6655, июль 2012 г.

 [RFC6936] Fairhurst, G. и M. Westerlund, "Заявление о применимости
 для использования дейтаграмм IPv6 UDP с нулевыми контрольными суммами »,
 RFC 6936, апрель 2013 г.

 [RFC6960] Сантессон, С., Майерс, М., Анкни, Р., Малпани, А.,
 Гальперин, С. и К. Адамс, "Открытый ключ Интернета X.509"
 Протокол статуса онлайн-сертификата инфраструктуры - OCSP »,
 RFC 6960, июнь 2013 г.

 [RFC6961] Петтерсен Ю., "Безопасность транспортного уровня (TLS)"
 Расширение запроса состояния нескольких сертификатов », RFC 6961,
 Июнь 2013.

 [RFC7159] Брей, Т., "Данные JavaScript Object Notation (JSON)"
 Формат обмена », RFC 7159, март 2014 г.

 [RFC7228] Борман, К., Эрсу, М., и А. Керанен, «Терминология для
 Сети с ограниченными узлами ", RFC 7228, май 2014 г.

 [RTO-CONSIDER]
 Оллман, М., "Рассмотрение тайм-аута повторной передачи", Работа
 в процессе, май 2012 г.

 [W3CXMLSEC]
 Веннинг, Р., "Отчет о безопасности XML PAG", W3C XML
 Security PAG, октябрь 2012 г.,
 <http://www.w3.org/2011/xmlsec-pag/pagreport.html>.








































[стр. 103]




Приложение А. Примеры

 В этом разделе приводится несколько коротких примеров с потоками сообщений для
 GET запросы. Эти примеры демонстрируют базовую операцию,
 работа при наличии ретрансляций и многоадресной рассылки.

 На рисунке 16 показан базовый запрос GET, вызывающий совмещенный ответ:
 Клиент отправляет подтверждаемый запрос GET для ресурса.
 coap: // server / temperature на сервер с идентификатором сообщения 0x7d34.
 Запрос включает одну опцию Uri-Path (Delta 0 + 11 = 11, Length
 11, Значение «температура»); Токен остается пустым. Этот запрос является
 всего 16 байт. Ответ 2.05 (содержимое) возвращается в
 Сообщение с подтверждением, которое подтверждает подтвержденный запрос,
 повторяя как идентификатор сообщения 0x7d34, так и пустое значение токена. В
 ответ включает в себя полезную нагрузку «22,3 C» и имеет длину 11 байтов.

 Клиент-сервер
  | |
  | |
 | -----> | Заголовок: GET (T = CON, Code = 0,01, MID = 0x7d34)
| ПОЛУЧИТЬ | Uri-Path: "температура"
| |
| |
| <----- | Заголовок: 2.05 Содержимое (T = ACK, Code = 2.05, MID = 0x7d34)
| 2.05 | Полезная нагрузка: «22,3 с»
| |


  0 1 2 3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| - |
| 1 | 0 | 0 | GET = 1 | MID = 0x7d34 |
| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| - |
 | 11 | 11 | «температура» (11 B) ...
| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| - |

  0 1 2 3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| - |
 | 1 | 2 | 0 | 2,05 = 69 | MID = 0x7d34 |
| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| - |
 | 1 1 1 1 1 1 1 1 | «22,3 C» (6 B) ...
| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| - |

Рисунок 16: Подтверждаемый запрос; Совмещенный ответ






[стр. 104]




 На рисунке 17 показан аналогичный пример, но с включением не-
 пустой токен (значение 0x20) в запросе и ответе, увеличивая
 размеры до 17 и 12 байт соответственно.

 Клиент-сервер
  | |
  | |
 | -----> | Заголовок: GET (T = CON, Code = 0,01, MID = 0x7d35)
| ПОЛУЧИТЬ | Токен: 0x20
| | Uri-Path: "температура"
| |
| |
| <----- | Заголовок: 2.05 Содержимое (T = ACK, Code = 2.05, MID = 0x7d35)
| 2.05 | Токен: 0x20
| | Полезная нагрузка: «22,3 с»
| |


  0 1 2 3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| - |
| 1 | 0 | 1 | GET = 1 | MID = 0x7d35 |
| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| - |
| 0x20 |
| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| - |
 | 11 | 11 | «температура» (11 B) ...
| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| - |


  0 1 2 3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| - |
| 1 | 2 | 1 | 2,05 = 69 | MID = 0x7d35 |
| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| - |
| 0x20 |
| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| - |
 | 1 1 1 1 1 1 1 1 | «22,3 C» (6 B) ...
| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| -| - |

Рисунок 17: Подтверждаемый запрос; Совмещенный ответ











[стр. 105]




 На рисунке 18 подтвержденный запрос GET потерян. После ACK_TIMEOUT
 секунд, клиент повторно передает запрос, в результате
 совмещенный ответ, как в предыдущем примере.

 Клиент-сервер
  | |
  | |
 | ---- X | Заголовок: GET (T = CON, Code = 0,01, MID = 0x7d36)
| ПОЛУЧИТЬ | Токен: 0x31
| | Uri-Path: "температура"
 ТАЙМ-АУТ |
| |
 | -----> | Заголовок: GET (T = CON, Code = 0,01, MID = 0x7d36)
| ПОЛУЧИТЬ | Токен: 0x31
| | Uri-Path: "температура"
| |
| |
| <----- | Заголовок: 2.05 Содержимое (T = ACK, Code = 2.05, MID = 0x7d36)
| 2.05 | Токен: 0x31
| | Полезная нагрузка: «22,3 с»
| |

 Рисунок 18: Подтверждаемый запрос (переданный повторно); Совмещенный ответ




























[стр. 106]




 На рисунке 19 первое сообщение подтверждения от сервера к
 клиент потерян. Через ACK_TIMEOUT секунд клиент
 повторно передает запрос.

 Клиент-сервер
  | |
  | |
 | -----> | Заголовок: GET (T = CON, Code = 0,01, MID = 0x7d37)
| ПОЛУЧИТЬ | Токен: 0x42
| | Uri-Path: "температура"
| |
| |
| X ---- | Заголовок: 2.05 Содержимое (T = ACK, Code = 2.05, MID = 0x7d37)
| 2.05 | Токен: 0x42
| | Полезная нагрузка: «22,3 с»
 ТАЙМ-АУТ |
| |
 | -----> | Заголовок: GET (T = CON, Code = 0,01, MID = 0x7d37)
| ПОЛУЧИТЬ | Токен: 0x42
| | Uri-Path: "температура"
| |
| |
| <----- | Заголовок: 2.05 Содержимое (T = ACK, Code = 2.05, MID = 0x7d37)
| 2.05 | Токен: 0x42
| | Полезная нагрузка: «22,3 с»
| |

 Рисунок 19: Подтверждаемый запрос; Совместный ответ (передан повторно)























[стр. 107]




 На рисунке 20 сервер подтверждает подтверждаемый запрос и
 отправляет ответ 2.05 (контент) отдельно в подтверждающем сообщении.
 Обратите внимание, что сообщение подтверждения и подтверждаемый ответ делают
 не обязательно прибывать в том же порядке, в котором они были отправлены. В
 клиент подтверждает подтверждаемый ответ.

 Клиент-сервер
  | |
  | |
 | -----> | Заголовок: GET (T = CON, Code = 0,01, MID = 0x7d38)
| ПОЛУЧИТЬ | Токен: 0x53
| | Uri-Path: "температура"
| |
| |
| <- - - | Заголовок: (T = ACK, Code = 0.00, MID = 0x7d38)
| |
| |
| <----- | Заголовок: 2.05 Содержимое (T = CON, Code = 2.05, MID = 0xad7b)
| 2.05 | Токен: 0x53
| | Полезная нагрузка: «22,3 с»
| |
| |
 | - - -> | Заголовок: (T = ACK, Code = 0.00, MID = 0xad7b)
| |

Рисунок 20: Подтверждаемый запрос; Отдельный ответ

























[стр. 108]




 На рисунке 21 показан пример, в котором клиент теряет свое состояние (например,
 вылетает и перезагружается) сразу после отправки Подтверждаемого запроса,
 поэтому отдельный ответ, поступающий через некоторое время, приходит неожиданно.
 В этом случае клиент отклоняет Подтверждаемый ответ с помощью
 Сбросить сообщение. Обратите внимание, что неожиданный ACK игнорируется.

 Клиент-сервер
  | |
  | |
 | -----> | Заголовок: GET (T = CON, Code = 0,01, MID = 0x7d39)
| ПОЛУЧИТЬ | Токен: 0x64
| | Uri-Path: "температура"
    АВАРИЯ |
| |
| <- - - | Заголовок: (T = ACK, Code = 0.00, MID = 0x7d39)
| |
| |
| <----- | Заголовок: 2.05 Содержимое (T = CON, Code = 2.05, MID = 0xad7c)
| 2.05 | Токен: 0x64
| | Полезная нагрузка: «22,3 с»
| |
| |
 | - - -> | Заголовок: (T = RST, Code = 0.00, MID = 0xad7c)
| |

  Рисунок 21: Подтверждаемый запрос; Отдельный ответ (неожиданный)

 На рисунке 22 показан базовый запрос GET, где запрос и
 Ответ не подлежит подтверждению, поэтому оба могут быть потеряны без предварительного уведомления.

 Клиент-сервер
  | |
  | |
 | -----> | Заголовок: GET (T = NON, Code = 0.01, MID = 0x7d40)
| ПОЛУЧИТЬ | Токен: 0x75
| | Uri-Path: "температура"
| |
| |
| <----- | Заголовок: 2.05 Содержимое (T = NON, Code = 2.05, MID = 0xad7d)
| 2.05 | Токен: 0x75
| | Полезная нагрузка: «22,3 с»
| |

   Рисунок 22: неподтвержденный запрос; Неподтвержденный ответ







[стр. 109]




 На рисунке 23 клиент отправляет неподтвержденный запрос GET на
 многоадресный адрес: все узлы в локальной области связи. Есть 3
 серверы по ссылке: A, B и C. Серверы A и B совпадают
 ресурс, поэтому они отправляют обратно неподтвержденный 2.05 (контент)
 отклик. Ответ, отправленный B, потерян. C не имеет соответствия
 ответ, поэтому он отправляет неподтвержденный 4.04 (не найден)
 отклик.

 Клиент ff02 :: 1 ABC
  | | | | |
  | | | | |
 | ------> | | | | Заголовок: GET (T = NON, Code = 0.01, MID = 0x7d41)
| ПОЛУЧИТЬ | | | | Токен: 0x86
| | | | Uri-Path: "температура"
| | | |
| | | |
| <------------ | | | Заголовок: 2.05 (T = NON, Code = 2.05, MID = 0x60b1)
| 2.05 | | | Токен: 0x86
| | | | Полезная нагрузка: «22,3 с»
| | | |
| | | |
| X ------------ | | Заголовок: 2.05 (T = NON, Code = 2.05, MID = 0x01a0)
| 2.05 | | | Токен: 0x86
| | | | Полезная нагрузка: «20,9 с»
| | | |
| | | |
| <------------------ | Заголовок: 4.04 (T = NON, Code = 4.04, MID = 0x952a)
| 4.04 | | | Токен: 0x86
| | | |

  Рисунок 23: Неподтверждаемый запрос (многоадресная рассылка); Неподтвержденный
 Ответ

Приложение Б. Примеры URI

 В следующих примерах демонстрируются различные наборы параметров URI, а также
 результат после построения из них URI. В добавок к
 параметры, раздел 6.5 относится к IP-адресу и порту назначения,
 но не все пути алгоритма вызывают IP-адрес назначения
 и порт, который будет включен в URI.

* Ввод:

   IP-адрес назначения = [2001: db8 :: 2: 1]
   Порт назначения UDP = 5683






[стр. 110]




  Выход:

   coap: // [2001: db8 :: 2: 1] /

* Ввод:

   IP-адрес назначения = [2001: db8 :: 2: 1]
   Порт назначения UDP = 5683
   Uri-Host = "example.net"

  Выход:

   coap: //example.net/

* Ввод:

   IP-адрес назначения = [2001: db8 :: 2: 1]
   Порт назначения UDP = 5683
   Uri-Host = "example.net"
   Uri-Path = "хорошо известный"
   Uri-Path = "core"

  Выход:

   coap: //example.net/.well-known/core

* Ввод:

   IP-адрес назначения = [2001: db8 :: 2: 1]
   Порт назначения UDP = 5683
   Uri-Host = "xn - 18j4d.example"
   Uri-Path = строка, состоящая из символов Юникода U + 3053
   U + 3093 U + 306b U + 3061 U + 306f, обычно представлен в UTF-8 как
   E38193E38293E381ABE381A1E381AF шестнадцатеричный

  Выход:

   coap: //xn--18j4d.example/
   % E3% 81% 93% E3% 82% 93% E3% 81% AB% E3% 81% A1% E3% 81% AF

   (Разрыв строки вставлен для удобства чтения; это не
   часть URI.)









[стр. 111]




* Ввод:

   IP-адрес назначения = 198.51.100.1
   Порт назначения UDP = 61616
   Uri-Path = ""
   Uri-Path = "/"
   Uri-Path = ""
   Uri-Path = ""
   Uri-Query = "//"
   Uri-Query = "? &"

  Выход:

   coap: //198.51.100.1: 61616 //% 2F //?% 2F% 2F &?% 26

Адреса авторов

 Зак Шелби
 РУКА
 150 Розовый сад
 Сан-Хосе, Калифорния 95134
 США

 Телефон: + 1-408-203-9434
 Электронная почта: zach.shelby@arm.com

 Клаус Хартке
 Университет Бремена TZI
 Постфах 330440
 Бремен D-28359
 Германия

 Телефон: + 49-421-218-63905
 Электронная почта: hartke@tzi.org

 Карстен Борман
 Университет Бремена TZI
 Постфах 330440
 Бремен D-28359
 Германия

 Телефон: + 49-421-218-63921
 Электронная почта: cabo@tzi.org



[стр. 112]
